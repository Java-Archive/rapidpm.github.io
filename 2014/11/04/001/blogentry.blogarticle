<h2>Quiz</h2>

<b>1.</b> What JUnit version introduced annotations for handling the simple lifecycle?<br/>
    <ul>
    <li>since 1.0</li>
    <li>since 3.6</li>
    <li>since 4.0</li>
    <li>since 4.7</li></ul>

<b>2.</b> What is a difference of writing JUnit 3 tests in comparison to JUnit 4?<br/>
  <ul>  <li>there is no difference</li>
    <li>with a naming convention (for example with test as prefix for test methods)</li>
    <li>with annotations</li></ul>

<b>3.</b> Why should you prefer <i>@Before</i> annotated methods in comparison to the constructor? Because<br/>
   <ul> <li>it does not break the symmetry of the lifecycle</li>
    <li><i>@Before</i> should not be preferred</li>
    <li>better exception handling</li>
    <li>other frameworks rely on that</li>
    </ul>
<b>4.</b> Can you use more than one <i>@Before</i> annotated method in a test class?<br/>
   <ul> <li>yes</li>
    <li>no</li></ul>

<b>5.</b> Which method qualifiers must be used for a <i>@AfterClass</i> method?<br/>
   <ul> <li>protected</li>
    <li>static</li>
    <li>public</li>
    <li>final</li></ul>

<b>6.</b> What happens if a public method is annotated with <i>@Before</i>, <i>@Test</i> and <i>@After</i>?<br/>
    <ul><li>Runtime-/ValidationError</li>
    <li>CompilerError</li>
    <li>Runs fine</li></ul>

<b>7.</b> What is the best way (considering clean code) to handle exceptions?<br/>
    <ul><li>use try/catch</li>
    <li>use @Test(expected=....class)</li>
    <li>it is integrated in JUnit</li></ul>