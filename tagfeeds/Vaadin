<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Vaadin</title>
    <category label="Vaadin"/>
    <updated>2014-11-03T22:34:05.578+01:00</updated>
    <id>http://rapidpm.github.io</id>
    <author>
        <name>Marco Ebbinghaus</name>
    </author>
    <author>
        <name>Sven Ruppert</name>
    </author>
    <entry>
        <title>Vaadin: Markierte Zeile einer Tabelle editierbar machen</title>
        <category label="DefaultFieldFactory"/>
        <category label="Tabelle"/>
        <category label="TableFieldFactory"/>
        <category label="Vaadin"/>
        <published>2013-07-07T00:00:00+02:00</published>
        <author>
            <name>Marco Ebbinghaus</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/07/07/vaadin--markierte-zeile-einer-tabelle-.html&gt;Vaadin: Markierte Zeile einer Tabelle editierbar machen&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-07-07 from &lt;a href="/team/marco-ebbinghaus/"&gt;Marco Ebbinghaus&lt;/a&gt;&lt;/p&gt;
Hier ein kleines Tutorial über den Umgang mit Vaadin-Tabellen und deren Editierbarkeit. Der Anwendungsfall (aus der Praxis) ist simpel:&lt;br /&gt;
&lt;br /&gt;
Eine Tabelle enthält Entitäten des Typs &lt;i&gt;Parameter&lt;/i&gt;. Ein &lt;i&gt;Parameter &lt;/i&gt;besteht aus dem Parameter-Namen, einer Beschreibung, einem Standard-Wert und einem benutzerdefinierten Wert (welcher den Standard-Wert ersetzt). Die Vaadin-Tabelle enthält einen Container mit &lt;i&gt;Parameter&lt;/i&gt;-Beans und besteht somit aus den vier Spalten &lt;i&gt;Name, Beschreibung, Standard-Wert, benutzerdefinierter Wert&lt;/i&gt;. &lt;i&gt;Name, Beschreibung&lt;/i&gt; und &lt;i&gt;Standard-Wert&lt;/i&gt; sind fix, während der&lt;i&gt; benutzerdefinierte Wert&lt;/i&gt; editierbar sein soll.&lt;br /&gt;
&lt;br /&gt;
&lt;table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td style="text-align: center;"&gt;&lt;a href="http://3.bp.blogspot.com/-qWl7LhM7gzE/UdmFviRAh_I/AAAAAAAAAAg/zaS9wO2q9EA/s1600/vaadintable1.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"&gt;&lt;img border="0" height="159" src="http://3.bp.blogspot.com/-qWl7LhM7gzE/UdmFviRAh_I/AAAAAAAAAAg/zaS9wO2q9EA/s320/vaadintable1.png" width="320" /&gt;&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class="tr-caption" style="text-align: center;"&gt;Ziel&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;br /&gt;
&lt;br /&gt;
Um Vaadin-Tabellen editierbar zu machen existiert die Methode &lt;i&gt;setEditable(boolean b)&lt;/i&gt;. Wird dieser ein &lt;i&gt;true &lt;/i&gt;übergeben wird die gesamte Tabelle editierbar. Sprich: Alle Zellen werden zu Textfeldern. Oftmals ist dies natürlich nicht gewünscht da beispielsweise bestimmte Spalten nicht editierbar sein sollen (wie in unserem Fall). Um das Verhalten der Tabelle den eigenen Wünschen anzupassen muss man die von der Tabelle verwendete &lt;i&gt;TableFieldFactory &lt;/i&gt;überschreiben (standardmäßig wird hier eine Instanz der &lt;i&gt;DefaultFieldFactory &lt;/i&gt;verwendet, welche sämtliche Zellen der Tabelle editierbar macht). An dieser Stelle möchte ich etwas vorgreifen und schonmal die Codestelle zeigen, in welcher der Tabelle die neu implementierte FieldFactory zugewiesen wird. Die entsprechende Implementierung unserer eigenen TableFieldFactory folgt dann im Anschluss.&lt;br /&gt;
&lt;br /&gt;
&lt;code&gt;
parametersTable.addItemClickListener(new ItemClickEvent.ItemClickListener() {&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; @Override&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; public void itemClick(ItemClickEvent itemClickEvent) {&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; final CrawlerParameter crawlerParameter = (CrawlerParameter) itemClickEvent.getItemId();&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if(crawlerParameter == null){&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; buttonLeiste.setVisible(false);&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; parametersTable.setEditable(false);&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; } else {&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; buttonLeiste.setVisible(true);&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; parametersTable.setTableFieldFactory(new EditSelectedParamFieldFactory(crawlerParameter));&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; parametersTable.setEditable(true);&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; });&lt;br /&gt;
&lt;/code&gt;
Der Tabelle (parametersTable) wird ein ItemClickListener hinzugefügt welcher die itemClick()-Methode ausführt wenn eine Zeile der Tabelle durch den Benutzer markiert wurde. Innerhalb dieser Methode wird zuerst der vom Benutzer ausgewählte Parameter in einer entsprechenden Variable gespeichert. Achtung: &lt;span style="color: red;"&gt;Den aktuellen Parameter bekommt man nicht via parametersTable.getValue()! Dies liefert nicht den aktuell angeklickten Parameter, sondern den zuvor ausgewählten (Bei Benutzung dieser Methode ist man also immer genau einen Schritt hinterher). Der aktuell ausgewählte Parameter ist&amp;nbsp;per getValue()&amp;nbsp;erst NACH Durchführung der itemClick()-Methode abrufbar&lt;/span&gt;. Anschließend wird überprüft ob überhaupt ein Parameter ausgewählt ist. Ist dies nicht der Fall soll die Tabelle auch nicht editierbar sein, andernfalls bekommt die Tabelle eine neue FieldFactory - nämlich unsere eigene Implementation. Diese bekommt als Parameter den angeklickten Parameter übergeben (die Implementation folgt gleich). Anschließend wird die Tabelle editierbar gemacht (per setEditable(true)). Nun ist die Spalte BenutzerdefWert der ausgewählten Zeile editierbar.&lt;br /&gt;
&lt;br /&gt;
Lösen wir das Rätsel und schauen uns die EditSelectedParamFieldFactory-Implementation an:&lt;br /&gt;
&lt;br /&gt;
&lt;code&gt;
public class EditSelectedParamFieldFactory extends AbstractFieldFactory {&lt;br /&gt;
&lt;br /&gt;
&amp;nbsp; &amp;nbsp; private CrawlerParameter selectedCrawlerParameter;&lt;br /&gt;
&lt;br /&gt;
&amp;nbsp; &amp;nbsp; public EditSelectedParamFieldFactory(final CrawlerParameter selectedCrawlerParameter){&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; this.selectedCrawlerParameter = selectedCrawlerParameter;&lt;br /&gt;
&amp;nbsp; &amp;nbsp; }&lt;br /&gt;
&amp;nbsp; &amp;nbsp; @Override&lt;br /&gt;
&amp;nbsp; &amp;nbsp; public Field&amp;lt;?&amp;gt; createField(Container container, Object aParameter, Object spaltenname, Component uiContext) {&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; CrawlerParameter parameter = (CrawlerParameter)&amp;nbsp;aParameter;&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; switch(spaltenname.toString()){&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; case NAME:&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return null;&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; case DESCR:&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return null;&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; case DEFAULT_VALUE:&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return null;&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; case USER_VALUE:&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if(selectedCrawlerParameter != null){&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if(selectedCrawlerParameter.equals(parameter)){&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if(parameter.getDefaultValue().getClass() == Boolean.class) {&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return new CheckBox();&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if(parameter.getDefaultValue().getClass() == Integer.class) {&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; final TextField integerTextField = new TextField();&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; configureField(integerTextField, Integer.class);&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return integerTextField;&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if(parameter.getDefaultValue().getClass() == Double.class) {&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; final TextField doubleTextField = new TextField();&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; configureField(doubleTextField, Double.class);&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return doubleTextField;&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if(parameter.getDefaultValue().getClass() == String.class) {&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; final TextField textField = new TextField();&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; configureField(textField, String.class);&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return textField;&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; } else {&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return null;&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; default:&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return null;&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br /&gt;
&amp;nbsp; &amp;nbsp; }&lt;br /&gt;
}&lt;br /&gt;
&lt;/code&gt;
&lt;br /&gt;
&lt;code&gt;&lt;br /&gt;&lt;/code&gt;
Wie bereits erwähnt, muss ein selbst implementierte FieldFactory das Interface TableFieldFactory implementieren. Warum erweitert unsere Klasse also AbstractFieldFactory anstatt TableFieldFactory zu implementieren? Ganz einfach: Die Klasse AbstractFieldFactory ist abstrakt und implementiert das TableFieldFactory-Interface (zusätzlich wird in ihr die (für uns nun nicht relevante) Methode configureField() implementiert, welche die zu erstellenden Felder je nach enthaltenem Datentyp mit entsprechenden Validatoren etc. versieht). Wir implementieren also die Methode &amp;nbsp;public Field&amp;lt;?&amp;gt; createField(Container container, Object itemId, Object propertyId, Component uiContext) des TableFieldFactory-Interfaces. Außerdem besitzt die Klasse ein Attribut, welches den aktuell ausgewählten Parameter speichert. Für jede Zelle der Tabelle wird dann die Methode durchlaufen. Innerhalb der Methode wird bei jedem Durchlauf zunächst geprüft in welcher Zeile (CrawlerParameter parameter) und in welcher Spalte (switch(spaltenname.toString()) wir uns befinden. Befinden wir uns in einer Zelle der Spalten &lt;i&gt;Name&lt;/i&gt;, &lt;i&gt;Beschreibung&lt;/i&gt; oder &lt;i&gt;StandardWert &lt;/i&gt;ist eine Prüfung der Zeile unnötig, da Zellen dieser Spalten eh nicht editierbar sein sollen, egal ob es sich um die ausgewählte Zeile handelt oder nicht. Daher wird in diesen Fällen ein null-Wert zurückgegeben --&amp;gt; Die Zelle ist nicht editierbar. Falls wir uns in der &lt;i&gt;BenutzerdefWert&lt;/i&gt;-Spalte befinden wird überprüft ob es sich um die vom Benutzer ausgewählte Zeile handelt. Falls nicht, wird ebenfalls ein null zurückgegeben. Falls doch wird überprüft welchen Datentyp der Parameter besitzt (ist es ein boolescher Parameter, ein Integer-Parameter, ...?). Anschließend wird ein entsprechendes TextFeld (oder eine CheckBox bei einem booleschen Parameter) erstellt und mit entsprechenden Convertern/Validatoren etc. versehen. Anschließend wird das TextFeld bzw. die CheckBox zurückgegeben. Diese Zelle ist also nun editierbar. Damit haben wir das Ziel erreicht: Nur der benutzerdefinierte Wert des aktuell ausgewählten Parameters ist editierbar.&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Zusammenfassung&lt;/b&gt;&lt;br /&gt;
Soll nur die aktuell ausgewählte Zeile (bzw. Teile davon) der Tabelle editierbar sein so muss folgendes getan werden:&lt;br /&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;Tabelle einen ItemClickListener hinzufügen&lt;/li&gt;
&lt;li&gt;Im ItemClickListener wird der Tabelle eine Instanz einer selbst erstellten, das Interface &lt;i&gt;TableFieldFactory &lt;/i&gt;implementierenden, Klasse zugewiesen (setTableFieldFactory(new MyFieldFactory(currentSelectedEntity)) und die Tabelle auf editable gesetzt (setEditable(true)).&lt;/li&gt;
&lt;li&gt;In der eigenen Implementierung der TableFieldFactory (welche per Konstruktor-Parameter die selektierte Entität übergeben bekommt) wird überprüft ob es sich um eine Zelle handelt welche sich in der selektierten Zeile (und in einer editierbaren Spalte) befindet. Ist dies der Fall wird eine entsprechende Eingabe-Komponente (z.B. ein Textfeld oder eine CheckBox) erstellt und zurückgegeben (andernfalls wird &lt;i&gt;null &lt;/i&gt;zurückgegeben und die Zelle ist nicht editierbar).&lt;/li&gt;
&lt;/ul&gt;
&lt;table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td style="text-align: center;"&gt;&lt;a href="http://2.bp.blogspot.com/-5097075qitI/UdmF8mtS0FI/AAAAAAAAAAo/e1DZtGQ776I/s1600/vaadintable2.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"&gt;&lt;img border="0" height="158" src="http://2.bp.blogspot.com/-5097075qitI/UdmF8mtS0FI/AAAAAAAAAAo/e1DZtGQ776I/s320/vaadintable2.png" width="320" /&gt;&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class="tr-caption" style="text-align: center;"&gt;Hier werden alle Zellen der Spalte BenutzerdefWert editierbar gemacht, unabhängig von der Selektion&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>Introducing Vaadin: Validation</title>
        <category label="Client"/>
        <category label="Integer"/>
        <category label="Vaadin"/>
        <category label="Validation"/>
        <published>2013-09-03T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/09/03/introducing-vaadin--validation.html&gt;Introducing Vaadin: Validation&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-09-03 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
Let's talk about validation in Vaadin.&lt;br /&gt;
&lt;br /&gt;
&lt;h3&gt;
    Context&lt;/h3&gt;
We want to have a textfield which is marked as a "required" field and which expects integer values from 0 - 99. The user should get feedback&lt;b&gt; right after&lt;/b&gt; he entered something into the field.&lt;br /&gt;
&lt;br /&gt;
&lt;h3&gt;
    Implementation&lt;/h3&gt;
Here's the &lt;b&gt;complete&lt;/b&gt; code of the module:&lt;br /&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;
@SuppressWarnings("serial")
public class MyVaadinUI extends UI
{
    @Override
    protected void init(VaadinRequest request) {
        final TextField textField = new TextField("Enter an Integer value (0-99)");
        final FormLayout mainLayout = new FormLayout(textField);
        textField.setConverter(Integer.class);
        textField.addValidator(new IntegerRangeValidator("only integer, 0-99", 0, 99));
        textField.setRequired(true);
        textField.setImmediate(true);
        setContent(mainLayout);
    }
}&lt;/pre&gt;
&lt;pre&gt;-----&lt;/pre&gt;
&lt;b&gt;1&lt;/b&gt; Class&lt;br /&gt;
&lt;b&gt;7&lt;/b&gt; Lines of active code&lt;br /&gt;
&lt;b&gt;4&lt;/b&gt; &lt;b&gt;lines of code configuring the TextField (!)&lt;/b&gt;&lt;br /&gt;
&lt;b&gt;&lt;br /&gt;&lt;/b&gt;


&lt;br /&gt;
&lt;h3&gt;
    Result&lt;/h3&gt;
A red asterisk marks the field as required. After the user entered something into the field and the focus on the field is lost there is immediate feedback for the user.&lt;br /&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://3.bp.blogspot.com/-kaGZ1yDPL1w/UiWPpgSq8cI/AAAAAAAAAA4/JDAld5eiR3s/s1600/integererror.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="49" src="http://3.bp.blogspot.com/-kaGZ1yDPL1w/UiWPpgSq8cI/AAAAAAAAAA4/JDAld5eiR3s/s320/integererror.png" width="320" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://3.bp.blogspot.com/-NRcIVBy4mok/UiWPrWwaSpI/AAAAAAAAABA/293Fvk1KC58/s1600/stringerror.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="43" src="http://3.bp.blogspot.com/-NRcIVBy4mok/UiWPrWwaSpI/AAAAAAAAABA/293Fvk1KC58/s320/stringerror.png" width="320" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://1.bp.blogspot.com/-ErrK4ESPlyY/UiWPswcs6LI/AAAAAAAAABI/GVKcV_524Eo/s1600/noerror.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="45" src="http://1.bp.blogspot.com/-ErrK4ESPlyY/UiWPswcs6LI/AAAAAAAAABI/GVKcV_524Eo/s320/noerror.png" width="320" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
Does it look pretty? meh..&lt;br /&gt;
Does it work at a minimum of spent work and time? 4 lines of code?! Yea!
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>Using JavaScript libraries (D3) in Vaadin webapplications</title>
        <category label="D3"/>
        <category label="JavaScript"/>
        <category label="Vaadin"/>
        <published>2013-10-13T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/10/13/using-javascript-libraries-(d3)-in-vaa.html&gt;Using JavaScript libraries (D3) in Vaadin webapplications&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-10-13 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
This is a short tutorial on how to use JavaScript libraries with Vaadin.&lt;br /&gt;
&lt;br /&gt;
The library that shall be used is &lt;a href="http://d3js.org/"&gt;D3&lt;/a&gt;, which is a powerful library for creating data-driven diagrams using JavaScript.&lt;br /&gt;
&lt;br /&gt;
To keep it simple the final UI will look like this (see the screenshot at the end of the posting): We have a coordinate system in which we have a circle which can be moved inside that coordinate system. The coordinates can be entered in textfields and applied by clicking a button. Maybe there will be another post with some more meaningful use of D3 inside a Vaadin-Application in the future. But this tutorial aims on how to use JavaScript libraries inside Vaadin applications in general.. so let's start!&lt;br /&gt;
&lt;br /&gt;
We have to create two Java classes: &lt;b&gt;Diagram&lt;/b&gt;, &lt;b&gt;DiagramState&lt;/b&gt;&lt;br /&gt;
And we have to create one JavaScript file: &lt;b&gt;diagram_connector.js&lt;/b&gt;&lt;br /&gt;
&lt;br /&gt;
First, let's have a look at the Java classes "Diagram" and "DiagramState". The former extends "AbstractJavaScriptComponent". It is the component that is added to the UI in the end (like a Button or a TextField). The latter extends JavaScriptComponentState and is just needed for the communication between Vaadin and JavaScript (or server and client). Here is the code:&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Diagram&lt;/b&gt;&lt;br /&gt;
&lt;pre class="brush: java"&gt;@JavaScript({"d3.v3.min.js",
        "diagram_connector.js"})
public class Diagram extends AbstractJavaScriptComponent {

    public void setCoords(final List&amp;lt;Integer&amp;gt; coords) {
        getState().setCoords(coords);
    }

    @Override
    public DiagramState getState() {
        return (DiagramState) super.getState();
    }
}&lt;/pre&gt;
The @JavaScript annotation lists all JavaScrip files that have to be used. The first one is the D3 Library and the second one is the file that we have to create later. In my case both files are in the same folder in which the Vaadin UI-extending class is (AND I had to copy the files into my war manually, but that's a configuration issue of IntelliJ..).&lt;br /&gt;
&lt;br /&gt;
The setCoords method is used to give the Diagram component a list with the x- and y-coordinates of the position the circle should be moved to. The list is delegated to a corresponding attribute of the DiagramState.&lt;br /&gt;
&lt;br /&gt;
The overriden method getState looks always the same (with exception of the name of the State class, of course). &lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;DiagramState&lt;/b&gt;&lt;br /&gt;
&lt;pre class="brush: java"&gt;public class DiagramState extends JavaScriptComponentState {

    private List&amp;lt;Integer&amp;gt; coords;

    public List&amp;lt;Integer&amp;gt; getCoords() {
        return coords;
    }

    public void setCoords(final List&amp;lt;Integer&amp;gt; coords) {
        this.coords = coords;
    }
}&lt;/pre&gt;
The DiagramState class has an attribute which is a list of integers. It contains the x- and y-coordinates of the position the circle should be moved to (inside the coordinate system) as explained above. The rest is simple getters and setters for that attribute.&lt;br /&gt;
&lt;br /&gt;
Now let's have a look at the JavaScript file we have to create.&lt;br /&gt;
&lt;b&gt;&lt;br /&gt;&lt;/b&gt;
&lt;b&gt;diagram_connector.js&lt;/b&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;pre class="brush: javascript"&gt;window.org_rapidpm_vaadinwithjs_Diagram = function() {
    var diagramElement = this.getElement();
    var diagramFrame = d3.select(diagramElement).append("svg:svg").attr("width", 500).attr("height", 500);
    diagramFrame.append("svg:circle").attr("cx", 250).attr("cy", 250).attr("r", 20).attr("fill", "red");

    this.onStateChange = function() {
        var coords = this.getState().coords;
        d3.selectAll("circle").transition().attr("cx", parseInt(coords[0]));
        d3.selectAll("circle").transition().delay(500).attr("cy", parseInt(coords[1]));
    }
}
&lt;/pre&gt;
The first function assigment must always be done that way. Recognize that you assign a function to window.&amp;lt;fully qualified name of the class which extends AbstractJavaScriptComponent with underscores replacing the dots&amp;gt;.&lt;br /&gt;
&lt;br /&gt;
this.getElement() returns the corresponding DOM element for our diagram. (Think of document.getElementById(&amp;lt;the ID of the Diagram element&amp;gt;)).&lt;br /&gt;
&lt;br /&gt;
The following two lines are D3 related. We "select" our element and append a coordinate system to it with a width and height of 500. Then we insert a circle into that coordinate system at coordinates 250,250 (which is the center), a radius of 20 and a red fill color. For more information on how to use the D3 library in detail have a look at their website. There are some nice tutorials.&lt;br /&gt;
&lt;br /&gt;
The assignment of a function to this.onStateChange is always called when the state of the Diagram changes. This happens if we call the setCoords()-method of our Diagram class. If that is the case we get the coords from the Diagram's state. Recognize that coords (which is an Integer-List in the corresponding Java class) is a number array for JavaScript now. As next we select all circles (right, we only have one in our case). Then we move the circle to the new x- and y-coordinate (x = coords[0], y=coords[1]) via a transition (which simply looks cooler).&lt;br /&gt;
&lt;br /&gt;
That's all the magic. Now at last let's have a look at the main class with the init-method of our UI. We have to TextFields for x and y coordinate, a Button to apply the new coordinates and, of course, our Diagram which we can use as any other component as said above:&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;VaadinWithJavaScriptComponentsUI &lt;/b&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;public class VaadinWithJavaScriptComponentsUI extends UI {
    final VerticalLayout layout = new VerticalLayout();   
    final TextField xCoordField = new TextField("X");
    final TextField yCoordField = new TextField("Y");
    final Button button = new Button("move circle");
    final Diagram diagram = new Diagram();
    final List&amp;lt;Integer&amp;gt; coords = new ArrayList&amp;lt;&amp;gt;();

    @Override
    protected void init(VaadinRequest request) {

        configureIntegerField(xCoordField);     //not interesting, just adding converter/validator to the textFields
        configureIntegerField(yCoordField);

        button.addClickListener(new Button.ClickListener() {   //ATTENTION! Here we get the coordinates from the textfields and apply them to our Diagram via calling diagram.setCoords()
            @Override
            public void buttonClick(Button.ClickEvent event) {
                if(xCoordField.isValid() &amp;amp;&amp;amp; yCoordField.isValid()){
                    coords.clear();
                    coords.add(Integer.parseInt(xCoordField.getValue()));
                    coords.add(Integer.parseInt(yCoordField.getValue()));
                    diagram.setCoords(coords);
                }
            }
        })
        //now we build the layout.
        layout.setSpacing(true);
        layout.addComponent(xCoordField);
        layout.addComponent(yCoordField);
        layout.addComponent(button);
        layout.addComponent(diagram);     //add the diagram like any other vaadin component, cool!
        setContent(layout);
    }

    private void configureIntegerField(final TextField integerField) {
        integerField.setConverter(Integer.class);
        integerField.addValidator(new IntegerRangeValidator("only integer, 0-500", 0, 500));
        integerField.setRequired(true);
        integerField.setImmediate(true);
    }
}&lt;/pre&gt;
&lt;br /&gt;
That's it.
Here is a screenshot of the result and some (kind of unspectacular) animated pictures.&lt;br /&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
&lt;/div&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://2.bp.blogspot.com/-zuRvFBOm6jc/UlrtpHvmEfI/AAAAAAAAACU/hmEGqLwie7k/s1600/vaadinjs_First_Frame.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="179" src="http://2.bp.blogspot.com/-zuRvFBOm6jc/UlrtpHvmEfI/AAAAAAAAACU/hmEGqLwie7k/s320/vaadinjs_First_Frame.png" width="320" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br /&gt;
&lt;center&gt;
&lt;/center&gt;
&lt;center&gt;
    &lt;iframe allowfullscreen="" frameborder="0" height="315" src="//www.youtube.com/embed/Tm5SFhBHtaY" width="420"&gt;&lt;/iframe&gt;&lt;/center&gt;
&lt;br /&gt;
sources: &lt;br /&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href="https://vaadin.com/blog/-/blogs/vaadin-7-loves-javascript-components"&gt;https://vaadin.com/blog/-/blogs/vaadin-7-loves-javascript-components&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>Vaadin with CDI</title>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="Vaadin"/>
        <published>2013-11-18T00:00:00+01:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/11/18/vaadin-with-cdi.html&gt;Vaadin with CDI&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-11-18 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
Todays post will show a mini tutorial on how to use CDI with the current Vaadin version (7.1.8). To keep it simple, I will just extend the official Vaadin-HelloWorld-Program a bit.&lt;br /&gt;
&lt;br /&gt;
The normal Non-CDI-HelloWorld-Program works like that: There is a "Click Me"-Button on the screen and when you click that button, a label with the text "Thanks for clicking" is added below that button.&lt;br /&gt;
I will extend that HelloWorld-Program by using (injecting) our RapidPM-CDILogger which prints a WARN-Message on the console ("Button was clicked").&lt;br /&gt;
&lt;br /&gt;
The project structure looks like the following:&lt;br /&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://3.bp.blogspot.com/-OQBT3fV8CxA/UopF9jVPrII/AAAAAAAAACo/br335D8SVJs/s1600/structure.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="240" src="http://3.bp.blogspot.com/-OQBT3fV8CxA/UopF9jVPrII/AAAAAAAAACo/br335D8SVJs/s320/structure.PNG" width="320" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br /&gt;
&lt;br /&gt;
I created that Vaadin-project via Maven (see &lt;a href="https://vaadin.com/download"&gt;https://vaadin.com/download&lt;/a&gt;).&lt;br /&gt;
&lt;br /&gt;
To get the program working, we have to make the following changes:&lt;br /&gt;
&lt;ol&gt;
    &lt;li&gt;Add the Vaadin-CDI-support and the RapidPM-Modules as dependencies in the pom.xml&lt;/li&gt;
    &lt;li&gt;Create a log4j.properties in the resources-folder to configure the logger&lt;/li&gt;
    &lt;li&gt;Modify the Vaadin UI-Class (called MyVaadinUI per default)&lt;/li&gt;
&lt;/ol&gt;
That's all. So let's start:&lt;br /&gt;
&lt;br /&gt;
1)&lt;br /&gt;
Add the following dependency entries to the pom.xml:&lt;br /&gt;
&lt;br /&gt;
&lt;pre class="brush: xml"&gt;&amp;lt;dependency&amp;gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;groupId&amp;gt;com.vaadin&amp;lt;/groupId&amp;gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;artifactId&amp;gt;vaadin-cdi&amp;lt;/artifactId&amp;gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;version&amp;gt;1.0.0.alpha1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&amp;nbsp;
&amp;lt;dependency&amp;gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;groupId&amp;gt;org.rapidpm.modul&amp;lt;/groupId&amp;gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;artifactId&amp;gt;cdi-commons&amp;lt;/artifactId&amp;gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;version&amp;gt;1.2-SNAPSHOT&amp;lt;/version&amp;gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;type&amp;gt;jar&amp;lt;/type&amp;gt;
&amp;lt;/dependency&amp;gt; &lt;/pre&gt;
&lt;br /&gt;
The first dependency is needed to get Vaadin working with CDI, the second is needed to use our RapidPM-Logger.&lt;br /&gt;
&lt;span style="color: red;"&gt;Attention&lt;/span&gt;: The logger won't work with cdi-commons in version 1.1.1&lt;br /&gt;
&lt;br /&gt;
2)&lt;br /&gt;
Create a file called log4j.properties:&lt;br /&gt;
&lt;br /&gt;
&lt;pre class="brush: xml"&gt;log4j.rootLogger=DEBUG,stdout
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target=System.out
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m%n&lt;/pre&gt;
&lt;br /&gt;
That file is needed for log4j, which is used by our CDILogger. Put it into src/main/resources. I had to create that resources-folder and mark it as a source-folder manually.&lt;br /&gt;
&lt;br /&gt;
3)&lt;br /&gt;
Modify the MyVaadinUI-Class so it looks like the following:&lt;br /&gt;
&lt;pre class="brush: java"&gt;import com.vaadin.annotations.Theme;
import com.vaadin.annotations.VaadinServletConfiguration;
import com.vaadin.cdi.CDIUI;
import com.vaadin.server.VaadinRequest;
import com.vaadin.server.VaadinServlet;
import com.vaadin.ui.Button;
import com.vaadin.ui.Button.ClickEvent;
import com.vaadin.ui.Label;
import com.vaadin.ui.UI;
import com.vaadin.ui.VerticalLayout;
import org.rapidpm.demo.cdi.commons.logger.CDILogger;
import org.rapidpm.module.se.commons.logger.Logger;

import javax.inject.Inject;
import javax.servlet.annotation.WebServlet;

@Theme("mytheme")
@SuppressWarnings("serial")
@CDIUI
public class MyVaadinUI extends UI
{

    /*
    @WebServlet(value = "/*", asyncSupported = true)
    @VaadinServletConfiguration(productionMode = false, ui = MyVaadinUI.class, widgetset = "VaadinWithCDI.AppWidgetSet")
    public static class Servlet extends VaadinServlet {
    }
    */

    @Inject
    @CDILogger
    private Logger logger;

    @Override
    protected void init(VaadinRequest request) {
        final VerticalLayout layout = new VerticalLayout();
        final Button button = new Button("Click Me");
        button.addClickListener(new Button.ClickListener() {
            public void buttonClick(ClickEvent event) {
                layout.addComponent(new Label("Thank you for clicking"));
                logger.warn("Button was clicked");
            }
        });
        configureLayout(layout, button); //Only configuring layouting-issues
    }

    private void configureLayout(final VerticalLayout layout, final Button button) {
        layout.setMargin(true);
        layout.setWidth("100%");
        layout.addComponent(button);
        setContent(layout);
    }
}&lt;/pre&gt;
Explanation:&lt;br /&gt;
- The&amp;nbsp;@CDIUI Annotation at line 19 is needed to make the project use CDI. &lt;br /&gt;
- Recognize that the inner class at lines 24-27 must be commented out (you can delete those lines completely, of course). If this isn't commented out the Logger is not injected properly and a NullPointerException is thrown when calling methods of it.&lt;br /&gt;
- The CDILogger is injected in lines 30-32&lt;br /&gt;
- When the button is clicked, a label is added to the layout and a WARN-message is posted on the console via our logger (lines 40/41).&lt;br /&gt;
&lt;br /&gt;
-----------------------------&lt;br /&gt;
&lt;br /&gt;
The result looks like the following:&lt;br /&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://3.bp.blogspot.com/-sx_9t_rnK1Q/UopGFl2xv4I/AAAAAAAAACw/9N0gKNtdG48/s1600/result.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="146" src="http://3.bp.blogspot.com/-sx_9t_rnK1Q/UopGFl2xv4I/AAAAAAAAACw/9N0gKNtdG48/s320/result.PNG" width="320" /&gt;&lt;/a&gt;&lt;/div&gt;
links:&lt;br /&gt;
-&amp;nbsp; &lt;a href="https://vaadin.com/wiki/-/wiki/Main/Vaadin-CDI-integration"&gt;Vaadin-CDI-integration&lt;/a&gt; &lt;br /&gt;
&lt;br /&gt;
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
</feed>
