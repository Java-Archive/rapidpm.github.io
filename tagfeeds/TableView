<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>TableView</title>
    <category label="TableView"/>
    <updated>2014-07-21T21:24:53.686+02:00</updated>
    <id>http://rapidpm.github.io</id>
    <author>
        <name>Sven Ruppert</name>
    </author>
    <entry>
        <title>MultiLevel DrillDownPieChart in less then 30min as component for TableViews</title>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="Java"/>
        <category label="JavaFX"/>
        <category label="RapidPM"/>
        <category label="TableView"/>
        <category label="Weld"/>
        <published>2013-09-03T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/09/03/multilevel-drilldownpiechart-in-less-t.html&gt;MultiLevel DrillDownPieChart in less then 30min as component for TableViews&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-09-03 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
&lt;div style="text-align: center;"&gt;
    &lt;i&gt;&lt;span style="font-size: x-small;"&gt;The full code and demo jUnit you will find under :&amp;nbsp;&lt;a href="https://bitbucket.org/rapidpm/modules/src/265b5f577e8f9b5a875408a9659d58a02f72b1af/javafx-chart-pie-drilldown?at=develop" target="_blank"&gt;BitBucket Repo - RapidPM - Modules - javafx-chart-pie-drilldown&lt;/a&gt;&amp;nbsp;&lt;/span&gt;&lt;/i&gt;&lt;/div&gt;
&lt;div style="text-align: center;"&gt;
    &lt;i&gt;&lt;span style="font-size: x-small;"&gt;Please use the develop branch and a commit after&amp;nbsp;&lt;a href="https://bitbucket.org/rapidpm/modules/commits/265b5f577e8f9b5a875408a9659d58a02f72b1af?at=develop"&gt;265b5f5&lt;/a&gt;&amp;nbsp;&lt;/span&gt;&lt;/i&gt;&lt;/div&gt;
&lt;br /&gt;
Sometimes you want to have a drill down pi chart for a tableview. This code often looks like the following &lt;br /&gt;
(example from the oracle side)&lt;br /&gt;
&lt;a href="http://lh5.ggpht.com/-5KuGN_tnaic/UiYI9GTqX6I/AAAAAAABTXI/CKp7qJaPg8M/s1600-h/image%25255B3%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-ydmWK3GgtJk/UiYI9gFkecI/AAAAAAABTXM/tsHeNgJAvL0/image_thumb%25255B1%25255D.png?imgmax=800" height="484" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="530" /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
What you can see, is the direct way of putting the data together for each drilldown-level.&lt;br /&gt;
But if you want to drill down more than one level.. the code will be long.&lt;br /&gt;
For this example I am using the following demo data table.&lt;br /&gt;
&lt;br /&gt;
&lt;a href="http://lh6.ggpht.com/-Dln9HPL38mw/UiYI-gzJA7I/AAAAAAABTXY/l7uE_hEpjOc/s1600-h/image%25255B8%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh3.ggpht.com/-SnrHBEPMMHM/UiYI_MHshTI/AAAAAAABTXc/jFwz7iu2k_w/image_thumb%25255B4%25255D.png?imgmax=800" height="244" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="231" /&gt;&lt;/a&gt;&lt;br /&gt;
What I want to reach is a short way for a developer to aggregate from one row to an other (in both directions)&lt;br /&gt;
Here the pie–chart for this demo data and clicking the following steps:&lt;br /&gt;
Rows: Vorname-&amp;gt;Nachname-&amp;gt;Datum-&amp;gt;Betrag &lt;br /&gt;
Data: Holger-&amp;gt;Hoppel-&amp;gt;2013.10.01-&amp;gt;122.0 &lt;br /&gt;
&lt;a href="http://lh6.ggpht.com/-M8cJy_3fHmw/UiYI_txlqdI/AAAAAAABTXo/RRn5gXIi2LU/s1600-h/image%25255B11%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-CQyGxK2HMYI/UiYJAPlSEII/AAAAAAABTXs/ZZZHHNwgSFE/image_thumb%25255B5%25255D.png?imgmax=800" height="244" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="206" /&gt;&lt;/a&gt;&lt;a href="http://lh4.ggpht.com/-2_gTKMNX8mE/UiYJApNHhRI/AAAAAAABTX4/WFwxYSfYKUY/s1600-h/image%25255B14%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-FKGgdz6m5Co/UiYJBcGFtsI/AAAAAAABTYA/3Kyxlx2ij9Q/image_thumb%25255B6%25255D.png?imgmax=800" height="244" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; margin: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="191" /&gt;&lt;/a&gt;&lt;a href="http://lh4.ggpht.com/-IUAsBkI3mcs/UiYJCFnpZSI/AAAAAAABTYI/ILGKNlZsSsU/s1600-h/image%25255B17%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-K3YgnWkqaZM/UiYJCmmseGI/AAAAAAABTYQ/hDD7FDcvN90/image_thumb%25255B7%25255D.png?imgmax=800" height="244" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; margin: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="221" /&gt;&lt;/a&gt;&lt;a href="http://lh5.ggpht.com/-uIxOkfx3ZxU/UiYJDFf2Z7I/AAAAAAABTYY/hNh3S0nL0yo/s1600-h/image%25255B21%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-YUPfZV8MP3U/UiYJD_HH73I/AAAAAAABTYg/ZtSsq2GJljo/image_thumb%25255B9%25255D.png?imgmax=800" height="244" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="244" /&gt;&lt;/a&gt;&lt;br /&gt;
You can see, that for each level you will get the aggregated data from the table..&amp;nbsp; But how to do it?&lt;br /&gt;
The basic is the Aggregator-Class&lt;br /&gt;
&lt;script type="syntaxhighlighter" class="brush: java"&gt;&lt;![CDATA[
public abstract class MapAggregator&lt;T, K&gt; {

    private @Inject @CDILogger Logger logger;

    public abstract K getKeyElement(T t);

    public Map&lt;K, List&lt;T&gt;&gt; aggregate(final Collection&lt;T&gt; dataCollection) {
        final Map&lt;K, List&lt;T&gt;&gt; result = new HashMap&lt;&gt;();
        for (final T dataObject : dataCollection) {
            final K key = getKeyElement(dataObject);
            if (result.containsKey(key)) {
                if (logger.isDebugEnabled()) {
                    logger.debug("key schon vorhanden -&gt; " + key);
                }
            } else {
                result.put(key, new ArrayList&lt;T&gt;());
            }
            result.get(key).add(dataObject);
        }
        return result;
    }
}
]]&gt;&lt;/script&gt;
&lt;br /&gt;
&lt;span class="nt" style="background-color: ghostwhite; color: navy; font-family: Consolas, 'Liberation Mono', Courier, monospace; font-size: 14px; line-height: 19px; white-space: pre;"&gt;&lt;/span&gt;

With this you can aggregate a collection to a map. The key is the aggregated value from the collection elements.&lt;br /&gt;
For this example: A Collection of the TransientDemoDataRow (Collection&lt;transientdemodatarow&gt;) aggregated over the attribute vorname.&lt;/transientdemodatarow&gt;&lt;br /&gt;

&lt;script type="syntaxhighlighter" class="brush: java"&gt;&lt;![CDATA[
public class TransientDemoDataRow {


    private String vorname;
    private String nachname;
    private String datum;
    private Double betrag;

    @PostConstruct
    public void init() {

    }

    public String getVorname() {
        return vorname;
    }

    public void setVorname(String vorname) {
        this.vorname = vorname;
    }

    public String getNachname() {
        return nachname;
    }

    public void setNachname(String nachname) {
        this.nachname = nachname;
    }

    public String getDatum() {
        return datum;
    }

    public void setDatum(String datum) {
        this.datum = datum;
    }

    public Double getBetrag() {
        return betrag;
    }

    public void setBetrag(Double betrag) {
        this.betrag = betrag;
    }
}
]]&gt;&lt;/script&gt;
With our demo data table you will get a map with two collections. &lt;br /&gt;
a) Holger –&amp;gt; List of 6 elements&lt;br /&gt;
b) Willi –&amp;gt; List of 4 elements&lt;br /&gt;
This is the data for the first level of the DrillDownPieChart. (first pic of the pie charts see above)&lt;br /&gt;
For our DrillDownPieChart we are using the following aggregator extending the MapAggregator&lt;t&gt;.&lt;/t&gt;&lt;br /&gt;
&lt;t&gt;&lt;/t&gt;&lt;br /&gt;
&lt;script type="syntaxhighlighter" class="brush: java"&gt;&lt;![CDATA[
public abstract class DrillDownPieChartMapAggregator&lt;T&gt; extends MapAggregator&lt;T, String&gt; {


    /**
     * Calculate the Value for the PiChart.Data based on the aggregated values
     *
     * @param aggregatedValues
     * @return
     */
    public abstract double aggregateValue(List&lt;T&gt; aggregatedValues);

    public abstract String getLevelName();

    private DrillDownPieChartMapAggregator&lt;T&gt; nextLevelAggregator;
    private DrillDownPieChartMapAggregator&lt;T&gt; parentLevelAggregator;

    public DrillDownPieChartMapAggregator&lt;T&gt; getNextLevelAggregator() {
        return nextLevelAggregator;
    }

    public DrillDownPieChartMapAggregator&lt;T&gt; getParentLevelAggregator() {
        return parentLevelAggregator;
    }

    public void setNextLevelAggregator(DrillDownPieChartMapAggregator&lt;T&gt; nextLevelAggregator) {
        this.nextLevelAggregator = nextLevelAggregator;
        this.nextLevelAggregator.parentLevelAggregator = this;
    }

    public boolean isLastOne() {
        if (nextLevelAggregator == null) {
            return true;
        } else {
            return false;
        }
    }

    public boolean isFirstOne() {
        if (parentLevelAggregator == null) {
            return true;
        } else {
            return false;
        }
    }

}
]]&gt;&lt;/script&gt;
&lt;br /&gt;
We are holding the reference to the next level aggregator and the reference to the parent aggregator.&lt;br /&gt;
To implement the aggregator for each col. we want to use for our DrillDownPieChart we have to write code like the following&lt;br /&gt;
&lt;script type="syntaxhighlighter" class="brush: java"&gt;&lt;![CDATA[
public static class BetragAggregator extends DrillDownPieChartMapAggregator&lt;TransientDemoDataRow&gt; {
        @Override public double aggregateValue(List&lt;TransientDemoDataRow&gt; aggregatedValues) {
            double betrag = 0;
            for (final TransientDemoDataRow aggregatedValue : aggregatedValues) {
                betrag = betrag + aggregatedValue.getBetrag();
            }
            return betrag;
        }

        @Override public String getLevelName() {
            return "Betrag";
        }

        @Override public String getKeyElement(TransientDemoDataRow transientDemoDataRow) {
            return transientDemoDataRow.getBetrag() + " € Beträge";
        }
    }

    public static class DatumAggregator extends DrillDownPieChartMapAggregator&lt;TransientDemoDataRow&gt; {
        @Override public double aggregateValue(List&lt;TransientDemoDataRow&gt; aggregatedValues) {
            return aggregatedValues.size();
        }

        @Override public String getLevelName() {
            return "Datum";
        }
        @Override public String getKeyElement(TransientDemoDataRow transientDemoDataRow) {
            return transientDemoDataRow.getDatum();
        }
    }

    public static class VornameAggregator extends DrillDownPieChartMapAggregator&lt;TransientDemoDataRow&gt; {
        @Override public double aggregateValue(List&lt;TransientDemoDataRow&gt; aggregatedValues) {
            return aggregatedValues.size();
        }

        @Override public String getLevelName() {
            return "Vorname";
        }

        @Override public String getKeyElement(TransientDemoDataRow transientDemoDataRow) {
            return transientDemoDataRow.getVorname();
        }
    }


    public static class NachnameAggregator extends DrillDownPieChartMapAggregator&lt;TransientDemoDataRow&gt; {
        @Override public double aggregateValue(List&lt;TransientDemoDataRow&gt; aggregatedValues) {
            return aggregatedValues.size();
        }

        @Override public String getLevelName() {
            return "Nachname";
        }
        @Override public String getKeyElement(TransientDemoDataRow transientDemoDataRow) {
            return transientDemoDataRow.getNachname();
        }
    }

]]&gt;&lt;/script&gt;
&lt;br /&gt;
The method getLevelName is to label the PieChart for the user.&lt;br /&gt;
The method getKeyElement is the value used for the aggregation.&lt;br /&gt;
The method aggregateValue is to calculate the double, used by the pie chart as value.&lt;br /&gt;
After this you have to put all together… the logic-part is done now..&lt;br /&gt;
&lt;script type="syntaxhighlighter" class="brush: java"&gt;&lt;![CDATA[
public class DrillDownPieChartPaneController implements CDIJavaFxBaseController {

    @FXML DemoDrillDownPieChart piechart;


    @Inject Instance&lt;VornameAggregator&gt; vornameAggregatorInstance;
    @Inject Instance&lt;NachnameAggregator&gt; nachnameAggregatorInstance;
    @Inject Instance&lt;DatumAggregator&gt; datumAggregatorInstance;
    @Inject Instance&lt;BetragAggregator&gt; betragAggregatorInstance;


    @Override public void initialize(URL url, ResourceBundle resourceBundle) {

        //setze Aggregatoren
        final VornameAggregator vornameAggregator = vornameAggregatorInstance.get();

        final NachnameAggregator nachnameAggregator = nachnameAggregatorInstance.get();
        vornameAggregator.setNextLevelAggregator(nachnameAggregator);

        final DatumAggregator datumAggregator = datumAggregatorInstance.get();
        nachnameAggregator.setNextLevelAggregator(datumAggregator);

        final BetragAggregator betragAggregator = betragAggregatorInstance.get();
        datumAggregator.setNextLevelAggregator(betragAggregator);

        piechart.setRootAggregator(vornameAggregator);

    }


    public void init() {
        piechart.init();
    }

]]&gt;&lt;/script&gt;
The gui part looks like this: Extending the DrillDownPieChart with the type you need as data holder, here the TransientDemoDataRow.&lt;br /&gt;
&lt;script type="syntaxhighlighter" class="brush: java"&gt;&lt;![CDATA[
public class TransientDemoDataRow {


    private String vorname;
    private String nachname;
    private String datum;
    private Double betrag;

    @PostConstruct
    public void init() {

    }

    public String getVorname() {
        return vorname;
    }

    public void setVorname(String vorname) {
        this.vorname = vorname;
    }

    public String getNachname() {
        return nachname;
    }

    public void setNachname(String nachname) {
        this.nachname = nachname;
    }

    public String getDatum() {
        return datum;
    }

    public void setDatum(String datum) {
        this.datum = datum;
    }

    public Double getBetrag() {
        return betrag;
    }

    public void setBetrag(Double betrag) {
        this.betrag = betrag;
    }
}
]]&gt;&lt;/script&gt;
and putting it to a fxml file.&lt;br /&gt;
&lt;script type="syntaxhighlighter" class="brush: javafx"&gt;&lt;![CDATA[
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;?import gui.org.rapidpm.modul.javafx.chart.pie.drilldown.DemoDrillDownPieChart?&gt;
&lt;?import javafx.scene.control.Label?&gt;
&lt;?import javafx.scene.layout.AnchorPane?&gt;
&lt;?import javafx.scene.layout.VBox?&gt;
&lt;fx:root type="gui.org.rapidpm.modul.javafx.chart.pie.drilldown.DrillDownPieChartPane"
         fx:id="DrillDownPieChartPane" xmlns:fx="http://javafx.com/fxml" style="-fx-background-color:#EEEEEE"&gt;

    &lt;children&gt;
        &lt;AnchorPane minHeight="0.0" minWidth="0.0" VBox.vgrow="ALWAYS"
                    AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0"&gt;
            &lt;children&gt;
                &lt;Label text="hallo Hier bin ich"/&gt;
                &lt;DemoDrillDownPieChart fx:id="piechart"&gt;

                &lt;/DemoDrillDownPieChart&gt;
            &lt;/children&gt;
        &lt;/AnchorPane&gt;
    &lt;/children&gt;
&lt;/fx:root&gt;
]]&gt;&lt;/script&gt;
ready…&amp;nbsp; &lt;br /&gt;
&lt;br /&gt;
The steps for a developer are:&lt;br /&gt;
1) writing the transient data holder for an row –&amp;gt; TransientDemoDataRow&lt;br /&gt;
2) extending the DrillDownPieChart –&amp;gt; DemoDrillDownPieChart extends&lt;transientdemodatarow&gt;&lt;/transientdemodatarow&gt;&lt;br /&gt;
3) extending the DrillDownPieChartMapAggregator –&amp;gt; NachnameAggregator extends DrillDownPieChartMapAggregator&lt;transientdemodatarow&gt;&lt;/transientdemodatarow&gt;&lt;br /&gt;
4) putting all aggregator implementations together –&amp;gt; Controller – Class&lt;br /&gt;
5) add the element to the fxml file, &lt;br /&gt;
6) init() and ready&lt;br /&gt;
For a normal TableView with a handfull of rows you will need less than 30 min.&lt;br /&gt;
&lt;br /&gt;
The basic classes to use for an developer:&lt;br /&gt;
&lt;a href="http://lh3.ggpht.com/-SJ-pDNpLOMc/UiYJNA9ohpI/AAAAAAABTaY/ofUQV5uIuEk/s1600-h/image%25255B54%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh4.ggpht.com/-WMXinq5fTd8/UiYJNoBLSEI/AAAAAAABTag/WlbvOUwDZsk/image_thumb%25255B26%25255D.png?imgmax=800" height="484" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="513" /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
All classes from the jUnit demo available at the javafx-chart-pie-drilldown module.&lt;br /&gt;
&lt;a href="http://lh6.ggpht.com/-lP1udVyDMVA/UiYJOSIqFfI/AAAAAAABTao/rEssoxks5Gs/s1600-h/image%25255B58%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh3.ggpht.com/-LiWMRqCVT5A/UiYJPDrwyVI/AAAAAAABTaw/huD7OwGJooI/image_thumb%25255B28%25255D.png?imgmax=800" height="362" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="644" /&gt;&lt;/a&gt;

&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>CDI - ComboBoxCell - How to reduce 80% of code</title>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="FilteredTableView"/>
        <category label="Java"/>
        <category label="JavaFX"/>
        <category label="RapidPM"/>
        <category label="TableView"/>
        <category label="Weld"/>
        <published>2013-09-06T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/09/06/cdi-comboboxcell-how-to-reduce-80%-of-.html&gt;CDI - ComboBoxCell - How to reduce 80% of code&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-09-06 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
&lt;div style="text-align: center;"&gt;
    &lt;i&gt;&lt;span style="font-size: x-small;"&gt;The full code and demo jUnit you will find under :&amp;nbsp;&lt;a href="https://bitbucket.org/rapidpm/modules/src/aec4f95e0ae3130f62bc79170c0233cf49e43299/javafx-filtered-tableview?at=develop" target="_blank"&gt;BitBucket Repo - RapidPM - Modules - javafx-filtered-tableview&lt;/a&gt;&amp;nbsp;&lt;/span&gt;&lt;/i&gt;&lt;/div&gt;
&lt;div style="text-align: center;"&gt;
    &lt;i&gt;&lt;span style="font-size: x-small;"&gt;Please use the develop branch and a commit after&amp;nbsp;&lt;a href="https://bitbucket.org/rapidpm/modules/commits/265b5f577e8f9b5a875408a9659d58a02f72b1af?at=develop"&gt;aec4f95&lt;/a&gt;&amp;nbsp;&lt;/span&gt;&lt;/i&gt;&lt;/div&gt;
&lt;br /&gt;
&lt;br /&gt;
Today I had a TableView with the following function.&lt;br /&gt;
- In one column there was a ComboBoxCell.&lt;br /&gt;
- The values of this ComboBox was calculated / loaded at the moment the combobox was used.&lt;br /&gt;
- Each ComboBox will have different values based on the context of this row.&lt;br /&gt;
&lt;br /&gt;
The first version was something like this:&lt;br /&gt;
A ComboBoxCell:&lt;br /&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class LegacyBetragComboBoxCell extends ComboBoxTableCell&lt;TransientDemoDataRow, Double&gt; {

    private @Inject @CDILogger Logger logger;
    private boolean readOnlyView = false;

    @Inject Instance&lt;contextlogic&gt; contextLogicInstance; //some injected business logic;

    @Override
    public void updateItem(Double o, boolean b) {
        if (logger.isDebugEnabled()) {
            logger.debug("ComboBoxTableCell-&gt;updateItem " + o);
        }
        super.updateItem(o, b);
        if (o == null) {
            //
        } else {
            final TableRow tableRow = getTableRow();
            final TransientDemoDataRow row = (TransientDemoDataRow) tableRow.getItem();
            getItems().clear();
            if (row.getBetrag() == null || row.getBetrag().isInfinite() || row.getBetrag().isNaN()) {
                this.setDisable(true);
            } else if (readOnlyView) {
                this.setDisable(true);
            } else {
                final ContextLogic contextLogic = contextLogicInstance.get();
                final List&lt;double&gt; doubleList = contextLogic.workOnContext(row.getBetrag());

                getItems().addAll(doubleList);

                this.setDisable(false);
            }
            //application logic on row itself
            //application logic external
        }
    }


    public boolean isReadOnlyView() {
        return readOnlyView;
    }

    public void setReadOnlyView(boolean readOnlyView) {
        this.readOnlyView = readOnlyView;
    }
}
]]&gt;&lt;/script&gt;


and the code called from the controller:&lt;br /&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
    @Inject Instance&lt;legacybetragcomboboxcell&gt; legacyBetragComboBoxCellInstance;

    private void initTable() {
        final ObservableList&lt;TableColumn&lt;TransientDemoDataRow, ?&gt;&gt; columns = tableView.getColumns();
        for (final TableColumn&lt;TransientDemoDataRow, ?&gt; column : columns) {
            if(column.getText().equals("betrag")){
                final TableColumn&lt;TransientDemoDataRow, Double&gt; colTyped =(TableColumn&lt;TransientDemoDataRow, Double&gt;) column;
                colTyped.setCellFactory(new Callback&lt;TableColumn&lt;TransientDemoDataRow, Double&gt;, TableCell&lt;TransientDemoDataRow, Double&gt;&gt;() {
                    @Override public TableCell&lt;TransientDemoDataRow, Double&gt; call(TableColumn&lt;TransientDemoDataRow, Double&gt; transientDemoDataRowTableColumn) {
                        final LegacyBetragComboBoxCell cell = legacyBetragComboBoxCellInstance.get();
                        cell.setComboBoxEditable(false);  //true if you want bidirectional dataflow
                        return  cell;
                    }
                });

            } else{
                //other col
            }
        }
    }
]]&gt;&lt;/script&gt;

&lt;br /&gt;
This is to much boilerplate code. So I started to reduce it.&lt;br /&gt;
&lt;br /&gt;
First step was reducing the generics..&lt;br /&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
    @Inject Instance&lt;betragcomboboxcell&gt; betragComboBoxCellInstance;

    private void initTable() {
        final ObservableList&lt;TableColumn&lt;TransientDemoDataRow, ?&gt;&gt; columns = tableView.getColumns();
        for (final TableColumn column : columns) {
            if (column.getText().equals("betrag")) {
                column.setCellFactory(new Callback&lt;TableColumn, TableCell&gt;() {
                    @Override public TableCell call(TableColumn tableColumn) {
                        final BetragComboBoxCell cell = betragComboBoxCellInstance.get();
                        cell.setComboBoxEditable(false);  //true if you want bidirectional dataflow
                        return cell;
                    }
                });

            } else {
                //other col
            }
        }
    }
]]&gt;&lt;/script&gt;
This is shorter, but not better...&amp;nbsp;
&lt;br /&gt;
&lt;br /&gt;
The solution is the abstract GenericComboBoxCell. (part of the &lt;a href="https://bitbucket.org/rapidpm/modules/src/cd6e925b21196fc3e3a5f7b26abe879ed6add129/javafx-filtered-tableview?at=develop" target="_blank"&gt;javafx-filtered-tableview module&lt;/a&gt;)&lt;br /&gt;
&lt;br /&gt;
Iterating over the columns are now part of the GenericComboBoxCell, and here will be the typesave code.&lt;br /&gt;
&lt;br /&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public abstract class GenericComboBoxCell&lt;RT, VT&gt; extends ComboBoxTableCell&lt;RT, VT&gt; {

    private @Inject @CDILogger Logger logger;
    private boolean readOnlyView = false;

    @Override
    public void updateItem(VT o, boolean b) {
        if (logger.isDebugEnabled()) {
            logger.debug("ComboBoxTableCell-&gt;updateItem " + o);
        }
        super.updateItem(o, b);
        if (o == null) {
            //
        } else {
            final TableRow tableRow = getTableRow();
            final RT row = (RT) tableRow.getItem();
            getItems().clear();
            if (disableComboBox(row)) {
                this.setDisable(true);
            } else if (readOnlyView) {
                this.setDisable(true);
            } else {

                final List&lt;vt&gt; comboBoxValues = createComboBoxValues(row);
                getItems().addAll(comboBoxValues);

                this.setDisable(false);
            }
            workOnRowItself(row);
        }
    }

    public void associateWithCol(final TableView&lt;rt&gt; tableView, final String colName) {
        final ObservableList&lt;TableColumn&lt;RT, ?&gt;&gt; columns = tableView.getColumns();
        for (final TableColumn&lt;RT, ?&gt; column : columns) {
            final String columnText = column.getText();
            if (columnText.equals(colName)) {
                if (logger.isDebugEnabled()) {
                    logger.debug("associating to col " + columnText);
                }
                associate((TableColumn&lt;RT, VT&gt;) column);
            } else {
                if (logger.isDebugEnabled()) {
                    logger.debug("not binding to this col : " + columnText);
                }
            }
        }
    }

    private void associate(TableColumn&lt;RT, VT&gt; column) {
        column.setCellFactory(new Callback&lt;TableColumn&lt;RT, VT&gt;, TableCell&lt;RT, VT&gt;&gt;() {
            @Override
            public TableCell&lt;RT, VT&gt; call(TableColumn&lt;RT, VT&gt; rtTableColumn) {
                final GenericComboBoxCell&lt;RT, VT&gt; mySelf = getComboBoxCellRef();
                mySelf.setComboBoxEditable(false);
                mySelf.setReadOnlyView(readOnlyView);
                return mySelf;
            }
        });
    }

    protected abstract GenericComboBoxCell&lt;RT, VT&gt; getComboBoxCellRef();

    /**
     * logic to disable the combobox, for example if the value ist null or ...
     *
     * @return
     */
    public abstract boolean disableComboBox(final RT row);

    public abstract List&lt;vt&gt; createComboBoxValues(final RT row);

    public abstract void workOnRowItself(final RT row);


    public boolean isReadOnlyView() {
        return readOnlyView;
    }

    public void setReadOnlyView(boolean readOnlyView) {
        this.readOnlyView = readOnlyView;
    }
}
]]&gt;&lt;/script&gt;

The developer must extend this class and has to implement the following methods only:&lt;br /&gt;
- protected abstract GenericComboBoxCell&lt;rt vt=""&gt; getComboBoxCellRef();&amp;nbsp;&lt;/rt&gt;&lt;br /&gt;
&lt;rt vt=""&gt;- public abstract boolean disableComboBox(final RT row); (optional)&amp;nbsp;&lt;/rt&gt;&lt;br /&gt;
&lt;rt vt=""&gt;- public abstract List&lt;vt&gt; createComboBoxValues(final RT row);&amp;nbsp;&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;rt vt=""&gt;&lt;vt&gt;- public abstract void workOnRowItself(final RT row); (optional)&amp;nbsp;&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;rt vt=""&gt;&lt;vt&gt;A demo implementation is shown here:&amp;nbsp;&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class BetragComboBoxCell extends GenericComboBoxCell&lt;TransientDemoDataRow, Double&gt; {

    @Inject Instance&lt;contextlogic&gt; contextLogicInstance; //business logic
    @Inject Instance&lt;betragcomboboxcell&gt; betragComboBoxCellInstance; //the cell instance itself

    @Override
    protected GenericComboBoxCell&lt;TransientDemoDataRow, Double&gt; getComboBoxCellRef() {
        return betragComboBoxCellInstance.get();
    }

    @Override public boolean disableComboBox(TransientDemoDataRow row) {
        return row.getBetrag() == null || row.getBetrag().isInfinite() || row.getBetrag().isNaN();
    }

    @Override public List&lt;double&gt; createComboBoxValues(TransientDemoDataRow row) {
        final ContextLogic contextLogic = contextLogicInstance.get();
        final List&lt;double&gt; doubleList = contextLogic.workOnContext(row.getBetrag());
        return doubleList;
    }

    @Override public void workOnRowItself(TransientDemoDataRow row) {
        //nothing for this example
    }
}
]]&gt;&lt;/script&gt;


&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;rt vt=""&gt;&lt;vt&gt;The controlle will need a piece of code like this:&amp;nbsp;&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
    @Inject Instance&lt;betragcomboboxcell&gt; betragComboBoxCellInstance;

    private void initTable() {
        final BetragComboBoxCell cell = betragComboBoxCellInstance.get();
        cell.associateWithCol(tableView, "betrag");
    }
]]&gt;&lt;/script&gt;

&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;rt vt=""&gt;&lt;vt&gt;With this you can test the context logic indepentend from the javafx stuff.&amp;nbsp;&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;rt vt=""&gt;&lt;vt&gt;All initializations inside a ComboBoxCell must be done in a PostConstruct - method.&amp;nbsp;&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;rt vt=""&gt;&lt;vt&gt;With the&amp;nbsp;GenericComboBoxCell&amp;nbsp;you can activate/deactivate the combobox, modify the row cell values, and create the combobox values.&amp;nbsp;&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;rt vt=""&gt;&lt;vt&gt;This implementation is based on the JavaFX/CDI bootstrap from cdi-commons-fx. (blog entry &lt;a href="http://www.rapidpm.org/2013/08/cdicommonsfx-javafxcdi-bootstrap.html" target="_blank"&gt;JavaFX/CDI bootstrap&lt;/a&gt; )&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://2.bp.blogspot.com/-AQ7GFqVQD4U/Uin3Zyv-FxI/AAAAAAABTbs/Kp70aYegR3U/s1600/tableview001.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://2.bp.blogspot.com/-AQ7GFqVQD4U/Uin3Zyv-FxI/AAAAAAABTbs/Kp70aYegR3U/s1600/tableview001.jpg" height="216" width="320" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://2.bp.blogspot.com/-8qDppXPeXes/Uin3Z_Su-pI/AAAAAAABTb4/BLIB0FT2cLI/s1600/tableview002.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://2.bp.blogspot.com/-8qDppXPeXes/Uin3Z_Su-pI/AAAAAAABTb4/BLIB0FT2cLI/s1600/tableview002.jpg" height="218" width="320" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;rt vt=""&gt;&lt;vt&gt;UML of this demo:&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://1.bp.blogspot.com/-ePJ6s1IzMKE/Uiny8-L--tI/AAAAAAABTbY/3hK_OgfHDPc/s1600/uml.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img alt="" border="0" src="http://1.bp.blogspot.com/-ePJ6s1IzMKE/Uiny8-L--tI/AAAAAAABTbY/3hK_OgfHDPc/s1600/uml.png" height="608" title="" width="640" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;rt vt=""&gt;&lt;vt&gt;Full CDI dependicies&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://4.bp.blogspot.com/-1CreRx6oh_I/UinzViniCcI/AAAAAAABTbg/E6C0MdnnRTQ/s1600/cdi-deps.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://4.bp.blogspot.com/-1CreRx6oh_I/UinzViniCcI/AAAAAAABTbg/E6C0MdnnRTQ/s1600/cdi-deps.png" height="254" width="640" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>CDI Callback&lt;TableColumn, TableCell&gt; cellFactory - from FXML</title>
        <category label="Callback"/>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="JavaFX"/>
        <category label="RapidPM"/>
        <category label="TableView"/>
        <published>2013-09-19T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/09/19/cdi-callback-tablecolumn-tablecell-cel.html&gt;CDI Callback&lt;TableColumn, TableCell&gt; cellFactory - from FXML&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-09-19 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
How to get a full managed JavaFX-element declared in the fxml-file?&lt;br/&gt;

Let´s say we have something like the following:&lt;br/&gt;

&lt;script class="brush: javafx" type="syntaxhighlighter"&gt;&lt;![CDATA[
&lt;TableView fx:id="tableView" editable="true" VBox.vgrow="ALWAYS" style="-fx-font-size: 80%"
                   tableMenuButtonVisible="true"&gt;
    &lt;columns&gt;
        &lt;FilterableStringTableColumn prefWidth="120.0" text="vorname"&gt;
            &lt;cellFactory&gt;
                &lt;EditingAutoCompleteStringCellFactory/&gt;
            &lt;/cellFactory&gt;
            &lt;cellValueFactory&gt;
                &lt;PropertyValueFactory property="vorname"/&gt;
            &lt;/cellValueFactory&gt;
        &lt;/FilterableStringTableColumn&gt;
        &lt;FilterableStringTableColumn prefWidth="120.0" text="nachname"&gt;
            &lt;cellFactory&gt;
                &lt;EditingStringCellFactoryCallback/&gt;
            &lt;/cellFactory&gt;
            &lt;cellValueFactory&gt;
                &lt;PropertyValueFactory property="nachname"/&gt;
            &lt;/cellValueFactory&gt;
        &lt;/FilterableStringTableColumn&gt;
        &lt;FilterableDateTableColumn prefWidth="120.0" text="datum"&gt;
            &lt;cellFactory&gt;
                &lt;EditingDateCellFactoryCallback/&gt;
            &lt;/cellFactory&gt;
            &lt;cellValueFactory&gt;
                &lt;PropertyValueFactory property="datum"/&gt;
            &lt;/cellValueFactory&gt;
        &lt;/FilterableDateTableColumn&gt;
        &lt;FilterableDoubleTableColumn prefWidth="120.0" text="betrag"&gt;
            &lt;cellValueFactory&gt;
                &lt;PropertyValueFactory property="betrag"/&gt;
            &lt;/cellValueFactory&gt;
        &lt;/FilterableDoubleTableColumn&gt;
    &lt;/columns&gt;
&lt;/TableView&gt;
]]&gt;&lt;/script&gt;

This looks like a normal definition of a TableView with some cell-factories.
The intressting part is the instantiating of the cellFactory elements. They are
created from the JavaFX part. How to get them as full managed bean?&lt;br/&gt;

Based on my blog entry about  (&lt;a href="http://www.rapidpm.org/2013/08/cdicommonsfx-javafxcdi-bootstrap.html"&gt;CDI-JavaFX bootstrapping&lt;/a&gt;) I wanted to have full cdi managed JavaFX elements but defined in my fxml-file.&lt;br/&gt;

How to get this with a ComboBoxCell you can see here (&lt;a href="http://www.rapidpm.org/2013/09/cdi-comboboxcell-how-to-reduce-80-of.html"&gt;cdi comboboxcell how to reduce 80 of code&lt;/a&gt;)&lt;br/&gt;

The aproach was to define an element that is able to associate itself as CellFactory.
Only two line of code are used during the init - phase:&lt;br/&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
@Inject Instance&lt;BetragComboboxCell&gt; betragComboBoxCellInstance;
 
private void initTable() {
    final BetragComboBoxCell cell = betragComboBoxCellInstance.get();
    cell.associateWithCol(tableView, "betrag");
}
]]&gt;&lt;/script&gt;


BUT: the definition inside the fxml-file is &lt;br/&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
        &lt;FilterableDoubleTableColumn prefWidth="120.0" text="betrag"&gt;
            &lt;cellValueFactory&gt;
                &lt;PropertyValueFactory property="betrag"/&gt;
            &lt;/cellValueFactory&gt;
        &lt;/FilterableDoubleTableColumn&gt;
]]&gt;&lt;/script&gt;

You only could (implicit)define a normal CellFactory, because the creation of this element would be done by JavaFX.&lt;br/&gt;

Now I want to write a more precise fxml file.&lt;br/&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
&lt;FilterableStringTableColumn prefWidth="120.0" text="vorname"&gt;
            &lt;cellFactory&gt;
                &lt;EditingAutoCompleteStringCellFactory/&gt;
            &lt;/cellFactory&gt;
            &lt;cellValueFactory&gt;
                &lt;PropertyValueFactory property="vorname"/&gt;
            &lt;/cellValueFactory&gt;
        &lt;/FilterableStringTableColumn&gt;
]]&gt;&lt;/script&gt;

Now you could see, the CellFactory is well defined. Here an EditingAutoCompleteStringCellFactory.
This is an element with injected autocomplete functions/data.&lt;br/&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class EditingAutoCompleteStringCellFactory 
                implements Callback&lt;TableColumn&lt;FilteredTableDataRow, ?&gt;,
                                      TableCell&lt;FilteredTableDataRow, ?&gt;&gt;
]]&gt;&lt;/script&gt;

Inside this class you can use all cdi features.&lt;br/&gt;

The missing part is: How to get this as managed instance?&lt;br/&gt;
The short answer is.. make it managed by yourself ;-)&lt;br/&gt;

Let´s say the controller is a managed instance, you can get the BeanManager with&lt;br/&gt;

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
@Inject BeanManager beanManager;
]]&gt;&lt;/script&gt;

Now I started to get during the init-phase the right column&lt;br/&gt;

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
final ObservableList&lt;TableColumn&lt;TransientDemoDataRow, ?&gt;&gt; columns = tableView.getColumns();
for (final TableColumn&lt;TransientDemoDataRow, ?&gt; column : columns) {
 if(column.getText().equals("vorname")){ 
   //do something on column
 } else{
  //nothing to do
 }
}
]]&gt;&lt;/script&gt;

After you found the right column, start with the CDI-stuff
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
final TableColumn&lt;TransientDemoDataRow, String&gt; columnString = (TableColumn&lt;TransientDemoDataRow, String&gt;) column;

final Callback&lt;? extends TableColumn&lt;TransientDemoDataRow, String&gt;, ? extends TableCell&lt;TransientDemoDataRow,String&gt;&gt; cellFactory = columnString.getCellFactory();

final AnnotatedType&lt;EditingAutoCompleteStringCellFactory&gt; annotationType = beanManager.createAnnotatedType(EditingAutoCompleteStringCellFactory.class);

final InjectionTarget injectionTarget = beanManager.createInjectionTarget(annotationType);

final CreationalContext&lt;EditingAutoCompleteStringCellFactory&gt; creationalContext = beanManager.createCreationalContext(null);

                injectionTarget.inject(cellFactory, creationalContext);
                injectionTarget.postConstruct(cellFactory);

]]&gt;&lt;/script&gt;

Ready..   but this code is not nice...  and done for every column this is toooooo much code.&lt;br/&gt;

So I started to reduce it.&lt;br/&gt;
- reducing the generics..&lt;br/&gt;
- getting the class from the instance itself&lt;br/&gt;

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
final Callback cellFactory = column.getCellFactory();
final AnnotatedType annotationType = beanManager.createAnnotatedType(cellFactory.getClass());
final InjectionTarget injectionTarget = beanManager.createInjectionTarget(annotationType);
final CreationalContext creationalContext = beanManager.createCreationalContext(null);
injectionTarget.inject(cellFactory, creationalContext);
injectionTarget.postConstruct(cellFactory);
]]&gt;&lt;/script&gt;

Done..  OK, this is short and easy..  and you can do it for every column..&lt;br/&gt;

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
final ObservableList&lt;TableColumn&lt;TransientDemoDataRow, ?&gt;&gt; columns = tableView.getColumns();
for (final TableColumn&lt;TransientDemoDataRow, ?&gt; column : columns) {
 final Callback cellFactory = column.getCellFactory();
 final AnnotatedType annotationType = beanManager.createAnnotatedType(cellFactory.getClass());
 final InjectionTarget injectionTarget = beanManager.createInjectionTarget(annotationType);
 final CreationalContext creationalContext = beanManager.createCreationalContext(null);
 injectionTarget.inject(cellFactory, creationalContext);
 injectionTarget.postConstruct(cellFactory);
}
]]&gt;&lt;/script&gt;

or more generic...&lt;br/&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
final ObservableList&lt;TableColumn&lt;?, ?&gt;&gt; columns = tableView.getColumns();
for (final TableColumn&lt;?, ?&gt; column : columns) {
 final Callback cellFactory = column.getCellFactory();
 final AnnotatedType annotationType = beanManager.createAnnotatedType(cellFactory.getClass());
 final InjectionTarget injectionTarget = beanManager.createInjectionTarget(annotationType);
 final CreationalContext creationalContext = beanManager.createCreationalContext(null);
 injectionTarget.inject(cellFactory, creationalContext);
 injectionTarget.postConstruct(cellFactory);
}
]]&gt;&lt;/script&gt;

Now you can use CDI-managed elements as CellFactories and define them inside your fxml. &lt;br/&gt;

Nice, Managed and TypeSave&lt;br/&gt;
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>CDI ButtonCell</title>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="JavaFX"/>
        <category label="RapidPM"/>
        <category label="TableView"/>
        <category label="Weld"/>
        <published>2013-10-02T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/10/02/cdi-buttoncell.html&gt;CDI ButtonCell&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-10-02 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
&lt;div style="text-align: center;"&gt;
    &lt;i&gt;&lt;span style="font-size: x-small;"&gt;The full code and demo jUnit you will find under :&amp;nbsp;&lt;a href="https://bitbucket.org/rapidpm/modules/src/6e440e241875/javafx-filtered-tableview?at=release/1.1.1" target="_blank"&gt;BitBucket Repo - RapidPM - Modules - javafx-filtered-tableview&lt;/a&gt;&amp;nbsp;&lt;/span&gt;&lt;/i&gt;&lt;/div&gt;
&lt;div style="text-align: center;"&gt;
    &lt;i&gt;&lt;span style="font-size: x-small;"&gt;Please use the release/1.1.1 branch and a commit after&amp;nbsp;&lt;a href="https://bitbucket.org/rapidpm/modules/commits/6e440e241875c2f574741bd1f0e0749054996326"&gt;6e440e2&lt;/a&gt;&amp;nbsp;&lt;/span&gt;&lt;/i&gt;&lt;/div&gt;
&lt;br /&gt;

Today I needed a button inside my TableView.

Something needed to be activated, based on some other values in this row.

How to do this in a nice, lean and decoupled way? One goal was the possibillity that the definition could be done inside the fxml - file.

Let´s start with the basic cdi managed &lt;b&gt;ButtonCell&lt;/b&gt;:

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[ 
public abstract class ButtonCell&lt;T&gt; extends TableCell&lt;T, Boolean&gt; {

    public Button cellButton;
    public abstract String getButtonLabelText();
    private List&lt;ButtonCellAction&lt;T&gt;&gt; actionList = new ArrayList&lt;&gt;();

    private @Inject @CDILogger Logger logger;

    public ButtonCell() {

    }

    @PostConstruct
    public void init(){
        if (logger.isDebugEnabled()) {
            logger.debug("ButtonCell-&gt;init");
        }
        cellButton = new Button(getButtonLabelText());
        cellButton.setOnAction(new EventHandler&lt;ActionEvent&gt;() {
            @Override
            public void handle(ActionEvent t) {
                for (final ButtonCellAction&lt;T&gt; buttonCellAction : actionList) {
                    if (logger.isDebugEnabled()) {
                        logger.debug("execute buttonCellAction-&gt; " + buttonCellAction);
                    }
                    buttonCellAction.execute(ButtonCell.this, t);
                }
            }
        });
    }

    @Override
    protected void updateItem(Boolean t, boolean empty) {
        super.updateItem(t, empty);
        if (!empty) {
            setGraphic(cellButton);
        }
    }

    public static abstract class ButtonCellAction&lt;T&gt; {
        public abstract void execute(ButtonCell&lt;T&gt; buttonCell, ActionEvent t);
    }


    public List&lt;ButtonCellAction&lt;T&gt;&gt; getActionList() {
        return actionList;
    }
}
]]&gt;&lt;/script&gt;

The main part here is the method &lt;b&gt;setOnAction()&lt;/b&gt;: With this we are iterating over a list of ButtonCellActions.
&lt;br/&gt;
Now we have to implement a class for our used TableView. In this example an simple delete-button.
&lt;br/&gt;

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class DeleteButtonCell extends ButtonCell&lt;TransientDemoDataRow&gt; {

    private @Inject @CDILogger Logger logger;
    private @Inject @CDIPropertyRegistryService PropertyRegistryService propertyRegistryService;
    private @Inject DeleteButtonLogic logic;

    @Override public String getButtonLabelText() {
        return propertyRegistryService.getRessourceForKey("delete");
    }

    public DeleteButtonCell() {

    }

    @PostConstruct
    public void init(){
        super.init();
        if (logger.isDebugEnabled()) {
            logger.debug("DeleteButtonCell-&gt;init");
        }
        getActionList().add(new ButtonCellAction&lt;TransientDemoDataRow&gt;() {
            @Override public void execute(ButtonCell&lt;TransientDemoDataRow&gt; buttonCell, ActionEvent t) {
                if (logger.isDebugEnabled()) {
                    final Object source = t.getSource();
                    logger.debug("ButtonCellAction -&gt; " + source);
                }
                final TableRow tableRow = buttonCell.getTableRow();
            }
        });
    }
}
]]&gt;&lt;/script&gt;

At this point we are able to inject all the needed logic (here :&lt;b&gt;DeleteButtonLogic&lt;/b&gt;) to fullfill our task. The logic will be activated inside an implementtion of the class &lt;b&gt;ButtonCellAction&lt;/b&gt;. The order you are filling the Actions is the order the actions are processed. quite easy and mostly all you need.
&lt;br/&gt;
The implementation is easy, but we want to put this to an fxml file like the following?:

&lt;script class="brush: javafx" type="syntaxhighlighter"&gt;&lt;![CDATA[
&lt;TableColumn text="tcdelete" sortable="false"&gt;
 &lt;cellFactory&gt;
  &lt;DeleteButtonCellFactory/&gt;
 &lt;/cellFactory&gt;
 &lt;cellValueFactory&gt;
  &lt;DeleteButtonCellValueFactory/&gt;
 &lt;/cellValueFactory&gt;
&lt;/TableColumn&gt;
]]&gt;&lt;/script&gt;

For this we need the CellFactory and the CellValueFactory.
Both implementations are small:

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class DeleteButtonCellFactory
        implements Callback&lt;TableColumn&lt;TransientDemoDataRow, ?&gt;, TableCell&lt;TransientDemoDataRow, ?&gt;&gt; {

    @Inject Instance&lt;DeleteButtonCell&gt;  deleteButtonCellInstance;

    public DeleteButtonCellFactory() {
        CDIContainerSingleton.getInstance().activateCDI(this);
    }

    @Override public TableCell&lt;TransientDemoDataRow, ?&gt; call(TableColumn&lt;TransientDemoDataRow, ?&gt; column) {
        return deleteButtonCellInstance.get();
    }
}
]]&gt;&lt;/script&gt;

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class DeleteButtonCellValueFactory
        implements Callback&lt;TableColumn.CellDataFeatures&lt;TransientDemoDataRow, Boolean&gt;,ObservableValue&lt;Boolean&gt;&gt; {


    @Override public ObservableValue&lt;Boolean&gt; call(TableColumn.CellDataFeatures&lt;TransientDemoDataRow, Boolean&gt; p) {
        final TransientDemoDataRow value = p.getValue();
        return new SimpleBooleanProperty(value != null);
    }
}
]]&gt;&lt;/script&gt;

This is all..  and the result is nice and clean..
&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://4.bp.blogspot.com/-2UVVaH6biHA/Ukw537ReTJI/AAAAAAABUVc/mULLql4jTi0/s1600/uml-buttoncell.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://4.bp.blogspot.com/-2UVVaH6biHA/Ukw537ReTJI/AAAAAAABUVc/mULLql4jTi0/s400/uml-buttoncell.png" /&gt;&lt;/a&gt;&lt;/div&gt;

 
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
</feed>
