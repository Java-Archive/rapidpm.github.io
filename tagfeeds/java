<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Java</title>
    <category label="Java"/>
    <updated>2015-07-16T19:09:42.099+02:00</updated>
    <id>http://rapidpm.github.io</id>
    <author>
        <name>Sven Ruppert</name>
    </author>
    <author>
        <name>Alexander Bischof</name>
    </author>
    <author>
        <name>Oliver Milke</name>
    </author>
    <entry>
        <title>SPMT - Small Photo Management Tool</title>
        <category label="Java"/>
        <category label="Photos"/>
        <category label="SPMT"/>
        <published>2013-05-23T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/05/23/spmt-small-photo-management-tool.html&gt;SPMT - Small Photo Management Tool&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-05-23 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
Ich muss gestehen, dass ich gerne fotographiere. An sich ist das nichts schlimmes, nur die Ordnung zu behalten ist da doch ein wenig zeitaudfwendiger. &lt;br /&gt;
Aber für routine – Arbeiten gibt es ja zum Glück einen PC. Ich für meinen Teil habe das Problem zu lösen, das die Ordnerstruktur derzeitig sehr flach ist. Es gibt ein Verzeichnis in dem Pro Tag ein Verzeichnis existiert. Die Namenskonvention lautet hier yyyy-mm-dd_Thema_des_Tages.&lt;br /&gt;
Als Beispiel z.B. 2010.10.10_Geburtstag_XYZ&lt;br /&gt;
Das hat sich eigentlich bewährt, wenn man keine weiteren Ansprüche stellt. Nur was soll man machen wenn Bekannte auf einen zukommen die eine große Festplatte unter dem Armt tragen und um Hilfe bitten hier mal mit Werkzeugen die Bilder aufzuräumen.&lt;br /&gt;
Lange Rede kurzer Sinn, es schreit nach einen kleinen Werkzeug in der Programmiersprache meiner Wahl. Java&lt;br /&gt;
In einer kleinen Serie werde ich die Entwicklung der einzelnen Komponenten beschreiben.&lt;br /&gt;
Die Sourcen sind übrigens unter &lt;a href="https://bitbucket.org/svenruppert/spmt-smallphotomanagementtool" target="_blank"&gt;https://bitbucket.org/svenruppert/spmt-smallphotomanagementtool&lt;/a&gt; zu finden.&lt;br /&gt;
Hier nochmals der Hinweis: Es handelt sich um experimentelle Software die keinen Anspruch auf Fehlerfreiheit hat. Es kann gerne ausprobiert werden, aber bitte nur auf Kopien arbeiten. Die Software ist nicht “fertig” sondern befindet sich aus aktuellem Anlass mitten in der Entwicklung. (Stand 20130523)
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>JavaEE - Arquillian - first version to play</title>
        <category label="Arquillian"/>
        <category label="IDEA"/>
        <category label="IntelliJ"/>
        <category label="Java"/>
        <category label="JBoss"/>
        <category label="jUnit"/>
        <published>2013-05-29T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/05/29/javaee-arquillian-first-version-to-pla.html&gt;JavaEE - Arquillian - first version to play&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-05-29 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
Heute geht es um Arquillian und wie man ein Basisgerüst für die eigene Entwicklung aufbauen kann. Das Hier vorgestellte Projekt kann als Vorlage für eigene verwendet werden und ist die Vorbereitung für den eigenen Einsatz in einem neuen Projekt. Also kann ich es hier auch gleich ein wenig dokumentieren &amp;nbsp;;-)&lt;br /&gt;
Hier in dem Projekt wird JDK 8 verwendet, die Konfiguration selbst ist aber bis auf die Compiler-Anweisung neutral.&lt;br /&gt;
kurz: Was ist Arquillian?&lt;br /&gt;
Arquillian ist ein Framework um Tests in den JEE-Containern selbst laufen zu lassen. Soll bedeuten: Es hilft dabei die jUnit-Tests in embedded oder lokal oder remote ApplikationsServern auszuführen.&lt;br /&gt;
&lt;a href="http://arquillian.org/" target="_blank"&gt;Arquillian Homepage&lt;/a&gt; –&amp;gt; Unter &lt;a href="https://bitbucket.org/svenruppert/javaee-arquillian" target="_blank"&gt;Bitbucket - JavaEE – Arquillian&lt;/a&gt; sind alle Sourcen in einem Git-Repository.&lt;br /&gt;
&lt;br /&gt;
Zu Beginn werden die Grundlagen in der pom.xml definiert. Wichtig hierbei ist, dass nur die generischen Teile global definiert werden, die containerabhängigen Dinge in den Profilen. Damit wird erreicht, das durch die Auswahl des Profils der Laufzeitcontainer gewechselt/definiert wird. In der Pom habe ich die Konfiguration für GlassFish, Jboss und einen einfachen Weld-Container hinterlegt.&lt;br /&gt;
Interessant ist der Abschnitt im Profil &lt;strong&gt;arquillian-jbossas-managed&lt;/strong&gt;. Unter &lt;strong&gt;build-&amp;gt;testRessourcen&lt;/strong&gt; ist ein Beispiel zu sehen wie man für den jeweiligen Container eigene Ressourcen definiert.&lt;br /&gt;
&lt;br /&gt;
Die nächste Konfigurationsstelle ist die Datei&amp;nbsp; test/ressourcen/arquillian.xml. Hier können die Container selbst mit Konfigurationen belegt werden. In diesem Beispiel habe ich für den jbossas-managed gezeigt, wie man auf eine eigene Version eines JBoss zugreifen kann. Das ist notwendig, wenn man in den Embedded-Tests z.B. Oracle Treiber für DataSourcen benötigt. Es werden also alle Konfigurationen verwendet, die man evtl schon vorgenommen hat.&lt;br /&gt;
&lt;a href="http://lh6.ggpht.com/-88ntwCjrxVs/UaYkpOkzu3I/AAAAAAABQ2U/MRKWHjikjAA/s1600-h/image%25255B5%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-x0-zBfvvHvc/UaYkpyqTrQI/AAAAAAABQ2c/KyaLL5jY_Y0/image_thumb%25255B3%25255D.png?imgmax=800" height="388" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="865" /&gt;&lt;/a&gt;&lt;br /&gt;
Remote Test auf einem JBoss.&lt;br /&gt;
Um einen Test in einem Remote JBoss auszuführen, muss der Jboss zuerst gestartet werden. Wenn dieser hochgefahren ist, kann der Test via maven ausgeführt werden. In diesem Beispiel gehe ich davon aus, das der jboss auf localhost läuft.&lt;br /&gt;
In der Datei arquillian.xml unter &lt;strong&gt;jbossas-remot&lt;/strong&gt; ist der Port für den Debugger zu setzen. in meinem Fall 52197 was der Defaulteinstellung unter IntelliJ entspricht.&lt;br /&gt;
&lt;br /&gt;
Mit den Einstellungen kann schon begonnen werden. clean, compile, test. ;-)&lt;br /&gt;
Demnächst dann mehr mit praktischen Dingen…
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>CDI Commons - Dynamic Service Resolver</title>
        <category label="Arquillian"/>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="IDEA"/>
        <category label="IntelliJ"/>
        <category label="Java"/>
        <category label="jUnit"/>
        <category label="Weld"/>
        <published>2013-06-26T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/06/26/cdi-commons-dynamic-service-resolver.html&gt;CDI Commons - Dynamic Service Resolver&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-06-26 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In meinem Blog über CDi und i18n (&lt;a href="http://www.rapidpm.org/2013/06/cdi-commons-i18n.html" target="_blank"&gt;Artikel&lt;/a&gt;) hatte ich einen PropertyRegistryService vorgestellt.&lt;/p&gt; &lt;p&gt;Als Beispiel wurde der Producer für die Instanz eines SimpleDateFormat gezeigt. &lt;/p&gt; &lt;p&gt;&lt;a href="http://lh3.ggpht.com/-uHPakGHkaOQ/UcrzhykV6lI/AAAAAAABSKM/U5BFjin6KH4/s1600-h/image%25255B3%25255D.png"&gt;&lt;img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="http://lh4.ggpht.com/-nl3-2Ew87K8/UcrzihB3ncI/AAAAAAABSKU/f0Z4x6v8JGU/image_thumb%25255B1%25255D.png?imgmax=800" width="644" height="284"&gt;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;Nicht schön war die harte Kopplung der Implementierung des PropertyRegistryService. Per Annotation wurde&lt;/p&gt; &lt;p&gt;die Implementierung deklariert. &lt;strong&gt;@CDIPropertyRegistryFileBased&lt;/strong&gt; (im Blog noch @CDIFileBased)&lt;/p&gt; &lt;p&gt;Immer wieder muss aber zur Laufzeit entschieden werden welche Implementierung verwendet werden soll/muss.&lt;/p&gt; &lt;p&gt;Das kann verschiedene Gründe haben wie z.B. das derzeitige Lastverhalten, der angemeldete User und und und.&lt;/p&gt; &lt;p&gt;Wie also die Endscheidung vornehmen? &lt;/p&gt; &lt;p&gt;Zwei Dinge sind notwendig:&lt;/p&gt; &lt;p&gt;1) Das Interface der implementierenden Klasse, in unserem Fall PropertyRegistryService&lt;/p&gt; &lt;p&gt;2) und der Qualifier um den richtigen Producer zu selektieren.&lt;/p&gt; &lt;p&gt;&lt;a href="http://lh6.ggpht.com/-h00St984Puw/UcrzjsYJWqI/AAAAAAABSKY/_tdGiHgBOtM/s1600-h/image%25255B10%25255D.png"&gt;&lt;img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="http://lh3.ggpht.com/-qqqZ7bBXoYU/UcrzkSEbvAI/AAAAAAABSKk/uysM0o1UCdo/image_thumb%25255B6%25255D.png?imgmax=800" width="1028" height="436"&gt;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;Das Interface ist relativ leicht zu ermitteln. Mann kann es fest angeben, da man weiß das man genau dieses Interface benötigt.&lt;/p&gt; &lt;p&gt;Wenn auch das dynamisch ermittelt werden muss, kann man hier ähnlich wie bei den MessageRessourcen vorgehen. Es wird ein Key übergeben, der an anderer Stelle auf ein Interface gemappt wird. Hier einfach simuliert durch die Methode &lt;/p&gt; &lt;p&gt;&lt;strong&gt;Class mapp2Class(final String key)&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;Spannender wird es bei der Auswahl der richtigen Qualifiers. Das ist der Kern der Implementierung.&amp;nbsp; Simuliert wird es hier &lt;/p&gt; &lt;p&gt;durch die Methode &lt;strong&gt;resolveContextImpl().&lt;/strong&gt; Wie genau die Implementierung aussehen kann, hängt von der Umgebung ab und welche Parameter ausgewertet werden müssen.&lt;/p&gt; &lt;p&gt;Die Implementierung hier erzeugt ein &lt;strong&gt;AnnotationLiteral&amp;lt;CDIPropertyRegistryFileBased&amp;gt;.&lt;/strong&gt; Das ist wieder eine harte Kopplung, kann jedoch wieder durch einen Mappingmechanismus zur Laufzeit aufgelöst werden.&amp;nbsp; Am einfachsten,&amp;nbsp; in dem man eine Klasse dynamisch instanziiert, die von AnnotationLitaral erbt.&lt;/p&gt; &lt;p&gt;z.B.&lt;/p&gt; &lt;p&gt;&lt;a href="http://lh6.ggpht.com/-G1N0nxPr5Jw/UcrzlHIDuvI/AAAAAAABSKs/Los4mxtfuRs/s1600-h/image%25255B14%25255D.png"&gt;&lt;img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="http://lh4.ggpht.com/-y0L-RO_BVbQ/Ucrzl2JaOdI/AAAAAAABSK0/H3f7eFzzq1Y/image_thumb%25255B8%25255D.png?imgmax=800" width="644" height="118"&gt;&lt;/a&gt;&lt;/p&gt;  
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>Hot Swap in Java with DCEVM</title>
        <category label="IDEA"/>
        <category label="Java"/>
        <category label="jUnit"/>
        <category label="Tools"/>
        <published>2013-07-12T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/07/12/hot-swap-in-java-with-dcevm.html&gt;Hot Swap in Java with DCEVM&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-07-12 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
Immer auf der Suche nach neuen Werkzeugen…&amp;nbsp; Hier DCEVM (&lt;a href="http://ssw.jku.at/dcevm/" target="_blank"&gt;http://ssw.jku.at/dcevm/&lt;/a&gt;)&lt;br /&gt;
Und das beste: Es gibt es schon als intelliJ Plugin..&lt;br /&gt;
&lt;a href="http://blogs.jetbrains.com/idea/2013/07/get-true-hot-swap-in-java-with-dcevm-and-intellij-idea/" target="_blank"&gt;http://blogs.jetbrains.com/idea/2013/07/get-true-hot-swap-in-java-with-dcevm-and-intellij-idea/&lt;/a&gt;&lt;br /&gt;
das normale HotSwaping hat enge Grenzen sobald man an der Struktur der Klassen Veränderungen vornimmt. Hier gab es bisher immer noch das kommerzielle Werkzeug jRebel.&lt;br /&gt;
(Danke übrigens an das jRebel Team f die OSS Lizenz)&lt;br /&gt;
Nun gibt es eine OSS Lösung die genau an dieser Stelle weiterhilft. &lt;br /&gt;
Ich werde von meinen Tests berichten… &lt;img alt="Zwinkerndes Smiley" class="wlEmoticon wlEmoticon-winkingsmile" src="http://lh6.ggpht.com/-G022Pyxe_B0/Ud-RlflpOrI/AAAAAAABSkE/ULRusdSNp3Q/wlEmoticon-winkingsmile%25255B2%25255D.png?imgmax=800" style="border-bottom-style: none; border-left-style: none; border-right-style: none; border-top-style: none;" /&gt;
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>cdi.commons.logger - ProgrammingHandbook - RapidPM</title>
        <category label="Arquillian"/>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="Java"/>
        <category label="Weld"/>
        <published>2013-08-01T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/08/01/cdi.commons.logger-programminghandbook.html&gt;cdi.commons.logger - ProgrammingHandbook - RapidPM&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-08-01 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
&lt;div style="background-color: white; color: #333333; font-family: Arial, sans-serif; font-size: 14.666666984558105px; line-height: 26.66666603088379px; margin-top: 10px;"&gt;
Die Definition eines Loggers gehört zu fast jeder Klasse. Immer wieder ist der Logger zu definieren und in diesem Zuge dann auch die Entscheidung zu treffen, welcher Logger zu verwenden ist.&lt;/div&gt;
&lt;div style="background-color: white; color: #333333; font-family: Arial, sans-serif; font-size: 14.666666984558105px; line-height: 26.66666603088379px; margin-top: 10px;"&gt;
Nachträglich dieses zu ändern bedeutet immer, alle Klassen zu modifizieren. Es geht auch anders..&lt;/div&gt;
&lt;div style="background-color: white; color: #333333; font-family: Arial, sans-serif; font-size: 14.666666984558105px; line-height: 26.66666603088379px; margin-top: 10px;"&gt;
... siehe&amp;nbsp;&lt;/div&gt;
&lt;a href="http://wiki.rapidpm.org/display/PHB/cdi.commons.logger"&gt;cdi.commons.logger - ProgrammingHandbook - RapidPM&lt;/a&gt;: &lt;br /&gt;
&lt;br /&gt;
&lt;a href="https://chrome.google.com/webstore/detail/pengoopmcjnbflcjbmoeodbmoflcgjlk" style="font-size: 13px;"&gt;'via Blog this'&lt;/a&gt;
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>Grundgedanke: Warum CDI</title>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="Java"/>
        <category label="Weld"/>
        <published>2013-08-02T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/08/02/grundgedanke--warum-cdi.html&gt;Grundgedanke: Warum CDI&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-08-02 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
Grundgedanke: Warum CDI? (&lt;a href="http://wiki.rapidpm.org/display/PHB/02+-+CDI+for+JavaEE+and+JavaSE" target="_blank"&gt;Wiki&lt;/a&gt;) &lt;br /&gt;
CDI als eine Technik die auf der SE als auch auf der EE Seite zur Verfügung steht ist ein mächtiges Werkzeug um Quelltext in einer Anwendung zu entkoppeln.  &lt;br /&gt;
Der modulare Aufbau kann auf einfache Art und Weise unterstützt und bei Alt-Anwendungen eingeführt werden.  &lt;br /&gt;
&lt;b&gt;kürzere Notation?&lt;/b&gt;&lt;br /&gt;Manchmal ist die Notation per Inject kürzer. Sobald allerdings die einzelnen Qualifier dazukommen, ist meist der Aufwand zum Aufruf eines Konstruktors kaum unterschiedlich.  &lt;br /&gt;
&lt;b&gt;lösen von statischen Abhängigkeiten?&lt;/b&gt;&lt;br /&gt;Dieser Punkt ist einer der Wesentlichen. Wie kann man zur Entwicklungszeit die Abhängigkeiten zu den anderen Projektmodulen möglichst gering halten?&lt;br /&gt;Gehen wir von der Definition einer Liste aus. Als Rückgabewert einer Methode wird die List verwendet.  &lt;br /&gt;
&lt;b&gt;Definition Rückgabewert&lt;/b&gt;  &lt;br /&gt;
&lt;a href="http://lh4.ggpht.com/-d-b41AM1HyQ/UftGL4WdLuI/AAAAAAABS8s/oGfAp2F9_EA/s1600-h/image%25255B28%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh4.ggpht.com/-j1uXwlxRVDo/UftGMdAbWjI/AAAAAAABS80/tnx7-9PIgr8/image_thumb%25255B20%25255D.png?imgmax=800" height="69" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="437" /&gt;&lt;/a&gt;  &lt;br /&gt;
Damit sind nachfolgende Aufrufer nicht mehr an die Implementierung der List gebunden. In der Methode jedoch besteht meist die Abhängigkeit zu der entsprechenden Implementierung obwohl auch das meist nicht notwendig ist.  &lt;br /&gt;
&lt;b&gt;Erzeugen der Liste&lt;/b&gt;  &lt;br /&gt;
&lt;code&gt;&lt;a href="http://lh4.ggpht.com/-7I3g1Dg0N14/UftGMotqprI/AAAAAAABS88/_I8F01DVLhM/s1600-h/image%25255B27%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh6.ggpht.com/-Q9Pu7l58d_Q/UftGNH6eGCI/AAAAAAABS9E/7YyW5wH005M/image_thumb%25255B19%25255D.png?imgmax=800" height="206" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="437" /&gt;&lt;/a&gt;&lt;/code&gt;  &lt;br /&gt;
&lt;code&gt;&lt;/code&gt; &lt;br /&gt;
Gehen wir davon aus, dass keine spezifischen Methoden der ArrayList verwendet werden. Selten werden Methoden wie z.B. trimToSize() verwendet. Somit ist die statische Abhängigkeit zu der ArrayList nicht notwendig. Sollte sich zur Laufzeit herausstellen, das die Wahl dieser Implementierung nicht optimal gewesen ist, muss der Quelltext angepasst und neu verteilt werden. Mit std SE Mitteln kann man das durch entsprechende Factories lösen. Beispielhaft soll hier folgende Implementierung verwendet werden.  &lt;br /&gt;
&lt;b&gt;Definition ListFactory&lt;/b&gt;  &lt;br /&gt;
&lt;code&gt;&lt;a href="http://lh6.ggpht.com/-MpWEc3Vj5Ss/UftGNUj5LWI/AAAAAAABS9M/Bv4kRfLVI1w/s1600-h/image%25255B15%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-n3H4xK_UpBQ/UftGN8uScSI/AAAAAAABS9U/_tYw3ap0ImU/image_thumb%25255B9%25255D.png?imgmax=800" height="484" style="background-image: none; border-bottom-width: 0px; border-left-width: 0px; border-right-width: 0px; border-top-width: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="437" /&gt;&lt;/a&gt;&lt;/code&gt;  &lt;br /&gt;
Der Entwickler selbst schreibt nun seinen Quelltext unter Verwendung der Factory. Die Factory sollte unter Umständen immer neu erzeugt werden, um Nebenläufigkeitsprobleme sofort auszuschliessen. Selbstverständlich kann auch die Factory threadsave programmiert werden, im schlimmsten Fall mit den Schlüsselwort synchronized.  &lt;br /&gt;
&lt;b&gt;Verwendung ListFactory&lt;/b&gt;  &lt;br /&gt;
&lt;a href="http://lh3.ggpht.com/-oFzYiG5IAQ4/UftGOSJ28dI/AAAAAAABS9c/fXECqVj2NQY/s1600-h/image%25255B30%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-CVfHTeJNC_E/UftGOxUS5bI/AAAAAAABS9k/ldG5rybeNBs/image_thumb%25255B22%25255D.png?imgmax=800" height="157" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="437" /&gt;&lt;/a&gt;  &lt;br /&gt;
Bisher wurde nun die statische Abhängigkeit zur ArrayList verhindert, die Entscheidung eine ArrayList zu nehmen ist jedoch immer noch expliziet gefallen.  &lt;br /&gt;
Umgehen kann man das durch die Verwendung der ListFactory.&amp;nbsp; &lt;br /&gt;
Die Implementierung der ListFactory selber hat auch wieder die statischen Abhängigkeiten zu allen vorgesehenen Implementierungen.&amp;nbsp; &lt;br /&gt;
Der nächste Schritt kann ein ContextRsolver sein, der in die Factory eingebunden wird und zur Laufzeit die Wahl der Implementierung trifft.  &lt;br /&gt;
Der ContextResolver wird entweder beim Methodenaufruf übergeben, oder bei der Initialisierung der Factory erzeugt/übergeben/geholt.  &lt;br /&gt;
Möchte man nun die Factory so erstellen, das diese wiederum nicht statische Abhängigkeiten zu den jeweiligen Contexten bzw Implementierungen der Liste hat, muss eine Registry gebaut werden.  &lt;br /&gt;
Dort kann man zur Laufzeit die jeweiligen Implementierungen registrieren und für eine Auflösung zur Verfügung stellen.  &lt;br /&gt;
Spätestens ab diesem Zeitpunkt wird die Implementierung aufwendig, da man entweder diesen Mechanismus für alle Implementierungen vorhalten muss, oder eine generische Implementierung notwendig ist.  &lt;br /&gt;
Hier Hilft CDI durch seine Konzepte, ohne das man sich mit der Basisimplementierung der Infrastruktur beschäftigen muss.&amp;nbsp; &lt;br /&gt;
&lt;b&gt;&lt;/b&gt;&amp;nbsp; &lt;br /&gt;
&lt;b&gt;Wie ist nun die Lösung mittels CDI?&lt;/b&gt; &lt;br /&gt;
Für den Entwickler sieht die Verwendung exemplarisch (&lt;b&gt;CDILegacyTest&lt;/b&gt;) wie folgt aus. &lt;br /&gt;
&lt;b&gt;Def List per CDI&lt;/b&gt; &lt;br /&gt;
&lt;a href="http://lh4.ggpht.com/-bLcZPIibAx4/UftGPNKMxiI/AAAAAAABS9s/d4Dcxqv8XTk/s1600-h/image%25255B34%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-YjcOGqGEVvM/UftGPoSfgvI/AAAAAAABS90/uMCmYSSMRXU/image_thumb%25255B24%25255D.png?imgmax=800" height="71" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="437" /&gt;&lt;/a&gt; &lt;br /&gt;
Die Verwendung erfolgt wie gewohnt. Das AnnotationsLiteral &lt;b&gt;CDILegacyTest&lt;/b&gt; gibt an, welcher Producer zu wählen ist. &lt;br /&gt;
&lt;b&gt;Def ListProducer&lt;/b&gt; &lt;br /&gt;
&lt;a href="http://lh4.ggpht.com/-Mqa6FjW3nVY/UftGP4pVxLI/AAAAAAABS98/lnd4vw1eVW0/s1600-h/image%25255B38%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh3.ggpht.com/-K3k-sZg_3AY/UftGQXAGksI/AAAAAAABS-E/BD2wV4v8EVk/image_thumb%25255B26%25255D.png?imgmax=800" height="60" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="437" /&gt;&lt;/a&gt; &lt;br /&gt;
Fertig sind wir. &lt;br /&gt;
&lt;b&gt;dynamische Rekonfiguration?&lt;/b&gt; &lt;br /&gt;
CDI stellt eine sehr angenehme Basis zur Erzeugung dynamisch rekonfigurierbarer Systeme dar. Das Konzept der Instance&amp;lt;T&amp;gt; ist hier der Einstiegspunkt. &lt;br /&gt;
In der Definition der Attribute wird der Proxy Instance&amp;lt;T&amp;gt; verwendet. &lt;br /&gt;
&lt;b&gt;Def List-Instance&lt;/b&gt; &lt;br /&gt;
&lt;a href="http://lh3.ggpht.com/-Jx7pcJ8Lljc/UftGQu_1iaI/AAAAAAABS-I/YN22O1upDnA/s1600-h/image%25255B42%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh6.ggpht.com/-x0LxTetnq6Y/UftGRDDqJ5I/AAAAAAABS-U/-_opHCRoGzw/image_thumb%25255B28%25255D.png?imgmax=800" height="60" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="437" /&gt;&lt;/a&gt; &lt;br /&gt;
&lt;code&gt;&lt;/code&gt; &lt;br /&gt;
Zu dem Zeitpunkt wenn auf die Variable zugegriffen werden muss, wird per get() die konkrete Implementierung geholt. &lt;br /&gt;
&lt;b&gt;Verwendung der Liste&lt;/b&gt; &lt;br /&gt;
&lt;a href="http://lh6.ggpht.com/-pxLHjI0MXfo/UftGRdDxBxI/AAAAAAABS-Y/OjA7SmGkyis/s1600-h/image%25255B46%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh4.ggpht.com/-4qL8gg2H9OA/UftGR5ul8nI/AAAAAAABS-k/_SCq8OqH7-0/image_thumb%25255B30%25255D.png?imgmax=800" height="65" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="437" /&gt;&lt;/a&gt; &lt;br /&gt;
&lt;code&gt;&lt;/code&gt; &lt;br /&gt;
Damit kann die Entscheidung von der Erzeugung der verwendenden Instanz auf den Zeitpunkt der Verwendung verschoben werden. &lt;br /&gt;
In diesem Moment sollten im System hinreichend Informationen zur Verfügung stehen um die richtige Implementierung wählen zu können. Das Konzept basiert auf einem ContextResolver. &lt;br /&gt;
In diesem werden die Zustandsinformationen der Laufzeitumgebung, des Benutzers und was immer notwendig ist aggregiert und führen zu einer deklarativen Entscheidung. &lt;br /&gt;
Das Ergebnis ist ein umgebungsspezifisches AnnotationsLiteral mit dessen Hilfe die zur Verfügung stehenden Producer ausgewählt werden. Fertig ist das dynamisch rekonfigurierbare System. &lt;br /&gt;
Die Implementierung des ContextResolvers kann wiederum lean selektiert werden &lt;img alt="(Zwinkern)" src="http://wiki.rapidpm.org/s/de_DE-1988229788/4249/84a11b3502ae79dd6028856f37ff89838963c1cc.5/_/images/icons/emoticons/wink.png" /&gt;  &lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;

&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>cdi.commons.fx -JavaFX/CDI Bootstrap</title>
        <category label="Arquillian"/>
        <category label="CDI"/>
        <category label="IDEA"/>
        <category label="IntelliJ"/>
        <category label="Java"/>
        <category label="JavaFX"/>
        <category label="Weld"/>
        <published>2013-08-03T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/08/03/cdi.commons.fx-javafx-cdi-bootstrap.html&gt;cdi.commons.fx -JavaFX/CDI Bootstrap&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-08-03 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
The both technologies JavaFX and CDI are greate for itself.. but how to combine them? How I can get managed JavaFX - controller instances? &lt;br /&gt;
Starting from the JavaFX – side, we have to implement the Class extending &lt;strong&gt;javafx.application.Application.&lt;/strong&gt; The importand method will be &lt;br /&gt;
&lt;blockquote&gt;
&lt;em&gt;&lt;code&gt;public&lt;/code&gt; &lt;code&gt;void&lt;/code&gt; &lt;code&gt;start(Stage primaryStage) &lt;/code&gt;&lt;code&gt;throws&lt;/code&gt; &lt;code&gt;Exception&lt;/code&gt;&lt;/em&gt;&lt;/blockquote&gt;
&lt;code&gt;&lt;a href="https://bitbucket.org/svenruppert/cdi-commons-fx/src/204e32a360b4090661e7871330921609b628205b/src/main/java/org/rapidpm/demo/cdi/commons/fx/CDIJavaFXBaseApplication.java?at=develop" target="_blank"&gt;CDIJavaFXBaseApplication&lt;/a&gt;&lt;/code&gt; &lt;br /&gt;
&lt;a href="http://lh3.ggpht.com/-spRH4z861ZQ/Uf12wRaYx5I/AAAAAAABTJI/dma-IzG6hho/s1600-h/image%25255B3%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-IKNxCJX9Ma8/Uf12wwRsReI/AAAAAAABTJQ/MQTcwt1GbIU/image_thumb%25255B1%25255D.png?imgmax=800" height="274" style="border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline;" title="image" width="644" /&gt;&lt;/a&gt;  &lt;br /&gt;
&amp;nbsp; &lt;br /&gt;
With &lt;strong&gt;CDIContainerSingleton.getInstance()&lt;/strong&gt; you will get an instance of the Weld-Container. After the normal JavaFX – init&amp;nbsp; there will be an event fired with the primaryStage as attribute. Now the primaryStage is available in an managed environment. &lt;br /&gt;
JAvaFX –&amp;gt; CDI &lt;br /&gt;
&lt;blockquote&gt;
&lt;em&gt;&lt;code&gt;cdi.event()&lt;/code&gt;&lt;code&gt;.select(Stage.&lt;/code&gt;&lt;code&gt;class&lt;/code&gt;&lt;code&gt;, &lt;/code&gt;&lt;code&gt;new&lt;/code&gt; &lt;code&gt;AnnotationLiteral&amp;lt;CDIStartupScene&amp;gt;() {})&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
&lt;code&gt;&lt;em&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; .fire(primaryStage);&lt;/em&gt;&lt;/code&gt;&lt;/blockquote&gt;
The observer will catch this event. Hownthis will be donw, I show with the excample jUnit-test.&lt;br /&gt;
(&lt;a href="https://bitbucket.org/svenruppert/cdi-commons-fx/src/204e32a360b4090661e7871330921609b628205b/src/test/java/org/rapidpm/demo/cdi/commons/fx/JavaFXBaseTest.java?at=develop" target="_blank"&gt;JavaFXBaseTest&lt;/a&gt;)&lt;br /&gt;
&lt;a href="http://lh6.ggpht.com/-pe3l8kSIZrI/Uf12xUqXCaI/AAAAAAABTJY/4qNT0JYh-5o/s1600-h/image%25255B7%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh6.ggpht.com/-mYyW73L1y7A/Uf12xkbSleI/AAAAAAABTJg/GrkqVjLTMhM/image_thumb%25255B3%25255D.png?imgmax=800" height="345" style="border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline;" title="image" width="644" /&gt;&lt;/a&gt; &lt;br /&gt;
The final jUnit-Class (extends JavaFXBaseTest ) will implement the method –&amp;gt; testImpl(final Stage stage). The jUnit-Test will be a manged instance itself.&lt;br /&gt;
&lt;a href="http://lh3.ggpht.com/-rIZgDI2CmZc/Uf12yFhNcaI/AAAAAAABTJo/xmDBb7Nilas/s1600-h/image%25255B11%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-ANX-6HvYjEk/Uf12y-vIj3I/AAAAAAABTJw/sbkL-wTuD-A/image_thumb%25255B5%25255D.png?imgmax=800" height="484" style="border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline;" title="image" width="636" /&gt;&lt;/a&gt; &lt;br /&gt;
But how to get the manged controller class instance?&lt;br /&gt;
This is done by the &lt;code&gt;&lt;strong&gt;FXMLLoaderSingleton used from the jUnit-test.&lt;/strong&gt;&lt;/code&gt;&lt;br /&gt;
&lt;blockquote&gt;
&lt;pre class="brush:java"&gt;
final FXMLLoader fxmlLoader = fxmlLoaderSingleton.getFXMLLoader(LoginPane.class);
&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;br /&gt;
During the process of loading the fxml-file the used FxmlLoader will get an instance of an ControllerFactory-Callback.&lt;br /&gt;
&lt;a href="http://lh6.ggpht.com/-81g1FPtpMV0/Uf12zchLfMI/AAAAAAABTJ4/UZ6beCx-JkE/s1600-h/image%25255B15%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-snchFSsAGE8/Uf12zxccG1I/AAAAAAABTKA/WmMrwTqTh50/image_thumb%25255B7%25255D.png?imgmax=800" height="379" style="border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline;" title="image" width="644" /&gt;&lt;/a&gt; &lt;br /&gt;
The importand lines are the following &lt;br /&gt;
&lt;a href="http://lh6.ggpht.com/-TW3PcealhwQ/Uf120NC8jFI/AAAAAAABTKI/8Tz8jER8lbU/s1600-h/image%25255B19%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-2vpQxC1vfnI/Uf1207BA-xI/AAAAAAABTKQ/f8jnqwb7CC0/image_thumb%25255B9%25255D.png?imgmax=800" height="93" style="border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline;" title="image" width="644" /&gt;&lt;/a&gt; &lt;br /&gt;
The ControllerFactory-&amp;gt;Callback.call() will give back a manged instance of the controller class.&lt;br /&gt;
Now you can use CDI inside the pojo-fx-controller class.&lt;br /&gt;


&lt;pre class="prettyprint"&gt;
public class LoginController implements CDIJavaFxBaseController {
    // Standard FXML injected fields
 @FXML TextField loginField;
 @FXML PasswordField passwordField;
 @FXML Text feedback;
 
 // CDI Injected field
 @Inject LoginService loginService;
 
    // Default application parameters
 @Inject @CDIJavaFXBaseApp
    Parameters applicationParameters;
 
 @FXML protected void handleSubmitButtonAction(ActionEvent event) {
  feedback.setText(loginService.login(loginField.getText(), passwordField.getText()));
 }

 @Override
 public void initialize(URL location, ResourceBundle resources) {
  loginField.setText(applicationParameters.getNamed().get("user"));
 }
}
&lt;/pre&gt;



&lt;br /&gt;
So we are done..&amp;nbsp; Happy coding ;-)&lt;br /&gt;
&lt;br /&gt;
UML-Diagramm&lt;br /&gt;
&lt;img alt="" src="http://wiki.rapidpm.org/download/attachments/8093789/uml_fx_20130802_001.png?version=1&amp;amp;modificationDate=1375433878726&amp;amp;api=v2" height="479" width="640" /&gt;&lt;br /&gt;
&lt;br /&gt;

&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>JavaFX/CDI Bootstrap - Add On</title>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="Java"/>
        <category label="JavaFX"/>
        <category label="jUnit"/>
        <published>2013-08-14T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/08/14/javafx-cdi-bootstrap-add-on.html&gt;JavaFX/CDI Bootstrap - Add On&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-08-14 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
A few days ago I was writing about the JavaFX/CDI Bootstrap. &lt;br /&gt;
There are a few small changings until now. &lt;br /&gt;
&lt;blockquote&gt;
&lt;em&gt;The final jUnit-Class (extends JavaFXBaseTest ) will implement the method –&amp;gt; testImpl(final Stage stage). &lt;/em&gt;&lt;br /&gt;
&lt;em&gt;The jUnit-Test will be a manged instance itself.&lt;/em&gt;&lt;/blockquote&gt;
This is right.. but I forgot to Inject the a few things.&lt;br /&gt;
First the JavaFX component that is managed:&lt;br /&gt;
The jUnit example (&lt;b&gt;CDIJavaFXBaseApplication001Test&lt;/b&gt;, you will find this at cdi-commons-fx) is using the LoginPane.&lt;br /&gt;
This is changed from an empty class to the following implementation&lt;br /&gt;
&lt;script type="syntaxhighlighter" class="brush: js"&gt;&lt;![CDATA[
public class LoginPane extends GridPane {

    private @Inject FXMLLoaderSingleton fxmlLoaderSingleton;
    private @Inject LoginController controller;

    public LoginPane() {
    }

    @PostConstruct
    public void init(){
        final FXMLLoader fxmlLoader = fxmlLoaderSingleton.getFXMLLoader(LoginPane.class);
        fxmlLoader.setRoot(this);
        try {
            fxmlLoader.setController(controller);
            fxmlLoader.load();
        } catch (IOException exception) {
            throw new RuntimeException(exception);
        }
    }

    public LoginController getController() {
        return controller;
    }
}
]]&gt;&lt;/script&gt;
&lt;br /&gt;
Now you have to modify the fxml based on this first version.&lt;br /&gt;
&lt;br /&gt;
&lt;script type="syntaxhighlighter" class="brush: js"&gt;&lt;![CDATA[
&lt;fx:root type="javafx.scene.layout.GridPane" fx:controller="demo.LoginController"
         alignment="CENTER" hgap="10.0" stylesheets="/demo/login.css" vgap="10.0"
          xmlns:fx="http://javafx.com/fxml"
          &gt;

   &lt;!-- .... --&gt;

&lt;/fx:root&gt;
]]&gt;&lt;/script&gt;
&lt;br /&gt;
At this version you had to declare the controller itself. This can be done later by the init-phase. And the root – element was an pure GridPane.
&lt;br /&gt;
The new version looks like this:&lt;br /&gt;
&lt;script type="syntaxhighlighter" class="brush: js"&gt;&lt;![CDATA[
&lt;fx:root type="demo.LoginPane"
         alignment="CENTER" hgap="10.0" stylesheets="/demo/login.css" vgap="10.0"
          xmlns:fx="http://javafx.com/fxml"&gt;

&lt;!-- .... --&gt;

&lt;/fx:root&gt;
]]&gt;&lt;/script&gt;

The root – element is now the self defined class LoginPane and the the controller definition is removed. So you can inject a controller at runtime depending on the ContextResolver.&lt;br /&gt;
&lt;br /&gt;
The jUnit-Test itself changed a little bit. At the first version we used the fxml-Loader to get the LoginPane.. This can now be done by an Inject. (@Inject LoginPane root; )&lt;br /&gt;
&lt;br /&gt;
&lt;script type="syntaxhighlighter" class="brush: js"&gt;&lt;![CDATA[
        @Inject
        @CDISimpleDateFormatter(value = "date.yyyyMMdd")
        SimpleDateFormat sdf;
        @Inject
        @CDILogger
        Logger logger;

        @Inject LoginPane root;

        @Override
        public void testImpl(Stage stage) {
            if (logger.isDebugEnabled()) {
                logger.debug("testrunn at -&gt; " + sdf.format(new Date()));
            }
            stage.setTitle("Login");  //i18n
            stage.setScene(new Scene(root, 300, 275));
            //stage.show();
            final Scene scene = stage.getScene();

            //TestCode
            final TextField login = (TextField) scene.lookup("#loginField");
            login.setText("LOGIN");
            final PasswordField passwd = (PasswordField) scene.lookup("#passwordField");
            passwd.setText("LOGIN");

            final LoginController controller = root.getController();
            controller.handleSubmitButtonAction(new ActionEvent());

            final Text feedback = (Text) scene.lookup("#feedback");
            Assert.assertEquals("LOGIN logged in successfully", feedback.getText());
        }

]]&gt;&lt;/script&gt;
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>How to setup a JavaFX / CDI Component</title>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="Java"/>
        <category label="JavaFX"/>
        <category label="Weld"/>
        <published>2013-08-30T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/08/30/how-to-setup-a-javafx-cdi-component.html&gt;How to setup a JavaFX / CDI Component&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-08-30 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
With cdi-commons it is very easy to start with an JavaFX / CDI Component/Application.&lt;br /&gt;
As an example we will start with an small Table-App with i18n and CDI.&lt;br /&gt;
&lt;a href="http://lh4.ggpht.com/-5_UEi4MPRqU/UiBXeUvOy8I/AAAAAAABTTg/YGS8XJvlXHE/s1600-h/image%25255B4%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh4.ggpht.com/-9eP1fWM5Mq4/UiBXfE6n4nI/AAAAAAABTTo/hYmHY3_DOg8/image_thumb%25255B2%25255D.png?imgmax=800" height="118" style="background-image: none; border-bottom-width: 0px; border-left-width: 0px; border-right-width: 0px; border-top-width: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="244" /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
You need the following steps:&lt;br /&gt;
01) create the empty Controller;&lt;br /&gt;
&lt;a href="http://lh5.ggpht.com/-h_lnfIW1bP0/UiBcdWdzE3I/AAAAAAABTT4/Xjqng3D10bQ/s1600-h/image%25255B4%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-Qi1cIozCosk/UiBcd3dxqZI/AAAAAAABTUA/k1vZxh__QFo/image_thumb%25255B1%25255D.png?imgmax=800" height="120" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="644" /&gt;&lt;/a&gt;&lt;br /&gt;
02) create the Root JavaFX Component&lt;br /&gt;
&lt;a href="http://lh5.ggpht.com/-pyWO2opZ9SA/UiBceQb_ILI/AAAAAAABTUE/k50-cXu8ltU/s1600-h/image%25255B8%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-oXnNYmOYEwc/UiBcenXuo5I/AAAAAAABTUQ/HJuxITXt-zA/image_thumb%25255B3%25255D.png?imgmax=800" height="111" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="644" /&gt;&lt;/a&gt;&lt;br /&gt;
03) create the fxml-file&lt;br /&gt;
&lt;a href="http://lh6.ggpht.com/-GXCDEVy2Ve0/UiBcfIO5TlI/AAAAAAABTUY/SshqU6AVNXg/s1600-h/image%25255B15%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh4.ggpht.com/-3h_Uv3Dzxj0/UiBcf8T4FjI/AAAAAAABTUc/u3tYtlsIWJk/image_thumb%25255B6%25255D.png?imgmax=800" height="484" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="612" /&gt;&lt;/a&gt;&lt;br /&gt;
04) create the i18n-properties&lt;br /&gt;
&lt;a href="http://lh3.ggpht.com/-mRhBaxlqpC0/UiBcgJ1aI-I/AAAAAAABTUk/otKEBYNGIDM/s1600-h/image%25255B19%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh6.ggpht.com/-guqrvakcjms/UiBcg2nyZfI/AAAAAAABTUw/FhecBnTk40A/image_thumb%25255B8%25255D.png?imgmax=800" height="75" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="644" /&gt;&lt;/a&gt;&lt;br /&gt;
05) create the KeyMapper-Class&lt;br /&gt;
&lt;a href="http://lh4.ggpht.com/-atTY5fiaq_0/UiBchsr1r5I/AAAAAAABTU0/6aBTpP3jx70/s1600-h/image%25255B23%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh4.ggpht.com/-UN-1I-kG89A/UiBch5mI93I/AAAAAAABTU8/q4xcsQ50xeI/image_thumb%25255B10%25255D.png?imgmax=800" height="80" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="644" /&gt;&lt;/a&gt;&lt;br /&gt;
06) create the transient Row-Class&lt;br /&gt;
&lt;a href="http://lh3.ggpht.com/-RsZmGPbhFHk/UiBcifod8fI/AAAAAAABTVE/QerSAvdrYMc/s1600-h/image%25255B27%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh3.ggpht.com/-Hd0sCxIFHwI/UiBcjCxqRTI/AAAAAAABTVM/OoEW7vOupG0/image_thumb%25255B12%25255D.png?imgmax=800" height="240" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="644" /&gt;&lt;/a&gt;&lt;br /&gt;
07) create the TableFilters&lt;br /&gt;
&lt;a href="http://lh3.ggpht.com/-WZTIZm0jXL4/UiBcj_3fP7I/AAAAAAABTVQ/Pm8fDRz5zi8/s1600-h/image%25255B31%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh4.ggpht.com/-X-lxpy-bQ9k/UiBckeMSjqI/AAAAAAABTVY/zIFqN7MIrXI/image_thumb%25255B14%25255D.png?imgmax=800" height="303" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="644" /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://lh3.ggpht.com/-4j7YmxgvjW4/UiBckqbYfFI/AAAAAAABTVk/ZULr7ynlrQI/s1600-h/image%25255B35%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh4.ggpht.com/-jTw5ELuINIo/UiBclVVyEKI/AAAAAAABTVo/xBZ9ZlaS9r4/image_thumb%25255B16%25255D.png?imgmax=800" height="463" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="644" /&gt;&lt;/a&gt;&lt;br /&gt;
08) create the RowComparator&lt;br /&gt;
&lt;a href="http://lh3.ggpht.com/-KlUGUuDtrok/UiBcliRMB1I/AAAAAAABTVw/ltV7dDzcftc/s1600-h/image%25255B39%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh6.ggpht.com/-Ss-lT9MR8kc/UiBcmBCBd_I/AAAAAAABTV8/7WPFpEiFlO8/image_thumb%25255B18%25255D.png?imgmax=800" height="484" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="597" /&gt;&lt;/a&gt;&lt;br /&gt;
09) create the DemoDataBuilder&lt;br /&gt;
&lt;a href="http://lh4.ggpht.com/-i_PHNnfPiM8/UiBcmlZx4wI/AAAAAAABTWA/Webh62iZyG0/s1600-h/image%25255B43%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh6.ggpht.com/-EsCNI3UlX0g/UiBcnDjFDhI/AAAAAAABTWM/_0v-REDYjm8/image_thumb%25255B20%25255D.png?imgmax=800" height="258" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="644" /&gt;&lt;/a&gt;&lt;br /&gt;
10) implement the Controller methods&lt;br /&gt;
&lt;a href="http://lh4.ggpht.com/-HV0HNafku7A/UiBcnpsx3gI/AAAAAAABTWU/1kaLaDNhyvc/s1600-h/image%25255B47%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh3.ggpht.com/-7FId4UwLKss/UiBcoVG5XYI/AAAAAAABTWc/KBhjh1BLT00/image_thumb%25255B22%25255D.png?imgmax=800" height="484" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="552" /&gt;&lt;/a&gt;&lt;br /&gt;
11) create the jUnit Test-Class&lt;br /&gt;
&lt;a href="http://lh3.ggpht.com/-oOHz685ypLU/UiBco0QD5GI/AAAAAAABTWg/nZLFC0X8Dts/s1600-h/image%25255B51%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-RBGhQ0MJ9XM/UiBcpaR7sHI/AAAAAAABTWs/nu0UjOo2NuI/image_thumb%25255B24%25255D.png?imgmax=800" height="280" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="644" /&gt;&lt;/a&gt;&lt;br /&gt;
12) start implementing the Workflows….
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>MultiLevel DrillDownPieChart in less then 30min as component for TableViews</title>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="Java"/>
        <category label="JavaFX"/>
        <category label="RapidPM"/>
        <category label="TableView"/>
        <category label="Weld"/>
        <published>2013-09-03T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/09/03/multilevel-drilldownpiechart-in-less-t.html&gt;MultiLevel DrillDownPieChart in less then 30min as component for TableViews&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-09-03 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
&lt;div style="text-align: center;"&gt;
    &lt;i&gt;&lt;span style="font-size: x-small;"&gt;The full code and demo jUnit you will find under :&amp;nbsp;&lt;a href="https://bitbucket.org/rapidpm/modules/src/265b5f577e8f9b5a875408a9659d58a02f72b1af/javafx-chart-pie-drilldown?at=develop" target="_blank"&gt;BitBucket Repo - RapidPM - Modules - javafx-chart-pie-drilldown&lt;/a&gt;&amp;nbsp;&lt;/span&gt;&lt;/i&gt;&lt;/div&gt;
&lt;div style="text-align: center;"&gt;
    &lt;i&gt;&lt;span style="font-size: x-small;"&gt;Please use the develop branch and a commit after&amp;nbsp;&lt;a href="https://bitbucket.org/rapidpm/modules/commits/265b5f577e8f9b5a875408a9659d58a02f72b1af?at=develop"&gt;265b5f5&lt;/a&gt;&amp;nbsp;&lt;/span&gt;&lt;/i&gt;&lt;/div&gt;
&lt;br /&gt;
Sometimes you want to have a drill down pi chart for a tableview. This code often looks like the following &lt;br /&gt;
(example from the oracle side)&lt;br /&gt;
&lt;a href="http://lh5.ggpht.com/-5KuGN_tnaic/UiYI9GTqX6I/AAAAAAABTXI/CKp7qJaPg8M/s1600-h/image%25255B3%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-ydmWK3GgtJk/UiYI9gFkecI/AAAAAAABTXM/tsHeNgJAvL0/image_thumb%25255B1%25255D.png?imgmax=800" height="484" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="530" /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
What you can see, is the direct way of putting the data together for each drilldown-level.&lt;br /&gt;
But if you want to drill down more than one level.. the code will be long.&lt;br /&gt;
For this example I am using the following demo data table.&lt;br /&gt;
&lt;br /&gt;
&lt;a href="http://lh6.ggpht.com/-Dln9HPL38mw/UiYI-gzJA7I/AAAAAAABTXY/l7uE_hEpjOc/s1600-h/image%25255B8%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh3.ggpht.com/-SnrHBEPMMHM/UiYI_MHshTI/AAAAAAABTXc/jFwz7iu2k_w/image_thumb%25255B4%25255D.png?imgmax=800" height="244" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="231" /&gt;&lt;/a&gt;&lt;br /&gt;
What I want to reach is a short way for a developer to aggregate from one row to an other (in both directions)&lt;br /&gt;
Here the pie–chart for this demo data and clicking the following steps:&lt;br /&gt;
Rows: Vorname-&amp;gt;Nachname-&amp;gt;Datum-&amp;gt;Betrag &lt;br /&gt;
Data: Holger-&amp;gt;Hoppel-&amp;gt;2013.10.01-&amp;gt;122.0 &lt;br /&gt;
&lt;a href="http://lh6.ggpht.com/-M8cJy_3fHmw/UiYI_txlqdI/AAAAAAABTXo/RRn5gXIi2LU/s1600-h/image%25255B11%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-CQyGxK2HMYI/UiYJAPlSEII/AAAAAAABTXs/ZZZHHNwgSFE/image_thumb%25255B5%25255D.png?imgmax=800" height="244" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="206" /&gt;&lt;/a&gt;&lt;a href="http://lh4.ggpht.com/-2_gTKMNX8mE/UiYJApNHhRI/AAAAAAABTX4/WFwxYSfYKUY/s1600-h/image%25255B14%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-FKGgdz6m5Co/UiYJBcGFtsI/AAAAAAABTYA/3Kyxlx2ij9Q/image_thumb%25255B6%25255D.png?imgmax=800" height="244" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; margin: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="191" /&gt;&lt;/a&gt;&lt;a href="http://lh4.ggpht.com/-IUAsBkI3mcs/UiYJCFnpZSI/AAAAAAABTYI/ILGKNlZsSsU/s1600-h/image%25255B17%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-K3YgnWkqaZM/UiYJCmmseGI/AAAAAAABTYQ/hDD7FDcvN90/image_thumb%25255B7%25255D.png?imgmax=800" height="244" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; margin: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="221" /&gt;&lt;/a&gt;&lt;a href="http://lh5.ggpht.com/-uIxOkfx3ZxU/UiYJDFf2Z7I/AAAAAAABTYY/hNh3S0nL0yo/s1600-h/image%25255B21%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-YUPfZV8MP3U/UiYJD_HH73I/AAAAAAABTYg/ZtSsq2GJljo/image_thumb%25255B9%25255D.png?imgmax=800" height="244" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="244" /&gt;&lt;/a&gt;&lt;br /&gt;
You can see, that for each level you will get the aggregated data from the table..&amp;nbsp; But how to do it?&lt;br /&gt;
The basic is the Aggregator-Class&lt;br /&gt;
&lt;script type="syntaxhighlighter" class="brush: java"&gt;&lt;![CDATA[
public abstract class MapAggregator&lt;T, K&gt; {

    private @Inject @CDILogger Logger logger;

    public abstract K getKeyElement(T t);

    public Map&lt;K, List&lt;T&gt;&gt; aggregate(final Collection&lt;T&gt; dataCollection) {
        final Map&lt;K, List&lt;T&gt;&gt; result = new HashMap&lt;&gt;();
        for (final T dataObject : dataCollection) {
            final K key = getKeyElement(dataObject);
            if (result.containsKey(key)) {
                if (logger.isDebugEnabled()) {
                    logger.debug("key schon vorhanden -&gt; " + key);
                }
            } else {
                result.put(key, new ArrayList&lt;T&gt;());
            }
            result.get(key).add(dataObject);
        }
        return result;
    }
}
]]&gt;&lt;/script&gt;
&lt;br /&gt;
&lt;span class="nt" style="background-color: ghostwhite; color: navy; font-family: Consolas, 'Liberation Mono', Courier, monospace; font-size: 14px; line-height: 19px; white-space: pre;"&gt;&lt;/span&gt;

With this you can aggregate a collection to a map. The key is the aggregated value from the collection elements.&lt;br /&gt;
For this example: A Collection of the TransientDemoDataRow (Collection&lt;transientdemodatarow&gt;) aggregated over the attribute vorname.&lt;/transientdemodatarow&gt;&lt;br /&gt;

&lt;script type="syntaxhighlighter" class="brush: java"&gt;&lt;![CDATA[
public class TransientDemoDataRow {


    private String vorname;
    private String nachname;
    private String datum;
    private Double betrag;

    @PostConstruct
    public void init() {

    }

    public String getVorname() {
        return vorname;
    }

    public void setVorname(String vorname) {
        this.vorname = vorname;
    }

    public String getNachname() {
        return nachname;
    }

    public void setNachname(String nachname) {
        this.nachname = nachname;
    }

    public String getDatum() {
        return datum;
    }

    public void setDatum(String datum) {
        this.datum = datum;
    }

    public Double getBetrag() {
        return betrag;
    }

    public void setBetrag(Double betrag) {
        this.betrag = betrag;
    }
}
]]&gt;&lt;/script&gt;
With our demo data table you will get a map with two collections. &lt;br /&gt;
a) Holger –&amp;gt; List of 6 elements&lt;br /&gt;
b) Willi –&amp;gt; List of 4 elements&lt;br /&gt;
This is the data for the first level of the DrillDownPieChart. (first pic of the pie charts see above)&lt;br /&gt;
For our DrillDownPieChart we are using the following aggregator extending the MapAggregator&lt;t&gt;.&lt;/t&gt;&lt;br /&gt;
&lt;t&gt;&lt;/t&gt;&lt;br /&gt;
&lt;script type="syntaxhighlighter" class="brush: java"&gt;&lt;![CDATA[
public abstract class DrillDownPieChartMapAggregator&lt;T&gt; extends MapAggregator&lt;T, String&gt; {


    /**
     * Calculate the Value for the PiChart.Data based on the aggregated values
     *
     * @param aggregatedValues
     * @return
     */
    public abstract double aggregateValue(List&lt;T&gt; aggregatedValues);

    public abstract String getLevelName();

    private DrillDownPieChartMapAggregator&lt;T&gt; nextLevelAggregator;
    private DrillDownPieChartMapAggregator&lt;T&gt; parentLevelAggregator;

    public DrillDownPieChartMapAggregator&lt;T&gt; getNextLevelAggregator() {
        return nextLevelAggregator;
    }

    public DrillDownPieChartMapAggregator&lt;T&gt; getParentLevelAggregator() {
        return parentLevelAggregator;
    }

    public void setNextLevelAggregator(DrillDownPieChartMapAggregator&lt;T&gt; nextLevelAggregator) {
        this.nextLevelAggregator = nextLevelAggregator;
        this.nextLevelAggregator.parentLevelAggregator = this;
    }

    public boolean isLastOne() {
        if (nextLevelAggregator == null) {
            return true;
        } else {
            return false;
        }
    }

    public boolean isFirstOne() {
        if (parentLevelAggregator == null) {
            return true;
        } else {
            return false;
        }
    }

}
]]&gt;&lt;/script&gt;
&lt;br /&gt;
We are holding the reference to the next level aggregator and the reference to the parent aggregator.&lt;br /&gt;
To implement the aggregator for each col. we want to use for our DrillDownPieChart we have to write code like the following&lt;br /&gt;
&lt;script type="syntaxhighlighter" class="brush: java"&gt;&lt;![CDATA[
public static class BetragAggregator extends DrillDownPieChartMapAggregator&lt;TransientDemoDataRow&gt; {
        @Override public double aggregateValue(List&lt;TransientDemoDataRow&gt; aggregatedValues) {
            double betrag = 0;
            for (final TransientDemoDataRow aggregatedValue : aggregatedValues) {
                betrag = betrag + aggregatedValue.getBetrag();
            }
            return betrag;
        }

        @Override public String getLevelName() {
            return "Betrag";
        }

        @Override public String getKeyElement(TransientDemoDataRow transientDemoDataRow) {
            return transientDemoDataRow.getBetrag() + " € Beträge";
        }
    }

    public static class DatumAggregator extends DrillDownPieChartMapAggregator&lt;TransientDemoDataRow&gt; {
        @Override public double aggregateValue(List&lt;TransientDemoDataRow&gt; aggregatedValues) {
            return aggregatedValues.size();
        }

        @Override public String getLevelName() {
            return "Datum";
        }
        @Override public String getKeyElement(TransientDemoDataRow transientDemoDataRow) {
            return transientDemoDataRow.getDatum();
        }
    }

    public static class VornameAggregator extends DrillDownPieChartMapAggregator&lt;TransientDemoDataRow&gt; {
        @Override public double aggregateValue(List&lt;TransientDemoDataRow&gt; aggregatedValues) {
            return aggregatedValues.size();
        }

        @Override public String getLevelName() {
            return "Vorname";
        }

        @Override public String getKeyElement(TransientDemoDataRow transientDemoDataRow) {
            return transientDemoDataRow.getVorname();
        }
    }


    public static class NachnameAggregator extends DrillDownPieChartMapAggregator&lt;TransientDemoDataRow&gt; {
        @Override public double aggregateValue(List&lt;TransientDemoDataRow&gt; aggregatedValues) {
            return aggregatedValues.size();
        }

        @Override public String getLevelName() {
            return "Nachname";
        }
        @Override public String getKeyElement(TransientDemoDataRow transientDemoDataRow) {
            return transientDemoDataRow.getNachname();
        }
    }

]]&gt;&lt;/script&gt;
&lt;br /&gt;
The method getLevelName is to label the PieChart for the user.&lt;br /&gt;
The method getKeyElement is the value used for the aggregation.&lt;br /&gt;
The method aggregateValue is to calculate the double, used by the pie chart as value.&lt;br /&gt;
After this you have to put all together… the logic-part is done now..&lt;br /&gt;
&lt;script type="syntaxhighlighter" class="brush: java"&gt;&lt;![CDATA[
public class DrillDownPieChartPaneController implements CDIJavaFxBaseController {

    @FXML DemoDrillDownPieChart piechart;


    @Inject Instance&lt;VornameAggregator&gt; vornameAggregatorInstance;
    @Inject Instance&lt;NachnameAggregator&gt; nachnameAggregatorInstance;
    @Inject Instance&lt;DatumAggregator&gt; datumAggregatorInstance;
    @Inject Instance&lt;BetragAggregator&gt; betragAggregatorInstance;


    @Override public void initialize(URL url, ResourceBundle resourceBundle) {

        //setze Aggregatoren
        final VornameAggregator vornameAggregator = vornameAggregatorInstance.get();

        final NachnameAggregator nachnameAggregator = nachnameAggregatorInstance.get();
        vornameAggregator.setNextLevelAggregator(nachnameAggregator);

        final DatumAggregator datumAggregator = datumAggregatorInstance.get();
        nachnameAggregator.setNextLevelAggregator(datumAggregator);

        final BetragAggregator betragAggregator = betragAggregatorInstance.get();
        datumAggregator.setNextLevelAggregator(betragAggregator);

        piechart.setRootAggregator(vornameAggregator);

    }


    public void init() {
        piechart.init();
    }

]]&gt;&lt;/script&gt;
The gui part looks like this: Extending the DrillDownPieChart with the type you need as data holder, here the TransientDemoDataRow.&lt;br /&gt;
&lt;script type="syntaxhighlighter" class="brush: java"&gt;&lt;![CDATA[
public class TransientDemoDataRow {


    private String vorname;
    private String nachname;
    private String datum;
    private Double betrag;

    @PostConstruct
    public void init() {

    }

    public String getVorname() {
        return vorname;
    }

    public void setVorname(String vorname) {
        this.vorname = vorname;
    }

    public String getNachname() {
        return nachname;
    }

    public void setNachname(String nachname) {
        this.nachname = nachname;
    }

    public String getDatum() {
        return datum;
    }

    public void setDatum(String datum) {
        this.datum = datum;
    }

    public Double getBetrag() {
        return betrag;
    }

    public void setBetrag(Double betrag) {
        this.betrag = betrag;
    }
}
]]&gt;&lt;/script&gt;
and putting it to a fxml file.&lt;br /&gt;
&lt;script type="syntaxhighlighter" class="brush: javafx"&gt;&lt;![CDATA[
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;?import gui.org.rapidpm.modul.javafx.chart.pie.drilldown.DemoDrillDownPieChart?&gt;
&lt;?import javafx.scene.control.Label?&gt;
&lt;?import javafx.scene.layout.AnchorPane?&gt;
&lt;?import javafx.scene.layout.VBox?&gt;
&lt;fx:root type="gui.org.rapidpm.modul.javafx.chart.pie.drilldown.DrillDownPieChartPane"
         fx:id="DrillDownPieChartPane" xmlns:fx="http://javafx.com/fxml" style="-fx-background-color:#EEEEEE"&gt;

    &lt;children&gt;
        &lt;AnchorPane minHeight="0.0" minWidth="0.0" VBox.vgrow="ALWAYS"
                    AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0"&gt;
            &lt;children&gt;
                &lt;Label text="hallo Hier bin ich"/&gt;
                &lt;DemoDrillDownPieChart fx:id="piechart"&gt;

                &lt;/DemoDrillDownPieChart&gt;
            &lt;/children&gt;
        &lt;/AnchorPane&gt;
    &lt;/children&gt;
&lt;/fx:root&gt;
]]&gt;&lt;/script&gt;
ready…&amp;nbsp; &lt;br /&gt;
&lt;br /&gt;
The steps for a developer are:&lt;br /&gt;
1) writing the transient data holder for an row –&amp;gt; TransientDemoDataRow&lt;br /&gt;
2) extending the DrillDownPieChart –&amp;gt; DemoDrillDownPieChart extends&lt;transientdemodatarow&gt;&lt;/transientdemodatarow&gt;&lt;br /&gt;
3) extending the DrillDownPieChartMapAggregator –&amp;gt; NachnameAggregator extends DrillDownPieChartMapAggregator&lt;transientdemodatarow&gt;&lt;/transientdemodatarow&gt;&lt;br /&gt;
4) putting all aggregator implementations together –&amp;gt; Controller – Class&lt;br /&gt;
5) add the element to the fxml file, &lt;br /&gt;
6) init() and ready&lt;br /&gt;
For a normal TableView with a handfull of rows you will need less than 30 min.&lt;br /&gt;
&lt;br /&gt;
The basic classes to use for an developer:&lt;br /&gt;
&lt;a href="http://lh3.ggpht.com/-SJ-pDNpLOMc/UiYJNA9ohpI/AAAAAAABTaY/ofUQV5uIuEk/s1600-h/image%25255B54%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh4.ggpht.com/-WMXinq5fTd8/UiYJNoBLSEI/AAAAAAABTag/WlbvOUwDZsk/image_thumb%25255B26%25255D.png?imgmax=800" height="484" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="513" /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
All classes from the jUnit demo available at the javafx-chart-pie-drilldown module.&lt;br /&gt;
&lt;a href="http://lh6.ggpht.com/-lP1udVyDMVA/UiYJOSIqFfI/AAAAAAABTao/rEssoxks5Gs/s1600-h/image%25255B58%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh3.ggpht.com/-LiWMRqCVT5A/UiYJPDrwyVI/AAAAAAABTaw/huD7OwGJooI/image_thumb%25255B28%25255D.png?imgmax=800" height="362" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="644" /&gt;&lt;/a&gt;

&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>CDI - ComboBoxCell - How to reduce 80% of code</title>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="FilteredTableView"/>
        <category label="Java"/>
        <category label="JavaFX"/>
        <category label="RapidPM"/>
        <category label="TableView"/>
        <category label="Weld"/>
        <published>2013-09-06T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/09/06/cdi-comboboxcell-how-to-reduce-80%-of-.html&gt;CDI - ComboBoxCell - How to reduce 80% of code&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-09-06 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
&lt;div style="text-align: center;"&gt;
    &lt;i&gt;&lt;span style="font-size: x-small;"&gt;The full code and demo jUnit you will find under :&amp;nbsp;&lt;a href="https://bitbucket.org/rapidpm/modules/src/aec4f95e0ae3130f62bc79170c0233cf49e43299/javafx-filtered-tableview?at=develop" target="_blank"&gt;BitBucket Repo - RapidPM - Modules - javafx-filtered-tableview&lt;/a&gt;&amp;nbsp;&lt;/span&gt;&lt;/i&gt;&lt;/div&gt;
&lt;div style="text-align: center;"&gt;
    &lt;i&gt;&lt;span style="font-size: x-small;"&gt;Please use the develop branch and a commit after&amp;nbsp;&lt;a href="https://bitbucket.org/rapidpm/modules/commits/265b5f577e8f9b5a875408a9659d58a02f72b1af?at=develop"&gt;aec4f95&lt;/a&gt;&amp;nbsp;&lt;/span&gt;&lt;/i&gt;&lt;/div&gt;
&lt;br /&gt;
&lt;br /&gt;
Today I had a TableView with the following function.&lt;br /&gt;
- In one column there was a ComboBoxCell.&lt;br /&gt;
- The values of this ComboBox was calculated / loaded at the moment the combobox was used.&lt;br /&gt;
- Each ComboBox will have different values based on the context of this row.&lt;br /&gt;
&lt;br /&gt;
The first version was something like this:&lt;br /&gt;
A ComboBoxCell:&lt;br /&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class LegacyBetragComboBoxCell extends ComboBoxTableCell&lt;TransientDemoDataRow, Double&gt; {

    private @Inject @CDILogger Logger logger;
    private boolean readOnlyView = false;

    @Inject Instance&lt;contextlogic&gt; contextLogicInstance; //some injected business logic;

    @Override
    public void updateItem(Double o, boolean b) {
        if (logger.isDebugEnabled()) {
            logger.debug("ComboBoxTableCell-&gt;updateItem " + o);
        }
        super.updateItem(o, b);
        if (o == null) {
            //
        } else {
            final TableRow tableRow = getTableRow();
            final TransientDemoDataRow row = (TransientDemoDataRow) tableRow.getItem();
            getItems().clear();
            if (row.getBetrag() == null || row.getBetrag().isInfinite() || row.getBetrag().isNaN()) {
                this.setDisable(true);
            } else if (readOnlyView) {
                this.setDisable(true);
            } else {
                final ContextLogic contextLogic = contextLogicInstance.get();
                final List&lt;double&gt; doubleList = contextLogic.workOnContext(row.getBetrag());

                getItems().addAll(doubleList);

                this.setDisable(false);
            }
            //application logic on row itself
            //application logic external
        }
    }


    public boolean isReadOnlyView() {
        return readOnlyView;
    }

    public void setReadOnlyView(boolean readOnlyView) {
        this.readOnlyView = readOnlyView;
    }
}
]]&gt;&lt;/script&gt;


and the code called from the controller:&lt;br /&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
    @Inject Instance&lt;legacybetragcomboboxcell&gt; legacyBetragComboBoxCellInstance;

    private void initTable() {
        final ObservableList&lt;TableColumn&lt;TransientDemoDataRow, ?&gt;&gt; columns = tableView.getColumns();
        for (final TableColumn&lt;TransientDemoDataRow, ?&gt; column : columns) {
            if(column.getText().equals("betrag")){
                final TableColumn&lt;TransientDemoDataRow, Double&gt; colTyped =(TableColumn&lt;TransientDemoDataRow, Double&gt;) column;
                colTyped.setCellFactory(new Callback&lt;TableColumn&lt;TransientDemoDataRow, Double&gt;, TableCell&lt;TransientDemoDataRow, Double&gt;&gt;() {
                    @Override public TableCell&lt;TransientDemoDataRow, Double&gt; call(TableColumn&lt;TransientDemoDataRow, Double&gt; transientDemoDataRowTableColumn) {
                        final LegacyBetragComboBoxCell cell = legacyBetragComboBoxCellInstance.get();
                        cell.setComboBoxEditable(false);  //true if you want bidirectional dataflow
                        return  cell;
                    }
                });

            } else{
                //other col
            }
        }
    }
]]&gt;&lt;/script&gt;

&lt;br /&gt;
This is to much boilerplate code. So I started to reduce it.&lt;br /&gt;
&lt;br /&gt;
First step was reducing the generics..&lt;br /&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
    @Inject Instance&lt;betragcomboboxcell&gt; betragComboBoxCellInstance;

    private void initTable() {
        final ObservableList&lt;TableColumn&lt;TransientDemoDataRow, ?&gt;&gt; columns = tableView.getColumns();
        for (final TableColumn column : columns) {
            if (column.getText().equals("betrag")) {
                column.setCellFactory(new Callback&lt;TableColumn, TableCell&gt;() {
                    @Override public TableCell call(TableColumn tableColumn) {
                        final BetragComboBoxCell cell = betragComboBoxCellInstance.get();
                        cell.setComboBoxEditable(false);  //true if you want bidirectional dataflow
                        return cell;
                    }
                });

            } else {
                //other col
            }
        }
    }
]]&gt;&lt;/script&gt;
This is shorter, but not better...&amp;nbsp;
&lt;br /&gt;
&lt;br /&gt;
The solution is the abstract GenericComboBoxCell. (part of the &lt;a href="https://bitbucket.org/rapidpm/modules/src/cd6e925b21196fc3e3a5f7b26abe879ed6add129/javafx-filtered-tableview?at=develop" target="_blank"&gt;javafx-filtered-tableview module&lt;/a&gt;)&lt;br /&gt;
&lt;br /&gt;
Iterating over the columns are now part of the GenericComboBoxCell, and here will be the typesave code.&lt;br /&gt;
&lt;br /&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public abstract class GenericComboBoxCell&lt;RT, VT&gt; extends ComboBoxTableCell&lt;RT, VT&gt; {

    private @Inject @CDILogger Logger logger;
    private boolean readOnlyView = false;

    @Override
    public void updateItem(VT o, boolean b) {
        if (logger.isDebugEnabled()) {
            logger.debug("ComboBoxTableCell-&gt;updateItem " + o);
        }
        super.updateItem(o, b);
        if (o == null) {
            //
        } else {
            final TableRow tableRow = getTableRow();
            final RT row = (RT) tableRow.getItem();
            getItems().clear();
            if (disableComboBox(row)) {
                this.setDisable(true);
            } else if (readOnlyView) {
                this.setDisable(true);
            } else {

                final List&lt;vt&gt; comboBoxValues = createComboBoxValues(row);
                getItems().addAll(comboBoxValues);

                this.setDisable(false);
            }
            workOnRowItself(row);
        }
    }

    public void associateWithCol(final TableView&lt;rt&gt; tableView, final String colName) {
        final ObservableList&lt;TableColumn&lt;RT, ?&gt;&gt; columns = tableView.getColumns();
        for (final TableColumn&lt;RT, ?&gt; column : columns) {
            final String columnText = column.getText();
            if (columnText.equals(colName)) {
                if (logger.isDebugEnabled()) {
                    logger.debug("associating to col " + columnText);
                }
                associate((TableColumn&lt;RT, VT&gt;) column);
            } else {
                if (logger.isDebugEnabled()) {
                    logger.debug("not binding to this col : " + columnText);
                }
            }
        }
    }

    private void associate(TableColumn&lt;RT, VT&gt; column) {
        column.setCellFactory(new Callback&lt;TableColumn&lt;RT, VT&gt;, TableCell&lt;RT, VT&gt;&gt;() {
            @Override
            public TableCell&lt;RT, VT&gt; call(TableColumn&lt;RT, VT&gt; rtTableColumn) {
                final GenericComboBoxCell&lt;RT, VT&gt; mySelf = getComboBoxCellRef();
                mySelf.setComboBoxEditable(false);
                mySelf.setReadOnlyView(readOnlyView);
                return mySelf;
            }
        });
    }

    protected abstract GenericComboBoxCell&lt;RT, VT&gt; getComboBoxCellRef();

    /**
     * logic to disable the combobox, for example if the value ist null or ...
     *
     * @return
     */
    public abstract boolean disableComboBox(final RT row);

    public abstract List&lt;vt&gt; createComboBoxValues(final RT row);

    public abstract void workOnRowItself(final RT row);


    public boolean isReadOnlyView() {
        return readOnlyView;
    }

    public void setReadOnlyView(boolean readOnlyView) {
        this.readOnlyView = readOnlyView;
    }
}
]]&gt;&lt;/script&gt;

The developer must extend this class and has to implement the following methods only:&lt;br /&gt;
- protected abstract GenericComboBoxCell&lt;rt vt=""&gt; getComboBoxCellRef();&amp;nbsp;&lt;/rt&gt;&lt;br /&gt;
&lt;rt vt=""&gt;- public abstract boolean disableComboBox(final RT row); (optional)&amp;nbsp;&lt;/rt&gt;&lt;br /&gt;
&lt;rt vt=""&gt;- public abstract List&lt;vt&gt; createComboBoxValues(final RT row);&amp;nbsp;&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;rt vt=""&gt;&lt;vt&gt;- public abstract void workOnRowItself(final RT row); (optional)&amp;nbsp;&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;rt vt=""&gt;&lt;vt&gt;A demo implementation is shown here:&amp;nbsp;&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class BetragComboBoxCell extends GenericComboBoxCell&lt;TransientDemoDataRow, Double&gt; {

    @Inject Instance&lt;contextlogic&gt; contextLogicInstance; //business logic
    @Inject Instance&lt;betragcomboboxcell&gt; betragComboBoxCellInstance; //the cell instance itself

    @Override
    protected GenericComboBoxCell&lt;TransientDemoDataRow, Double&gt; getComboBoxCellRef() {
        return betragComboBoxCellInstance.get();
    }

    @Override public boolean disableComboBox(TransientDemoDataRow row) {
        return row.getBetrag() == null || row.getBetrag().isInfinite() || row.getBetrag().isNaN();
    }

    @Override public List&lt;double&gt; createComboBoxValues(TransientDemoDataRow row) {
        final ContextLogic contextLogic = contextLogicInstance.get();
        final List&lt;double&gt; doubleList = contextLogic.workOnContext(row.getBetrag());
        return doubleList;
    }

    @Override public void workOnRowItself(TransientDemoDataRow row) {
        //nothing for this example
    }
}
]]&gt;&lt;/script&gt;


&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;rt vt=""&gt;&lt;vt&gt;The controlle will need a piece of code like this:&amp;nbsp;&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
    @Inject Instance&lt;betragcomboboxcell&gt; betragComboBoxCellInstance;

    private void initTable() {
        final BetragComboBoxCell cell = betragComboBoxCellInstance.get();
        cell.associateWithCol(tableView, "betrag");
    }
]]&gt;&lt;/script&gt;

&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;rt vt=""&gt;&lt;vt&gt;With this you can test the context logic indepentend from the javafx stuff.&amp;nbsp;&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;rt vt=""&gt;&lt;vt&gt;All initializations inside a ComboBoxCell must be done in a PostConstruct - method.&amp;nbsp;&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;rt vt=""&gt;&lt;vt&gt;With the&amp;nbsp;GenericComboBoxCell&amp;nbsp;you can activate/deactivate the combobox, modify the row cell values, and create the combobox values.&amp;nbsp;&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;rt vt=""&gt;&lt;vt&gt;This implementation is based on the JavaFX/CDI bootstrap from cdi-commons-fx. (blog entry &lt;a href="http://www.rapidpm.org/2013/08/cdicommonsfx-javafxcdi-bootstrap.html" target="_blank"&gt;JavaFX/CDI bootstrap&lt;/a&gt; )&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://2.bp.blogspot.com/-AQ7GFqVQD4U/Uin3Zyv-FxI/AAAAAAABTbs/Kp70aYegR3U/s1600/tableview001.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://2.bp.blogspot.com/-AQ7GFqVQD4U/Uin3Zyv-FxI/AAAAAAABTbs/Kp70aYegR3U/s1600/tableview001.jpg" height="216" width="320" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://2.bp.blogspot.com/-8qDppXPeXes/Uin3Z_Su-pI/AAAAAAABTb4/BLIB0FT2cLI/s1600/tableview002.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://2.bp.blogspot.com/-8qDppXPeXes/Uin3Z_Su-pI/AAAAAAABTb4/BLIB0FT2cLI/s1600/tableview002.jpg" height="218" width="320" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;rt vt=""&gt;&lt;vt&gt;UML of this demo:&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://1.bp.blogspot.com/-ePJ6s1IzMKE/Uiny8-L--tI/AAAAAAABTbY/3hK_OgfHDPc/s1600/uml.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img alt="" border="0" src="http://1.bp.blogspot.com/-ePJ6s1IzMKE/Uiny8-L--tI/AAAAAAABTbY/3hK_OgfHDPc/s1600/uml.png" height="608" title="" width="640" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;rt vt=""&gt;&lt;vt&gt;Full CDI dependicies&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://4.bp.blogspot.com/-1CreRx6oh_I/UinzViniCcI/AAAAAAABTbg/E6C0MdnnRTQ/s1600/cdi-deps.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://4.bp.blogspot.com/-1CreRx6oh_I/UinzViniCcI/AAAAAAABTbg/E6C0MdnnRTQ/s1600/cdi-deps.png" height="254" width="640" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>complex PropertyBindings</title>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="Java"/>
        <category label="JavaFX"/>
        <category label="PropertyBinding"/>
        <category label="RapidPM"/>
        <published>2013-10-08T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/10/08/complex-propertybindings.html&gt;complex PropertyBindings&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-10-08 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
Today I had to deal with different dependent input-fields.
&lt;br/&gt;
Let´s say you have (only) two TextFields, leftTextField and rightTextField.
If you writing something into the left TextField you have to calculate something (Logic A) and write it to the right TextField.
If you are writing to the right one you have to calculate something (Logic B) and write it to the left TextField.
&lt;br/&gt;
This example is quite simple, but if you have to deal with a lot of fields with different deps based on a transient context
you have to solve:
&lt;br/&gt;
- cycles between the different components.
&lt;br/&gt;
- in this case, the transient context that was changing the logic (here Logic A and Logic B).
&lt;br/&gt;
&lt;br/&gt;
First the component called PairedTextField.
&lt;br/&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[ 
public class PairedTextField extends Pane {

    private final TextField leftTextField = new TextField();
    private final TextField rightTextField = new TextField();

    private final HBox hb = new HBox();
    private int spacing = 10;

    public PairedTextField() {
        setAnchors(hb, 0.0);
        hb.getChildren().addAll(leftTextField, rightTextField);
        hb.setSpacing(spacing);
        getChildren().add(hb);
        setPadding(new Insets(0, 10, 0, 10));
    }

    private void setAnchors(Node node , Double anchor){
        AnchorPane.setBottomAnchor(node, anchor);
        AnchorPane.setLeftAnchor(node, anchor);
        AnchorPane.setRightAnchor(node, anchor);
        AnchorPane.setTopAnchor(node, anchor);
    }
}

]]&gt;&lt;/script&gt;

Now, how to bind both TextFields to get the result?
If you are binding bidirectional you will get a Stackoverflow. To solve this you can do something like the following:
&lt;br/&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
leftTextField.setOnKeyTyped(new EventHandler&lt;KeyEvent&gt;() {
            @Override public void handle(KeyEvent keyEvent) {
                rightTextField.textProperty().bind(leftTextFieldBinding);
            }
        });
        leftTextField.setOnKeyReleased(new EventHandler&lt;KeyEvent&gt;() {
            @Override public void handle(KeyEvent keyEvent) {
                rightTextField.textProperty().unbind();
            }
        });

        rightTextField.setOnKeyTyped(new EventHandler&lt;KeyEvent&gt;() {
            @Override public void handle(KeyEvent keyEvent) {
                leftTextField.textProperty().bind(rigthTextFieldBinding);
            }
        });
        rightTextField.setOnKeyReleased(new EventHandler&lt;KeyEvent&gt;() {
            @Override public void handle(KeyEvent keyEvent) {
                leftTextField.textProperty().unbind();
            }
        });
 ]]&gt;&lt;/script&gt;

This simple solution is working well. Binding if you need it, unbind after this. Thanks to JavaFX PropertyBinding ;-)
Finally we have to deal with the different implementations of the logic-part for every request.
&lt;br/&gt;
The class Bindings will give you the method createStringBinding(Callable, Property), with this you can create the Bindings (leftTextFieldBinding, rigthTextFieldBinding).
What you need now is the implementation of the Callable&lt;String&gt;. If you are doing it in the "normal" way you have to write it like the following
    &lt;br/&gt;
    &lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class LeftTextFieldBindingCallable extends Callable&lt;String&gt;{
    final DemoLogic demoLogic = new DemoLogic();

    @Override public String call() throws Exception {
        return "leftTextField - " + demoLogic.doIt();
    }
}
]]&gt;&lt;/script&gt;

    With this solution you are not able to switch the implementation of the attribute "demoLogic". Nicer would be something like
    &lt;br/&gt;
    &lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class LeftTextFieldBindingCallable extends CDICallable&lt;String&gt;{
    @Inject Instance&lt;DemoLogic&gt; demoLogic;

    @Override public String call() throws Exception {
        return "leftTextField - " + demoLogic.get().doIt();
    }
}
]]&gt;&lt;/script&gt;

    With every request you will get the possibility to change the implementation of DemoLogic. The Producer will decide wich implementation will be used.
    &lt;br/&gt;
    &lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class DemoLogicProducer {

    @Produces
    public DemoLogic create(BeanManager beanManager, InjectionPoint injectionPoint){
        //decide which implementation to use...
        //here simple version..
        return  new DemoLogic();
    }
}
]]&gt;&lt;/script&gt;
    &lt;br/&gt;
    Now, putting all together:
    &lt;br/&gt;
    &lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class PairedTextField extends Pane {

    private final TextField leftTextField = new TextField();
    private final TextField rightTextField = new TextField();

    private final HBox hb = new HBox();
    private int spacing = 10;

    @Inject Instance&lt;LeftTextFieldBindingCallable&gt; leftTextFieldBindingCallableInstance;
    @Inject Instance&lt;RightTextFieldBindingCallable&gt; rightTextFieldBindingCallableInstance;


    public PairedTextField() {
        setAnchors(hb, 0.0);
        hb.getChildren().addAll(leftTextField, rightTextField);
        hb.setSpacing(spacing);
        getChildren().add(hb);
        setPadding(new Insets(0, 10, 0, 10));

        CDIContainerSingleton.getInstance().activateCDI(this);

    }

    @PostConstruct
    public void init(){
        final StringBinding leftTextFieldBinding = Bindings.createStringBinding(leftTextFieldBindingCallableInstance.get(), leftTextField.textProperty());

        final StringBinding rigthTextFieldBinding = Bindings.createStringBinding(rightTextFieldBindingCallableInstance.get(), rightTextField.textProperty());


        leftTextField.setOnKeyTyped(new EventHandler&lt;KeyEvent&gt;() {
            @Override public void handle(KeyEvent keyEvent) {
                rightTextField.textProperty().bind(leftTextFieldBinding);
            }
        });
        leftTextField.setOnKeyReleased(new EventHandler&lt;KeyEvent&gt;() {
            @Override public void handle(KeyEvent keyEvent) {
                rightTextField.textProperty().unbind();
            }
        });

        rightTextField.setOnKeyTyped(new EventHandler&lt;KeyEvent&gt;() {
            @Override public void handle(KeyEvent keyEvent) {
                leftTextField.textProperty().bind(rigthTextFieldBinding);
            }
        });
        rightTextField.setOnKeyReleased(new EventHandler&lt;KeyEvent&gt;() {
            @Override public void handle(KeyEvent keyEvent) {
                leftTextField.textProperty().unbind();
            }
        });
    }


    private void setAnchors(Node node , Double anchor){
        AnchorPane.setBottomAnchor(node, anchor);
        AnchorPane.setLeftAnchor(node, anchor);
        AnchorPane.setRightAnchor(node, anchor);
        AnchorPane.setTopAnchor(node, anchor);
    }
}
]]&gt;&lt;/script&gt;
    &lt;br/&gt;
    The importand parts are:
    &lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[

public abstract class  CDICallable&lt;T&gt; implements Callable&lt;T&gt; {
    protected CDICallable() {
        CDIContainerSingleton.getInstance().activateCDI(this);
    }
}

//...
CDIContainerSingleton.getInstance().activateCDI(this);
//..
 
        final StringBinding leftTextFieldBinding = Bindings.createStringBinding(leftTextFieldBindingCallableInstance.get(), leftTextField.textProperty());

        final StringBinding rigthTextFieldBinding = Bindings.createStringBinding(rightTextFieldBindingCallableInstance.get(), rightTextField.textProperty());


]]&gt;&lt;/script&gt;

    &lt;br/&gt;
    &lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://1.bp.blogspot.com/-VJn5X9vrTig/UlQZiDC4LfI/AAAAAAABUV4/GKtv6srW2SY/s1600/diagram.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://1.bp.blogspot.com/-VJn5X9vrTig/UlQZiDC4LfI/AAAAAAABUV4/GKtv6srW2SY/s400/diagram.png" /&gt;&lt;/a&gt;&lt;/div&gt;


&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>TestFX internals explained</title>
        <category label="Java"/>
        <category label="JavaFX"/>
        <category label="jUnit"/>
        <category label="TestFX"/>
        <published>2014-01-03T00:00:00+01:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2014/01/03/testfx-internals-explained.html&gt;TestFX internals explained&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2014-01-03 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
TestFX a small but powerful framework for JavaFX GUI Testing with jUnit.&lt;br/&gt;
How it is used and how it is working inside?&lt;br/&gt;
&lt;br/&gt;
TDD for GUI development is for a lot of developers something that make them feeling uncomfortable.&lt;br/&gt;
Using jUnit for the testing of the GUI Elements is mostly not what you want to do. &lt;br/&gt;
But with TestFX it is quite simple to write short but reusable tests.&lt;br/&gt;
&lt;br/&gt;
Let´s start with the project initialization. You need only a few entries in you pom.xml.&lt;br/&gt;
jUnit, hamcrest and testfx, that is it.. and nothing more.&lt;br/&gt;

&lt;br /&gt;
&lt;pre class="brush: xml"&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.loadui&lt;/groupId&gt;
    &lt;artifactId&gt;testFx&lt;/artifactId&gt;
    &lt;version&gt;3.0.0 &lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.hamcrest&lt;/groupId&gt;
    &lt;artifactId&gt;hamcrest-all&lt;/artifactId&gt;
    &lt;version&gt;1.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;version&gt;4.11&lt;/version&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.hamcrest&lt;/groupId&gt;
            &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
    &lt;/class&gt;&lt;/pre&gt;
After we added this entries to the pom.xml, we can start with the first jUnitTest using TestFX.&lt;br/&gt;
We will start with the traditional &lt;b&gt;HelloWorld&lt;/b&gt;. The first step is the creation of a TestClass.&lt;br/&gt;
The TestClass must extend from GuiTest, a base class from the TestFX Framework. &lt;br/&gt;
This class is abstract and you have to implement the method &lt;b&gt;protected Parent getRootNode()&lt;/b&gt;&lt;br/&gt;
This method must create the GUI element that you will test. I our example we want to test a simple button.&lt;br/&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;
@Category(TestFX.class)
public class SimpleButtonTest extends GuiTest {
    @Override
    protected Parent getRootNode() {
        final Button btn = new Button();
        btn.setId("btn");
        btn.setText("Hello World");
        btn.setOnAction((actionEvent)-&gt; btn.setText( "was clicked" ));
        return btn;
    }
}
    &lt;/class&gt;&lt;/pre&gt;
You can see, that you don´t have to create a holder for your GUI element.&lt;br/&gt;
Now we can start with the first test itself.&lt;br/&gt;
The button will change the text from "Hello World" to "was clicked" if the user will click the button.&lt;br/&gt;
How we can test this?&lt;br/&gt;

As normal we have to write a test method annotated with the @Test from jUnit.&lt;br/&gt;
The first question will be, how to get the reference of the button? &lt;br/&gt;
For this you can use one of the service methods. With find and the id you will get the instance.&lt;br/&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;
@Test
public void shouldClickButton(){
    final Button button = find( "#btn" );
    click(button);
    verifyThat( "#btn", hasText("was clicked") );
}
    &lt;/class&gt;&lt;/pre&gt;
As you can see, we can start with the functional tests after we got the reference. Here we are simulating the click.&lt;br/&gt;
After this we are checking if the result is as expected.&lt;br/&gt;
Writing tests looks now like , writing the use case with methods organized with the builder pattern.&lt;br/&gt;
If you want to write your own check like hasText() you have to write it with the framework hamcrest.&lt;br/&gt;
But TestFX will provide a lot of default checks and test-steps. Mostly you don not need more.&lt;br/&gt;
&lt;br/&gt;
But how TestFX is doing all this?&lt;br/&gt;
Starting with the test class GUITest, we know that we have to create the GUI element we want to test.&lt;br/&gt;
The class GUITest itself contains a lot of methods to describe the use case with &lt;br/&gt;
actions like click,drag,move,push, scroll, rightClick and so on.&lt;br/&gt;
But how the application is started? This will be done by the internal class TestFXApp inside GUITest. &lt;br/&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;
public static class TestFxApp extends Application
{
    private static Scene scene = null;

    @Override
    public void start( Stage primaryStage ) throws Exception
    {
        primaryStage.initStyle(StageStyle.UNDECORATED);
        primaryStage.show();
        stageFuture.set( primaryStage );
    }

    public static void setRoot( Parent rootNode )
    {
        scene.setRoot( rootNode );
    }
}
    &lt;/class&gt;&lt;/pre&gt;
Every developer that was writing the first few jUnit tests for an JavaFX application &lt;br/&gt;
came to the point where the JVM was telling something like &lt;br/&gt;
"please, only one instance of the JavaFX Application please"&lt;br/&gt;
How to deal with this?&lt;br/&gt;
The basic is quite simple. You have to start the application in one thread, save this as an singleton over all jUnit tests in one JVM.&lt;br/&gt;
After this, put every junit test method in one Callable and start them one after an other.&lt;br/&gt;
The first step will be done with the method setupStage, annotated with @Before.&lt;br/&gt;
Inside this there is a check if the singleton is already there or not. If not, it will be created. FXTestUtils.launchApp(TestFxApp.class);&lt;br/&gt;
After this the GUI element from getRootNode() will be placed in a new Runnable.&lt;br/&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;
@Before
public void setupStage() throws Throwable{
    showNodeInStage();
}

private void showNodeInStage(){
    showNodeInStage(null);
}

private void showNodeInStage( final String stylesheet ){
    GuiTest.stylesheet = stylesheet;

    if( stage == null ){
        FXTestUtils.launchApp(TestFxApp.class);
        try{
            stage = targetWindow(stageFuture.get( 25,TimeUnit.SECONDS ) );
            FXTestUtils.bringToFront( stage );
        }catch( Exception e ) {
            throw new RuntimeException( "Unable to show stage", e );
        }
    }

    try{
        FXTestUtils.invokeAndWait( new Runnable(){
            @Override
            public void run(){
                Scene scene = SceneBuilder
                    .create()width( 600 ) height( 400 )
                    .root( getRootNode() ).build();

                if(stylesheet!=null) 
                    scene.getStylesheets().add(stylesheet);
                stage.setScene( scene );
            }
        }, 5 );
    }catch( Exception e ) {
        e.printStackTrace();
    }
}

    &lt;/class&gt;&lt;/pre&gt;

That´s it. Quite simple and easy to use for a developer.&lt;br/&gt;
The good thing is, that TestFX is good usable in an CI environment. &lt;br/&gt;
You only have to configure jUnit if not already done.&lt;br/&gt;
&lt;br/&gt;
But this is not the end..  I am working in the moment at the full CDI support inside &lt;br/&gt;
TestFX. We will see it in one of the next versions from TestFX. stay tuned...&lt;br/&gt;
&lt;br/&gt;
If you have any ideas what we can improve..    let me know..&lt;br/&gt;
&lt;br/&gt;
happy javafx testing&lt;br/&gt;
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>FXController with CDI managed DynamicObjectAdapter - Part 1</title>
        <category label="Arquillian"/>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="Java"/>
        <category label="JavaFX"/>
        <category label="JDK8"/>
        <category label="Reflection"/>
        <category label="Weld"/>
        <published>2014-01-10T00:00:00+01:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2014/01/10/fxcontroller-with-cdi-managed-dynamico.html&gt;FXController with CDI managed DynamicObjectAdapter - Part 1&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2014-01-10 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
Today I will show the first step how you can use a dynamic proxy for JavaFX Controller.&lt;br/&gt;
This we will need for the CDI support inside TestFX.. but this later..&lt;br/&gt;
&lt;br/&gt;
During I was writing on my reflection shortcut together with Dr. Heinz Kabutz&lt;br/&gt;
(will be first available in german, later in english if asked for) I was thinking about his Newsletter &lt;br/&gt;
about "Object Adapter based on Dynamic Proxy". &lt;br/&gt;
Based on this we will now transform this into an CDI pattern for JavaFX Controller.&lt;br/&gt;
&lt;br/&gt;
The basic target will be an decorator for an CDI environment, to switch between implementations of defined methods&lt;br/&gt;
of an controller. Ok, there is an decorator defined inside the CDI environment but with some hard limitations.&lt;br/&gt;
&lt;br/&gt;
First of all, you have to define the decorator inside the beans.xml. I don´t like this. &lt;br/&gt;
If something will be changed you have to restart the container. And the definition is static.&lt;br/&gt;
The second I not like, is the usage of an decorator. &lt;br/&gt;
&lt;br/&gt;
You have to annotate the class, &lt;br/&gt;
you have to inject the basic implementation&lt;br/&gt;
and you have to extend the basic implementation.  &lt;br/&gt;
&lt;br/&gt;
This is too much and the main disadvantage: you have to decide what decorator to use in the static context.&lt;br/&gt;
&lt;br/&gt;
How to solve this? &lt;br/&gt;
&lt;br/&gt;
Let´s start with the basic step. With the default methods in JDK8 you don´t need a basic Implementation class.&lt;br/&gt;
But you have an interface. Let´s say we have an interface called DemoLogic.&lt;br/&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;
@CDINotMapped
public interface DemoLogic {

    public default int add(int a, int b){
        return a+b;
    }

    public default int sub(int a, int b){
        return a-b;
    }
}
    &lt;/class&gt;&lt;/pre&gt;

Importand is the annotation, to exclude this from the default scope inside CDI. You will see it later why..&lt;br/&gt;
&lt;br/&gt;
The next thing we want to have is an special implementation from the add method. This we will implement inside a class &lt;br/&gt;
called DemoLogicAdapter_A.&lt;br/&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;
@CDINotMapped
public class DemoLogicAdapter_A implements DemoLogic{

    public int add(int a, int b){
        System.out.println("DemoLogicAdapter_A.add");
        return a+b + 100;
    }
}
    &lt;/class&gt;&lt;/pre&gt;

Same here with the annotation. The good thing is, you really have to implement the changed method only.&lt;br/&gt;
No other delegator stuff.&lt;br/&gt;
&lt;br/&gt;
Next we need, is something to decide dynamically if we want to use the original implementation or the special one.&lt;br/&gt;
This we will simulate with a singleton calles Context. This class with only one boolean attribute called original&lt;br/&gt;
is to simulate a decicion logic.&lt;br/&gt;
If the attribute is true, we are in context original otherwise we are inside the context customer specific.&lt;br/&gt;

&lt;br /&gt;
&lt;pre class="brush: java"&gt;
@Singleton
public class Context {

    public boolean original = true;
}
    &lt;/class&gt;&lt;/pre&gt;

Now we will use it like the developer will do it later in a high level way.&lt;br/&gt;
For this we write a jUnit Test to test this.&lt;br/&gt;
The test will do the following.&lt;br/&gt;
Inject the DemoLogic, call the method add and test if the original version was used.&lt;br/&gt;
After this switch the context by setting the attribut original to false.&lt;br/&gt;
Now get the demologic again and call the method add. &lt;br/&gt;
If all is all right we will get the customer specific result.&lt;br/&gt;


&lt;br /&gt;
&lt;pre class="brush: java"&gt;
@RunWith(Arquillian.class)
public class DemoLogicTest {
    @Deployment
    public static JavaArchive createDeployment() {
        return ShrinkWrap.create(JavaArchive.class)
                .addPackages(true, "org.rapidpm.commons")
                .addAsManifestResource(EmptyAsset.INSTANCE, "beans.xml");
    }

    @Inject @DynamicDecoratorTest Instance&lt;DemoLogic&gt; demoLogic;
    @Inject Context context;
    @Test
    public void testDemoLogicOriginalTest() throws Exception {
    Assert.assertNotNull(demoLogic);
    final DemoLogic demoLogic1 = demoLogic.get();
    final int add = demoLogic1.add(1, 1);
    Assert.assertEquals(2,add);
    System.out.println("add = " + add);

    context.original = false;
    final DemoLogic demoLogic2 = demoLogic.get();
    final int addAdapted = demoLogic2.add(1, 1);
    Assert.assertEquals(102,addAdapted);
    System.out.println("addAdapted = " + addAdapted);
    }
    }
    &lt;/class&gt;&lt;/pre&gt;
I am using arquillian to have CDI support inside my jUnit Tests.&lt;br/&gt;
The annotation DynamicDecoratorTest is to separate this test from the rest of my tests.&lt;br/&gt;
&lt;br/&gt;
You see the usage quite clear. The developer will only see the interface. He will use it like &lt;br/&gt;
he will do it as normal. No change to see! Let´s asume the context switch is done by the system,&lt;br/&gt;
hidden, so the the develper is not able to see it. &lt;br/&gt;
He will write code only with the thinking about the business logic to implement.&lt;br/&gt;
&lt;br/&gt;
Afer we described what we want to have, we will implement the core. &lt;br/&gt;
To get an instance of the DemoLogic, we need a producer. We will call the class DemoLogicProducer.&lt;br/&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;
public class DemoLogicProducer {

    @Inject Instance&lt;DynamicObjectAdapterFactory&gt; dynamicObjectAdapterFactoryInstance;

    @Inject Context context;

    @Produces @DynamicDecoratorTest
    public DemoLogic create(ManagedInstanceCreator instanceCreator){
    final DemoLogic demoLogic = instanceCreator.activateCDI(new DemoLogic() {});

    final DynamicObjectAdapterFactory dynamicObjectAdapterFactory = dynamicObjectAdapterFactoryInstance.get();

    final Object adapter;
    if (context.original){
    adapter = new Object();
    } else {
    adapter = instanceCreator.activateCDI(new DemoLogicAdapter_A());
    }

    return dynamicObjectAdapterFactory.adapt(demoLogic, DemoLogic.class, adapter);
    }
    }
    &lt;/class&gt;&lt;/pre&gt;
The basic what we are simulating here ist the switch between original and customer specific.&lt;br/&gt;
This will be more comfortable in the next post. (using a ContextResolver)&lt;br/&gt;
But to show the basic step this is made explicite simple.&lt;br/&gt;
If the attribute is true, use the original one otherwise use the customer specific.&lt;br/&gt;
Very simple.. Both instances are manually put inside the CDI environment. &lt;br/&gt;
This ist only to show that the adapter itself can be managed too.&lt;br/&gt;
&lt;br/&gt;
The most importand step is the transparent wrapping with the DynamicObjectAdapterFactory.&lt;br/&gt;
The developer will not see this, until he is debugging ;-)&lt;br/&gt;
&lt;br/&gt;
How this factory is working? &lt;br/&gt;
The factory is using the java.lang.reflect.Proxy from the JDK itself. An old but very usefull class.&lt;br/&gt;
In my case I will use this in side a CDI managed environment. &lt;br/&gt;

&lt;br /&gt;
&lt;pre class="brush: java"&gt;
public class DynamicObjectAdapterFactory {

    @Inject Instance&lt;CDIInvocationHandler&gt; cdiInvocationHandlerInstance;

    public  &lt;T&gt; T adapt(final Object adaptee,final Class&lt;T&gt; target,final Object adapter) {

        final CDIInvocationHandler invocationHandler = cdiInvocationHandlerInstance
        .get()
        .adapter(adapter)
        .adaptee(adaptee);

        return (T) Proxy.newProxyInstance(
        target.getClassLoader(),
        new Class[]{target},
        invocationHandler
        );
        }

        }
        &lt;/class&gt;&lt;/pre&gt;
This means I will be able to inject, for example, the InvocationHandler. &lt;br/&gt;
This I need, because I need a managed InvocationHandler. &lt;br/&gt;
The usage of the Proxy is nothing complex. But the InvocationHandler is the final and importand step.&lt;br/&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;
public class CDIInvocationHandler implements InvocationHandler {

    @Inject @CDILogger Logger logger;

    private Map&lt;MethodIdentifier, Method&gt; adaptedMethods = new HashMap&lt;&gt;();

    private Object adapter;
    private Object adaptee;

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

        if (adaptedMethods.isEmpty()){
            final Class&lt;?&gt; adapterClass = adapter.getClass();
            Method[] methods = adapterClass.getDeclaredMethods();
            for (Method m : methods) {
                adaptedMethods.put(new MethodIdentifier(m), m);
            }
        }else{
            if (logger.isDebugEnabled()) {
                logger.debug("adaptedMethods is initialized..");
            }
        }
        try {
            Method other = adaptedMethods.get(new MethodIdentifier(method));
            if (other != null) {
                return other.invoke(adapter, args);
            } else {
                return method.invoke(adaptee, args);
            }
        } catch (InvocationTargetException e) {
            throw e.getTargetException();
        }
    }

    public CDIInvocationHandler adapter(final Object adapter) {
        this.adapter = adapter;
        return this;
    }

    public CDIInvocationHandler adaptee(final Object adaptee) {
        this.adaptee = adaptee;
        return this;
    }


}

public class MethodIdentifier {
    private final String name;
    private final Class[] parameters;

    public MethodIdentifier(Method m) {
        name = m.getName();
        parameters = m.getParameterTypes();
    }

    // we can save time by assuming that we only compare against
    // other MethodIdentifier objects
    public boolean equals(Object o) {
        MethodIdentifier mid = (MethodIdentifier) o;
        return name.equals(mid.name) &amp;&amp;
                Arrays.equals(parameters, mid.parameters);
    }

    public int hashCode() {
        return name.hashCode();
    }
}

    &lt;/class&gt;&lt;/pre&gt;

The method invoke is called every time a method is called on the proxy. This is the place to decide which method will be called.&lt;br/&gt;
From the adapter we will get all methods and put them inside a HashMap. The key is based on method-name and attributes. &lt;br/&gt;
If a method is called with this key, we will get the adapter instance of this method from the map and &lt;br/&gt;
will call this instead of the original one.&lt;br/&gt;
If not key found, we will call the original nethod.&lt;br/&gt;
This is really simple!&lt;br/&gt;
&lt;br/&gt;
This means you have everywhere CDI managed instances.&lt;br/&gt;
You have only to implement what you whant to change.&lt;br/&gt;
It is dynamic with every request.&lt;br/&gt;
No beans.xml must be edited.&lt;br/&gt;
&lt;br/&gt;
You never need the decorator from CDI anymore. ;-)  &lt;br/&gt;
&lt;br/&gt;
Next step will be the integration iside an JavaFX controller.. and TestFX CDI Support&lt;br/&gt;
&lt;br/&gt;

&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>IoT with Java8 and TinkerForge Part 1</title>
        <category label="IoT"/>
        <category label="Java"/>
        <category label="JavaFX"/>
        <category label="JDK8"/>
        <category label="TinkerForge"/>
        <published>2014-01-13T00:00:00+01:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2014/01/13/iot-with-java8-and-tinkerforge-part-1.html&gt;IoT with Java8 and TinkerForge Part 1&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2014-01-13 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
IoT is something cool, but I think you know it already.&lt;br /&gt;
Today I started with TinkerForge.
TinkerForge is a german company that are building electronic elements. You can put them together like LEGO.
This means, that you don´t need any special electronic stuff or knowledge.
&lt;br /&gt;
And the best, you can code plain Java to use them.&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;But how we can start?
&lt;/b&gt;&lt;br /&gt;
&lt;br /&gt;
First of all, you need a MasterBrick and at minimumm one sensor. For my first experiment I am using
the simple temperature sensor. After unpacking it I needed around 3 min to put all together.
After this you can plug it into your USB port. Now the hardware part is ready.
&lt;br /&gt;
&lt;br /&gt;
To speak with this components you have to install two things.&lt;br /&gt;
First the usb-driver, that is used for the communication with the MasterBrick,&lt;br /&gt;
second the BrickViewr. With this you can check the installation, update the firmware and so on.
&lt;br /&gt;
&lt;br /&gt;
You will find the software for&lt;b&gt; linux/osx/windows&lt;/b&gt;.
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Hello IoT World:&amp;nbsp;&lt;/b&gt;&lt;br /&gt;
&lt;br /&gt;
We will start with the first HelloWorld. Here with the Hello IoTWorld.&lt;br /&gt;
After you connected the MasterBrick with the USB-port you will see a blue light
and the MasterBrick will be ready for communication.
&lt;br /&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://1.bp.blogspot.com/-L4kMEQNQn7U/UtRZqJ_UlPI/AAAAAAABVGA/q_UgrGaqkdQ/s1600/SvenRuppert_IoT_TinkerForge_001_BrickV_001.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://1.bp.blogspot.com/-L4kMEQNQn7U/UtRZqJ_UlPI/AAAAAAABVGA/q_UgrGaqkdQ/s1600/SvenRuppert_IoT_TinkerForge_001_BrickV_001.jpg" height="140" width="320" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br /&gt;
Now we could start the BrickViewer to check the installation.
The importand part is the UID from the sensor. With this we can connect it later.
After you pressed the connect button, you can see all the informations.
&lt;br /&gt;
&lt;br /&gt;
At &lt;a href="https://bitbucket.org/rapidpm/jaxenter.de-0012-iot-tinkerforge"&gt;https://bitbucket.org/rapidpm/jaxenter.de-0012-iot-tinkerforge&lt;/a&gt; are all source codes you will need, including the TinkerForge API itself.&lt;br /&gt;
I spoke with TinkerForge and we decided to put the API into maven.&lt;br /&gt;
&lt;br /&gt;
After we have done this, I will inform you.
If you are interested, follow me on Twitter please ( &lt;b&gt;&lt;a href="https://twitter.com/SvenRuppert"&gt;@SvenRuppert&lt;/a&gt;&lt;/b&gt; )
&lt;br /&gt;
&lt;br /&gt;
The basic steps are quite simple to use this sensor.&lt;br /&gt;
&lt;br /&gt;
&lt;ul&gt;
    &lt;li&gt;create a IPConnection&amp;nbsp;&lt;/li&gt;
    &lt;li&gt;create an instance of the class BrickletTemperature&amp;nbsp;&lt;/li&gt;
    &lt;li&gt;configure the sensor&amp;nbsp;&lt;/li&gt;
    &lt;li&gt;add an ActionListener.&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
That is all.
&lt;br /&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;import com.tinkerforge.BrickletTemperature;
import com.tinkerforge.IPConnection;

public class ExampleCallback {
    private static final String host = "localhost";
    private static final int port = 4223;
    private static final String UID = "dXj"; 
    public static void main(String args[]) throws Exception {
        IPConnection ipcon = new IPConnection(); 
        BrickletTemperature temp = new BrickletTemperature(UID, ipcon); 
        ipcon.connect(host, port); 
        temp.setTemperatureCallbackPeriod(1000);
        temp.addTemperatureListener(new 
          BrickletTemperature.TemperatureListener() {
            public void temperature(short temperature) {
                System.out.println("Temperature: " 
                   + temperature/100.0 + " °C");
            }
        });
        ipcon.disconnect();
    }
}
&lt;/pre&gt;
After this short example we could do our first javafx test.
We want to check the temperature over some time and show this inside an LineChart.&lt;br /&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://2.bp.blogspot.com/-q7AnTcjRQz4/UtRaLcWsJFI/AAAAAAABVGI/lUAYpFuc87g/s1600/SvenRuppert_IoT_TinkerForge_001_Temp_001.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://2.bp.blogspot.com/-q7AnTcjRQz4/UtRaLcWsJFI/AAAAAAABVGI/lUAYpFuc87g/s1600/SvenRuppert_IoT_TinkerForge_001_Temp_001.jpg" height="199" width="320" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br /&gt;
&lt;br /&gt;
Here we are... and please note, the DateAxis is from&lt;a href="http://myjavafx.blogspot.de/2013/09/javafx-charts-display-date-values-on.html"&gt; http://myjavafx.blogspot.de/2013/09/javafx-charts-display-date-values-on.html&lt;/a&gt;&lt;br /&gt;
&lt;pre class="brush: java"&gt; 
 public class HelloTinkerForge extends Application {

    private static final String host = "localhost";
    private static final int port = 4223;
    private static final String UID = "dXj"; 


    public static void main(String args[]) throws Exception {
        launch(args);
    }

    public static XYChart.Series series;

    @Override
    public void start(Stage stage) {
        stage.setTitle("Line Chart TinkerForge Sample");
        final DateAxis dateAxis = new DateAxis();
        final NumberAxis yAxis = new NumberAxis();
        dateAxis.setLabel("Time of Temp");
        final LineChart&lt;date number=""&gt; lineChart
    = new LineChart&amp;lt;&amp;gt;(dateAxis, yAxis);

    lineChart.setTitle("Temp Monitoring");

    series = new XYChart.Series();
    series.setName("My temps");
    final ObservableList seriesData = series.getData();

    lineChart.getData().add(series);
    Scene scene = new Scene(lineChart, 800, 600);
    stage.setScene(scene);
    stage.show();
    new Worker(seriesData).start();

    }

    public static class Worker extends Thread {
    final ObservableList seriesData;
    public Worker(final ObservableList seriesData) {
    setDaemon(true);
    setName("Thread Temp");
    this.seriesData = seriesData;
    }

    @Override
    public void run() {
    Platform.runLater(new Runnable() {
    @Override
    public void run() {
    IPConnection ipcon = new IPConnection();
    BrickletTemperature temp
    = new BrickletTemperature(UID, ipcon);
    try {
    ipcon.connect(host, port);
    temp.setTemperatureCallbackPeriod(1000);
    temp.addTemperatureListener(
    new BrickletTemperature.TemperatureListener() {
    public void temperature(short temperature) {
    Platform.runLater(new Runnable() {
    @Override
    public void run() {
    final double temp
    = temperature / 100.0;
    final int counter
    = seriesData.size() + 1;
    final XYChart.Data data
    = new XYChart.Data(
    new Date(), temp);
    seriesData.add(data);
    }
    });
    }
    });
    } catch (IOException |
    AlreadyConnectedException |
    TimeoutException |
    NotConnectedException e) {
    e.printStackTrace();
    }
    }
    });
    }
    }
    }
&lt;/date&gt;&lt;/pre&gt;
&lt;pre class="brush: java"&gt;&lt;date number=""&gt;
&lt;/date&gt;&lt;/pre&gt;
Short and simple.. Well this is a simple example, but the next step will be with more sensor-elements...&lt;br /&gt;
&amp;nbsp;stay tuned..  and happy coding.
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>IoT with Java8 and TinkerForge Part 2</title>
        <category label="IoT"/>
        <category label="Java"/>
        <category label="JavaFX"/>
        <category label="JDK8"/>
        <category label="TinkerForge"/>
        <published>2014-01-20T00:00:00+01:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2014/01/20/iot-with-java8-and-tinkerforge-part-2.html&gt;IoT with Java8 and TinkerForge Part 2&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2014-01-20 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
One of the interesting features of &lt;a href="http://www.tinkerforge.com/"&gt;TinkerForge&lt;/a&gt; is the possibility to
put different elements like sensors, physical buttons, and more on a MasterBrick&lt;br /&gt;
&lt;br /&gt;
This is what we want to do today.
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;The Barometer&lt;/b&gt;&lt;br /&gt;
Today we are using the &lt;a href="http://www.tinkerforge.com/en/doc/Hardware/Bricklets/Barometer.html"&gt;Barometer-Bricklet&lt;/a&gt;.
The Barometer Bricklet can be used to extend the features of Bricks
by the capability to measure air pressure in range of 10 to 1200mbar
with a resolution of 0.012mbar. The measurement is temperature
compensated internally. The Bricklet is equipped with
a MS5611-01BA01 sensor which is designed to be used as an altimeter, too.
&lt;br /&gt;
&lt;br /&gt;
&lt;i&gt;At &lt;a href="https://bitbucket.org/rapidpm/jaxenter.de-0012-iot-tinkerforge"&gt;https://bitbucket.org/rapidpm/jaxenter.de-0012-iot-tinkerforge&lt;/a&gt; are all source codes you will need, including the TinkerForge API itself.
    I spoke with TinkerForge and we decided to put the API into maven. After we have done this, I will inform you.
    If you are interested, follow me on Twitter please ( &lt;b&gt;@SvenRuppert&lt;/b&gt; )
&lt;/i&gt;&lt;br /&gt;
&lt;br /&gt;
The most interesting part for us today will be the presents of two sensors inside of one Bricklet.&lt;br /&gt;
How we can handle it and how we will get the data to the screen?&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Connect to n - Sensor-units&lt;/b&gt;&lt;br /&gt;
To remember... To connect to a sensor you need an instance of the representing class.
To get the value from the sensor you have to implement an ActionListener.
Here the short example from my last blog about TinkerForge. &lt;i&gt;(&lt;a href="http://www.rapidpm.org/2014/01/iot-with-java8-and-tinkerforge-part-1.html"&gt;engl&lt;/a&gt; /&lt;a href="http://jaxenter.de/artikel/Internet-of-Things-mit-Java-8-und-TinkerForge-Teil-1-170511"&gt; ger&lt;/a&gt;)&lt;/i&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;import com.tinkerforge.BrickletTemperature;
import com.tinkerforge.IPConnection;
public class ExampleCallback {
  private static final String host = "localhost";
  private static final int port = 4223;
  private static final String UID = "dXj";
  public static void main(String args[]) throws Exception {
    IPConnection ipcon = new IPConnection();
    BrickletTemperature temp = new BrickletTemperature(UID, ipcon);
    ipcon.connect(host, port);
    temp.setTemperatureCallbackPeriod(1000);
    temp.addTemperatureListener(new
    BrickletTemperature.TemperatureListener() {
      public void temperature(short temperature) {
        System.out.println("Temperature: "
        + temperature/100.0 + " °C");
      }
    });
    ipcon.disconnect();
}
}
&lt;/pre&gt;
The same will be with the two sensor-units inside the Barometer-Bricklet.
The class name will be BrickletBarometer, and you have to implement two ActionListeners.
One for the air-pressure called AirPressureListener and one for the altitude called AltitudeListener.
&lt;br /&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;public class ExampleCallback {
    private static final String host = "localhost";
    private static final int port = 4223;
    private static final String UID = "jY4";

    public static void main(String args[]) throws Exception {
        IPConnection ipcon = new IPConnection();
        BrickletBarometer b = new BrickletBarometer(UID, ipcon);
        ipcon.connect(host, port);
        b.setAirPressureCallbackPeriod(1000);
        b.setAltitudeCallbackPeriod(1000);
        b.addAirPressureListener(
                new BrickletBarometer.AirPressureListener() {
                    public void airPressure(int airPressure) {
                        System.out.println("Air Pressure: "
                                + airPressure / 1000.0 + " mbar");
                    }
                }
        );
        b.addAltitudeListener(new BrickletBarometer.AltitudeListener() {
            public void altitude(int altitude) {
                System.out.println("Altitude: " + altitude / 100.0 + " m");
            }
        });
        ipcon.disconnect();
    }
}
&lt;/pre&gt;
&lt;b&gt;Connection to JavaFX&lt;/b&gt;&lt;br /&gt;
The connection to JavaFX could be simple. The basic steps are always the same.
You have to start an Thread outside our JavaFX GUI Thread. Inside this thread you have to configure the sensor
and inside the run()- method you have to add the action listener.
All steps that are manipulating the GUI, you have to start again inside a Platform.runLater()
Now, we have to sensor-units. This means that we are doing this twice.
To reuse the code later, we are extracting it into an separate class.
If we would do it for the temperature sensor we used last time, it will look like the following.
&lt;br /&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;public class Temp implements Runnable {

  private String UID;
  private ObservableList seriesData;

  public Temp(final String UID, final XYChart.Series series) {
      this.UID = UID;
      this.seriesData = series.getData();
  }

  @Override
  public void run() {
      IPConnection ipcon = new IPConnection();
      BrickletTemperature temp = new BrickletTemperature(UID, ipcon);
      try {
          ipcon.connect(Barometer.host, Barometer.port);
          temp.setTemperatureCallbackPeriod(1000);
          temp.addTemperatureListener(new BrickletTemperature.TemperatureListener() {
              public void temperature(short temperature) {
                  Platform.runLater(new Runnable() {
                      @Override
                      public void run() {
                          final double temp = temperature / 100.0;
                          System.out.println("Temperature: " + temp + " °C");
                          final XYChart.Data data = new XYChart.Data(new Date(), temp);
                          seriesData.add(data);
       }
                  });
              }
          });
      } catch (IOException 
       | AlreadyConnectedException 
    | TimeoutException 
    | NotConnectedException e) {
          e.printStackTrace();
      }
  }
}
&lt;/pre&gt;
For the Barometer-Bricklet I was writing two classes. One for the airpressure and one for the altitude.
Both are identically, with one difference. The implementation of the ActionListener.
Every sensor will put his data to a separate LineChart.&lt;br /&gt;
&amp;nbsp;This implementation is not perfect, because we are not disconnecting
from the sensor in the end, and for one Bricklet we have two representing classes.
Both instances are in a different thread.
But this is still running over a longer period. (at least a few days with my laptop)
How to encapsulate this in better way we will see in one of my next posts.

&lt;br /&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;public class Altitude implements Runnable {

    private String UID;
    private ObservableList seriesData;

    public Altitude(final String UID, final XYChart.Series series) {
        this.UID = UID;
        this.seriesData = series.getData();
    }

    @Override
    public void run() {
        IPConnection ipcon = new IPConnection();
        BrickletBarometer b = new BrickletBarometer(UID, ipcon);

        try {
            ipcon.connect(Barometer.host, Barometer.port);
            b.setAirPressureCallbackPeriod(1000);
            b.addAltitudeListener(new BrickletBarometer.AltitudeListener() {
                public void altitude(int altitude) {
                    System.out.println("Altitude: " + altitude / 100.0 + " m");
                    Platform.runLater(new Runnable() {
                        @Override
                        public void run() {
                            final double temp = altitude / 100.0;
                            final XYChart.Data data = new XYChart.Data(new Date(), temp);
                            seriesData.add(data);
                        }
                    });
                }
            });
        } catch (IOException | AlreadyConnectedException | TimeoutException | NotConnectedException e) {
            e.printStackTrace();
        }
    }
}
&lt;/pre&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;public class Airpressure implements Runnable {

    private String UID;
    private ObservableList seriesData;

    public Airpressure(final String UID, final XYChart.Series series) {
        this.UID = UID;
        this.seriesData = series.getData();
    }

    @Override
    public void run() {
        IPConnection ipcon = new IPConnection();
        BrickletBarometer b = new BrickletBarometer(UID, ipcon);

        try {
            ipcon.connect(Barometer.host, Barometer.port);
            b.setAirPressureCallbackPeriod(1000);
            b.addAirPressureListener(new BrickletBarometer.AirPressureListener() {
                public void airPressure(int airPressure) {
                    System.out.println("Air Pressure: " + airPressure / 1000.0 + " mbar");
                    Platform.runLater(new Runnable() {
                        @Override
                        public void run() {
                            final double temp = airPressure / 1000.0 ;
                            final XYChart.Data data = new XYChart.Data(new Date(), temp);
                            seriesData.add(data);
                        }
                    });
                }
            });
        } catch (IOException 
     | AlreadyConnectedException 
     | TimeoutException 
     | NotConnectedException e) {
            e.printStackTrace();
        }
    }
}
&lt;/pre&gt;
Putting all together we will get the following main.

&lt;br /&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;public class Barometer extends Application {
    public static final String host = "localhost";
    public static final int port = 4223;


    public static void main(String args[]) throws Exception {
        launch(args);
    }

    public static XYChart.Series seriesTemp = new XYChart.Series();
    public static XYChart.Series seriesAirpressure = new XYChart.Series();
    public static XYChart.Series seriesAltitude = new XYChart.Series();

    @Override
    public void start(Stage stage) {
        stage.setTitle("Line Chart TinkerForge Sample");

        final VBox box = new VBox();
        seriesTemp.setName("Temp");
        seriesAirpressure.setName("Airpressure");
        seriesAltitude.setName("Altitude");

        final ObservableList&lt;node&gt; boxChildren = box.getChildren();
        boxChildren.add(createLineChart("Temp", seriesTemp));
        boxChildren.add(createLineChart("Airpressure", seriesAirpressure));
        boxChildren.add(createLineChart("Altitude", seriesAltitude));

        Scene scene = new Scene(box, 2000, 1500);

        stage.setScene(scene);
        stage.show();
        Platform.runLater(new Temp("dXj", seriesTemp));
        Platform.runLater(new Airpressure("jY4", seriesAirpressure));
        Platform.runLater(new Altitude("jY4", seriesAltitude));
        }

        private LineChart createLineChart(final String chartName,final XYChart.Series series ){
        final DateAxis dateAxis = new DateAxis();
        dateAxis.setLabel("Time");
        final NumberAxis yAxis = new NumberAxis();

        final LineChart&lt;date number=""&gt; lineChart = new LineChart&amp;lt;&amp;gt;(dateAxis, yAxis);
            lineChart.setTitle(chartName);
            lineChart.getData().add(series);

            return lineChart;
            }
            }
        &lt;/date&gt;&lt;/node&gt;&lt;/pre&gt;
&lt;br /&gt;
&lt;i&gt;At&amp;nbsp;&lt;a href="https://bitbucket.org/rapidpm/jaxenter.de-0012-iot-tinkerforge"&gt;https://bitbucket.org/rapidpm/jaxenter.de-0012-iot-tinkerforge&lt;/a&gt;&amp;nbsp;are all source codes you will need, including the TinkerForge API itself. I spoke with TinkerForge and we decided to put the API into maven. After we have done this, I will inform you. If you are interested, follow me on Twitter please (&amp;nbsp;&lt;b&gt;@SvenRuppert&lt;/b&gt;&amp;nbsp;)&lt;/i&gt;&lt;br /&gt;
&lt;i&gt;&lt;br /&gt;&lt;/i&gt;
Short and simple.. as always ..
But if we are using more sensors in a way like this, we will get performance problems.
To solve this we are connecting different &lt;b&gt;NoSQL&lt;/b&gt; systems soon. And we have to build the next version of JavaFX GUI-Elements...
.... stay tuned..  and happy coding.

&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>TestFX a must for jUnit Tests inside JavaFX environments!</title>
        <category label="CDI"/>
        <category label="Java"/>
        <category label="JavaFX"/>
        <category label="TestFX"/>
        <published>2014-02-04T00:00:00+01:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2014/02/04/testfx-a-must-for-junit-tests-inside-j.html&gt;TestFX a must for jUnit Tests inside JavaFX environments!&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2014-02-04 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
&lt;b&gt;You have written jUnit Tests for JavaFX applications?&amp;nbsp;&lt;/b&gt;&lt;br /&gt;
&lt;b&gt;You want to simulate user interactions?&lt;/b&gt;&lt;br /&gt;
&lt;br /&gt;
If you are starting from scratch this will be a long task.&lt;br /&gt;
But the Team from TestFX is working on a solution.&lt;br /&gt;
TestFX (&lt;a href="https://github.com/SmartBear/TestFX"&gt;https://github.com/SmartBear/TestFX&lt;/a&gt;) is an OpenSource framework from Henrik Olsson (SmartBear) with the goal to be an easy-to-use framework for testing JavaFX.&lt;br /&gt;
&lt;br /&gt;
This framework is ready for Java8 and supports JavaFX 2.&lt;br /&gt;
With this you are able to test featured JavaFX based GUIs.&lt;br /&gt;
&lt;br /&gt;
No License needed, no costs, complete OpenSource and extensible.&lt;br /&gt;
&lt;br /&gt;
The fluent and clean API is simple to use for the interaction with the controls. No special wrapper must be implemented, no boilerplate code is needed to test a simple control. Extend the jUnit Test-class and create an instance of your JavaFX control.&lt;br /&gt;
&lt;br /&gt;
That´s all you need. After this you are able to interact directly with the instance you created.&lt;br /&gt;
TestFX will give you a lot of service methods to interact and verify the behavior of the tested control.&lt;br /&gt;
And, if something goes wrong, you will get an screenshot of the failed test.&lt;br /&gt;
&lt;br /&gt;
One of the really big advantages is the easy possibility to extend TestFX by yourself. The framework is clean and well structured.&lt;br /&gt;
The support for Hamcrest Matchers and Lambdas will give you all you need to build complex tests.&lt;br /&gt;
&lt;br /&gt;
There is only one more thing....&lt;br /&gt;
... &amp;nbsp;we are working on the&lt;b&gt; CDI support&lt;/b&gt; for TestFX.&lt;br /&gt;
&lt;br /&gt;
stay tuned and happy coding.&lt;br /&gt;
&lt;br /&gt;
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>FXController with CDI managed DynamicObjectAdapter - Part 2</title>
        <category label="Arquillian"/>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="Java"/>
        <category label="JavaFX"/>
        <category label="JDK8"/>
        <category label="Reflection"/>
        <category label="Weld"/>
        <published>2014-02-07T00:00:00+01:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2014/02/07/fxcontroller-with-cdi-managed-dynamico.html&gt;FXController with CDI managed DynamicObjectAdapter - Part 2&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2014-02-07 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
Based on my &lt;a href="http://www.rapidpm.org/2014/01/fxcontroller-with-cdi-managed.html"&gt;blog article part 1&lt;/a&gt; we want to integrate the DynamicObjectAdapter into an JavaFX application.
To remember: We have an interface called DemoLogic with two methods. add(..) and sub(..)
The implementation is really simple, but at runtime we could switch the implementation partially.
For this we needed an adapter.
&lt;br/&gt;
The biggest tdifference compared to the default CDI decorator was,
that we need no definition inside the beans.xml. The implementation is smaller
and no need for Qualifiers and other biolder-plate code.
&lt;br/&gt;
This DemoLogic we want to use now inside an JavaFX application.
For this we ned first an fxml.file called DemoPane.fxml. Here we will define a few elements.

&lt;br /&gt;
&lt;pre class="brush: javafx"&gt;
&amp;lt;?import javafx.scene.control.Button?&amp;gt;
&amp;lt;?import javafx.scene.control.TextField?&amp;gt;
&amp;lt;?import javafx.scene.layout.VBox?&amp;gt;
&amp;lt;?import javafx.scene.control.Label?&amp;gt;
&amp;lt;?import javafx.scene.control.CheckBox?&amp;gt;
&amp;lt;fx:root type=&amp;quot;javafx.scene.layout.AnchorPane&amp;quot;
            xmlns:fx=&amp;quot;http://javafx.com/fxml&amp;quot;&amp;gt;
    &amp;lt;children&amp;gt;
        &amp;lt;VBox&amp;gt;
            &amp;lt;children&amp;gt;
                &amp;lt;Button fx:id=&amp;quot;button&amp;quot; text=&amp;quot;Hello World&amp;quot; /&amp;gt;
                &amp;lt;CheckBox fx:id=&amp;quot;checkbox&amp;quot; text=&amp;quot;switch context&amp;quot;/&amp;gt;
                &amp;lt;TextField fx:id=&amp;quot;textFieldA&amp;quot;/&amp;gt;
                &amp;lt;TextField fx:id=&amp;quot;textFieldB&amp;quot;/&amp;gt;
                &amp;lt;Label fx:id=&amp;quot;label&amp;quot;/&amp;gt;
            &amp;lt;/children&amp;gt;
        &amp;lt;/VBox&amp;gt;

    &amp;lt;/children&amp;gt;

&amp;lt;/fx:root&amp;gt;
    &lt;/class&gt;&lt;/pre&gt;

With the button we will activate the calculation, with the checkbox we will switch the context.
To have a small as possible implementation, there is no error checking.
&lt;br/&gt;
The next will be the controller called DemoController. This is a normal JavaFX Controller, but CDI managed.
How to get this? Well there is a good blog article here ;-) &lt;a href="http://www.rapidpm.org/2013/08/javafxcdi-bootstrap-add-on.html"&gt;CDI JavaFX bootstrapping&lt;/a&gt;.
&lt;br/&gt;
Inside the DemoController we will get an Instance of the DemoLogic and the Context.
&lt;br /&gt;
&lt;pre class="brush: java"&gt;
@Inject
    @DynamicDecoratorTest
    Instance&amp;lt;DemoLogic&amp;gt; demoLogicInstance;

    @Inject
    Context context;
    &lt;/class&gt;&lt;/pre&gt;

The full implementation will be like the following.
&lt;br /&gt;
&lt;pre class="brush: java"&gt;
@DynamicDecoratorTest
public class DemoController implements Initializable{

    @FXML public TextField textFieldA;
    @FXML public TextField textFieldB;
    @FXML public Button button;
    @FXML public Label label;
    @FXML public CheckBox checkbox;

    @Inject
    @DynamicDecoratorTest
    Instance&amp;lt;DemoLogic&amp;gt; demoLogicInstance;

    @Inject
    Context context;

    @Override
    public void initialize(URL url, ResourceBundle resourceBundle) {
        button.setText(&amp;quot;klick me&amp;quot;);
        button.setOnAction(actionEvent -&amp;gt; {

            final DemoLogic demoLogic = demoLogicInstance.get();

            final String textFieldAText = textFieldA.getText();
            final Integer a = Integer.valueOf(textFieldAText);

            final String textFieldBText = textFieldB.getText();
            final Integer b = Integer.valueOf(textFieldBText);

            final int result = demoLogic.add(a, b);
            label.setText(result+&amp;quot;&amp;quot;);

        });

        checkbox.setOnAction(actionEvent -&amp;gt; {
            context.original = checkbox.isSelected();
        });
    }
}
    &lt;/class&gt;&lt;/pre&gt;

Inside the method initialize you will find the connection between the GUI logic and the business logic.
This is now clean devided.
&lt;br/&gt;
To test this I was using Arquillian. LAter we will see how we could do this with TestFX.
We are working on the CDI Support.

&lt;br /&gt;
&lt;pre class="brush: java"&gt;
@RunWith(Arquillian.class)
public class DemoLogicTest {
    @Deployment
    public static JavaArchive createDeployment() {
        return ShrinkWrap.create(JavaArchive.class)
                .addPackages(true, &amp;quot;org.rapidpm.demo&amp;quot;)
                .addPackages(true, &amp;quot;junit.org.rapidpm.demo&amp;quot;)
                .addPackages(true, &amp;quot;demo&amp;quot;)
                .addAsManifestResource(EmptyAsset.INSTANCE, &amp;quot;beans.xml&amp;quot;);
    }

    @Inject @DynamicDecoratorTest
    Instance&amp;lt;DemoController&amp;gt; demoControllerInstance;
    @Inject
    Context context;

    static final FXMLLoader loader = new FXMLLoader();

    @Test
    public void testDemoLogicJavaFXTest() throws Exception {
        loader.setControllerFactory(param -&amp;gt; demoControllerInstance.get());
        Application.launch(DemoApp.class);
    }


    public static class DemoApp extends Application {
        @Override
        public void start(Stage stage) throws Exception {

            final URL resource = getClass()
                    .getClassLoader()
                    .getResource(&amp;quot;DemoPane.fxml&amp;quot;);
            loader.setLocation(resource);
            final DemoController controller = (DemoController) loader
                    .getControllerFactory()
                    .call(DemoController.class);
            try {

                loader.setController(controller);
                loader.setRoot(new AnchorPane());
                final Parent root = (Parent) loader.load();

                stage.setScene(new Scene(root));
                stage.setTitle(&amp;quot;Custom Control&amp;quot;);
                stage.setWidth(300);
                stage.setHeight(200);
                stage.show();
            } catch (IOException exception) {
                throw new RuntimeException(exception);
            }

        }

        public static void main(String[] args) {
            launch(args);
        }
    }
}
    &lt;/class&gt;&lt;/pre&gt;
&lt;br/&gt;
You never need the decorator from CDI anymore. ;-)  
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>JDK8/Streams are cool? Here is the answer. ;-)</title>
        <category label="Java"/>
        <category label="JDK8"/>
        <category label="Streams"/>
        <published>2014-02-10T00:00:00+01:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2014/02/10/jdk8-streams-are-cool-here-is-the-answ.html&gt;JDK8/Streams are cool? Here is the answer. ;-)&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2014-02-10 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
Today I was preparing a few slides for my next JUG talk.
For this if started with a normal piece of code like the following.

&lt;br/&gt;
&lt;pre class="brush: java"&gt;  
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; generateDemoValueMatrix() {
        final List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; resultMatrix = new ArrayList&amp;lt;&amp;gt;();
        final Random random = new Random();
        for(int anzahlKurven = 0; anzahlKurven &amp;lt;ANZAHL_KURVEN; anzahlKurven++){
            final List&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();
            for (int i = 0; i &amp;lt; 10; i++) {
                final int nextInt = random.nextInt(100);
                result.add(nextInt);
            }
            resultMatrix.add(result);
        }
        return resultMatrix;
    }

    &lt;/class&gt;&lt;/pre&gt;
Next step would be the creation of two methods...
&lt;br/&gt;
&lt;pre class="brush: java"&gt;  
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; generateDemoValueMatrix() {
        final List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();
        for(int anzahlKurven = 0; anzahlKurven &amp;lt;ANZAHL_KURVEN; anzahlKurven++){
            final List&amp;lt;Integer&amp;gt; demoValuesForY = generateDemoValuesForY();
            result.add(demoValuesForY);
        }
        return result;
    }
    public List&amp;lt;Integer&amp;gt; generateDemoValuesForY() {
        final Random random = new Random();
        final List&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; 10; i++) {
            final int nextInt = random.nextInt(100);
            result.add(nextInt);
        }
        return result;
    }
    &lt;/class&gt;&lt;/pre&gt;
Ok, look´s like always... booooring.... So I started with Streams..
&lt;br/&gt;
&lt;pre class="brush: java"&gt;
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; generateDemoValueMatrix() {
        return Stream
                .generate(this::generateDemoValuesForY)
                .limit(ANZAHL_KURVEN)
                .collect(Collectors.toList());
    }
    public List&amp;lt;Integer&amp;gt; generateDemoValuesForY(){
        final Random random = new Random();
        return Stream
                .generate(() -&amp;gt; {
                    return random.nextInt(100);
                })
                .limit(10)
                .collect(Collectors.toList());
    }
    &lt;/class&gt;&lt;/pre&gt;
Not really better.. only new syntax.. now reducing the syntax..
&lt;br/&gt;
&lt;pre class="brush: java"&gt;
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; generateDemoValueMatrix() {
        return Stream
                .generate(this::generateDemoValuesForY)
                .limit(ANZAHL_KURVEN)
                .collect(Collectors.toList());
    }
    public List&amp;lt;Integer&amp;gt; generateDemoValuesForY(){
        final Random random = new Random();
        return Stream
                .generate(() -&amp;gt; random.nextInt(100))
                .limit(10)
                .collect(Collectors.toList());
    }

    &lt;/class&gt;&lt;/pre&gt;
But Random offer something new.
&lt;br/&gt;
&lt;pre class="brush: java"&gt;
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; generateDemoValueMatrix() {
        return Stream
                .generate(this::generateDemoValuesForY)
                .limit(ANZAHL_KURVEN)
                .collect(Collectors.toList());
    }
    public List&amp;lt;Integer&amp;gt; generateDemoValuesForY(){
        return new Random()
                .ints(0, 100)
                .limit(10)
                .boxed()
                .collect(Collectors.toList());
    }
    &lt;/class&gt;&lt;/pre&gt;
Combining both methods..
&lt;br/&gt;
&lt;pre class="brush: java"&gt;
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; generateDemoValueMatrix() {
        final Random random = new Random();
        return Stream.generate(
                    () -&amp;gt; Stream.generate(
                            () -&amp;gt; random.nextInt(100))
                            .limit(10)
                            .collect(Collectors.toList())
                )
                .limit(ANZAHL_KURVEN)
                .collect(Collectors.toList());
    }
    &lt;/class&gt;&lt;/pre&gt;
OK, not short enough.. we could it better..
&lt;br/&gt;
&lt;pre class="brush: java"&gt;
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; generateDemoValueMatrix() {
        return Stream.generate(
                () -&amp;gt; new Random()
                        .ints(0, 100)
                        .limit(10)
                        .boxed()
                        .collect(Collectors.toList())
                ).limit(ANZAHL_KURVEN)
                .collect(Collectors.toList());
    }
    &lt;/class&gt;&lt;/pre&gt;
Uuuppsss..  static imports possible.. ;-)
&lt;br/&gt;
&lt;pre class="brush: java"&gt;
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; generateDemoValueMatrix() {
        return generate(() -&amp;gt; new Random()
                .ints(0, 100)
                .limit(10).boxed().collect(toList())
        ).limit(ANZAHL_KURVEN).collect(toList());
    }
    &lt;/class&gt;&lt;/pre&gt;

Now compare with the first  and decide ;-) Streams are cool ? I think so!!

&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>Is your JUnit KnowHow up to date? - Part 1</title>
        <category label="Java"/>
        <category label="JUnit"/>
        <category label="Test"/>
        <published>2014-10-31T00:00:00+01:00</published>
        <author>
            <name>Alexander Bischof</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2014/10/31/is-your-junit-knowhow-up-to-date-part-.html&gt;Is your JUnit KnowHow up to date? - Part 1&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2014-10-31 from &lt;a href="/team/alexander-bischof/"&gt;Alexander Bischof&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
Most of the Java developers know JUnit for many years and probably use it on a daily basis. But like all things
JUnit evolves and so should we. Especially if your test code lacks in view of readability, understandability and clean code
you should have a closer look at some of the newer features of JUnit.
The upcoming blog series starting with this article covering the JUnit basics
will take a close look on the internals, concepts and best practices of JUnit nowadays.&lt;br/&gt;&lt;br/&gt;

JUnit (current version 4.11) itself is a test framework which provides some annotations, interfaces and utility classes
which can be used to write test classes, lifecycle methods and test methods that will ensure the correctness of your business code.
It is widely known and used and plays a big role when it comes to continuous integration and agile projects.&lt;br/&gt;&lt;br/&gt;

&lt;h2&gt;Test classes&lt;/h2&gt;

A test class is just a plain java class and nothing more. In view of JUnit it is managed through a &lt;i&gt;JUnitRunner&lt;/i&gt; which normally provides
a lifecycle.
Like many framework nowadays JUnit follows the CoC (Convention over Configuration)
which basically means that you only have to declare things that are not part of the convention. That way your code keeps small and
therefore is more readable and understandable. Considering JUnit test classes it means that you can provide your own &lt;i&gt;JUnitRunner&lt;/i&gt; but JUnit already
                                               provides a default &lt;i&gt;JUnitRunner&lt;/i&gt; (internally mapped to &lt;i&gt;BlockJUnit4ClassRunner&lt;/i&gt;). This default &lt;i&gt;JUnitRunner&lt;/i&gt; inherits from &lt;i&gt;
                                                ParentRunner&lt;/i&gt; which provides you
                                               a lifecycle which is shown in the following image and will be explained further in this article.
                                               &lt;img src="JUnitLifecycle_simple.png"/&gt;
                                               But keep in mind that this lifecycle represents only the default lifecycle. If you develop your own &lt;i&gt;JUnitRunner&lt;/i&gt; or using other JUnit-Rules it can be something really different.
                                               But those topics i will cover in another blog post.&lt;br/&gt;

&lt;h2&gt;Lifecycle methods&lt;/h2&gt;
A lifecycle method here is a method which is marked with one of the following annotations and can be used to configure your tests.
&lt;table border="1"&gt;
    &lt;tr&gt;
        &lt;th&gt;Annotation&lt;/th&gt;
        &lt;th&gt;Explanation&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;@BeforeClass&lt;/td&gt;
        &lt;td&gt;Static methods (can occur multiple times) to initialize things on the test class level. The order is dependent on the
        underlying JVM&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;@AfterClass&lt;/td&gt;
        &lt;td&gt;Static methods (can occur multiple times) to clean up things on the test class level. The order is dependent on the
                                                                                                         underlying JVM&lt;/td&gt;
    &lt;/tr&gt;
     &lt;tr&gt;
            &lt;td&gt;@Before&lt;/td&gt;
            &lt;td&gt;Non Static methods (can occur multiple times) to initialize things on the test method level. The order is dependent on the
            underlying JVM&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;@After&lt;/td&gt;
            &lt;td&gt;Non Static methods (can occur multiple times) to clean up things on the test method level. The order is dependent on the
            underlying JVM&lt;/td&gt;
        &lt;/tr&gt;
&lt;/table&gt;
As already mentioned above this is just the half truth because since JUnit 4.7 the concept of rules are integrated.&lt;br/&gt;&lt;br/&gt;

One important point: As you can see in the lifecycle diagram above both (the constructor and &lt;i&gt;@Before&lt;/i&gt; annotated methods) are executed before each
test method and therefore seem to have the same semantic (at least
from the test-method point of view). But there are some important differences to keep in mind:
&lt;ul&gt;
    &lt;li&gt;It breaks the symmetry between &lt;i&gt;@Before&lt;/i&gt; and &lt;i&gt;@After&lt;/i&gt;&lt;/li&gt;
    &lt;li&gt;If the constructor throws an exception &lt;i&gt;@After&lt;/i&gt; is not
        executed
    &lt;/li&gt;
    &lt;li&gt;JUnit can be used with several other frameworks (e.g.
        Mockito) which rely on the lifecycle at least partially. Therefor using the
        constructor for initializing can lead for example to &lt;i&gt;NullPointerExceptions&lt;/i&gt;.
    &lt;/li&gt;
&lt;/ul&gt;
Looking at that it is reasonable to say prefer &lt;i&gt;@Before&lt;/i&gt; to the constructor.&lt;br/&gt;

One historical note: The usage of annotations is available since JUnit 4.0. Before that you had to follow a naming convention (e.g. test methods
has to start with "test"). &lt;br/&gt;&lt;br/&gt;

&lt;h2&gt;Test methods&lt;/h2&gt;
A test method for JUnit is a non static, public method which is marked with a &lt;i&gt;@Test&lt;/i&gt; annotation. Such a method should contain so
called assertions and/or assumptions (yes - there are use cases with none of them). The difference between them is that a cause of an assertion leads
to a fail of the test method because an AssertionError is thrown. Indeed an assumption also throws an exception (AssumptionViolatedException) but this one
marks the test just as ignored. So an assumption has more the semantic of a useless test which could be the case if you rely on another system
which is not running or cannot be started.&lt;br/&gt;
The following table shows the basic assertions which are part of the &lt;i&gt;Assert&lt;/i&gt; class.
&lt;table border="1"&gt;
    &lt;tr&gt;
        &lt;th&gt;Assert&lt;/th&gt;
        &lt;th&gt;Explanation&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;assertTrue&lt;/td&gt;
        &lt;td&gt;Checks whether a given condition is true. Fails if condition
            is false. Example: assertTrue("User not signed up",user.isSignUp())
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;assertFalse&lt;/td&gt;
        &lt;td&gt;Opposite of assertTrue&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;assertNull&lt;/td&gt;
        &lt;td&gt;Checks whether a given object is null. Fails if object is
            not null. Example: assertNull(calculator)
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;assertNotNull&lt;/td&gt;
        &lt;td&gt;Opposite of assertNull&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;assertSame&lt;/td&gt;
        &lt;td&gt;Checks whether two objects are reference the same object.
            Fails if not. Example: assertSame("Hallo Welt", "Hallo " + "Welt")
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;assertNotSame&lt;/td&gt;
        &lt;td&gt;Opposite of assertSame. Example: assertNotSame("Hallo Welt",
            new String("Hallo Welt"))
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;assertEquals&lt;/td&gt;
        &lt;td&gt;Checks whether two objects are equal. Example:
            assertEquals("Hallo Welt", new String("Hallo Welt"))
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;assertNotEquals&lt;/td&gt;
        &lt;td&gt;Opposite of assertEquals&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;assertArrayEquals&lt;/td&gt;
        &lt;td&gt;Checks whether two arrays are identical in length and
            elements. Example: assertArrayEquals(new int[]{1,2}, new int[]{1,2})
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;assertThat&lt;/td&gt;
        &lt;td&gt;Makes use of a matcher which describes itself to give
            feedback if it fails. Example: assertThat(new String("Hallo Welt"),
            equalTo("Hallo Welt"))
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;fail&lt;/td&gt;
        &lt;td&gt;Throws an &lt;i&gt;AssertionError&lt;/i&gt; so that the test will fail
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
Also note that every assert method is overloaded with an additional errorMessage
String in front of the parameter list. This is considered best practice because it makes the assertion or assumption more
readable and significant if something goes wrong (FYI: There is also an explicit
                                                                       PMD-Rule &lt;i&gt;JUnitAssertionsShouldIncludeMessage&lt;/i&gt; for that).&lt;br/&gt;&lt;br/&gt;

&lt;table border="1"&gt;
    &lt;tr&gt;
        &lt;th&gt;Assume&lt;/th&gt;
        &lt;th&gt;Explanation&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;assumeTrue&lt;/td&gt;
        &lt;td&gt;Checks whether a given condition is true. Skips test and marks it as ignored if condition
            is false. Example: assumeTrue("User not signed up",user.isSignUp())
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;assumeFalse&lt;/td&gt;
        &lt;td&gt;Opposite of assumeTrue&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;assumeNotNull&lt;/td&gt;
        &lt;td&gt;Checks whether one or many given objects are not null. Skips test and marks it as ignored otherwise. Example: assertNull(calculator)
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;assumeNoException&lt;/td&gt;
        &lt;td&gt;Checks whether a given &lt;i&gt;Throwable&lt;/i&gt; is not thrown. Otherwise test is skipped and marked as ignored.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;assumeThat&lt;/td&gt;
        &lt;td&gt;Makes use of a matcher to check if a condition is true. If not test is skipped and marked as ignored.
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

At this point i left out the following points because they would blow up this article. So stay tuned and read more
in one of the following topics:
&lt;ul&gt;
&lt;li&gt;&lt;i&gt;assertThat&lt;/i&gt; with the big topic &lt;i&gt;Matcher&lt;/i&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Example&lt;/h2&gt;
So far i had only covered theory. Now i am giving a simple example which uses annotations.
The calculator here is specialized for integers but could be easily extended for other numeric types. Our functional methods
would be add, subtract, multiply and divide.

	&lt;pre brush="java"&gt;
public class Calculator {

	public int add(int a, int b) {
		return a + b;
	}

	public int subtract(int a, int b) {
		return a - b;
	}

	public int multiply(int a, int b) {
		return a * b;
	}

	public int divide(int a, int b) {
		return a / b;
	}
}&lt;/pre&gt;
So far nothing special so let us have a look at the test. I created a test method for each public method of the
calculator and used the
&lt;i&gt;@Before&lt;/i&gt; annotated method to initialize the calculator. That way each time before the test method is executed the calculator is newly initialized. The reason for
that is quite simple - i want to eliminate possible side effects in the future (which could occur if i would use &lt;i&gt;@BeforeClass&lt;/i&gt;)
and do not want to violate the DRY (Don't Repeat Yourself) principle (which would occur if i would initialize the calculator in every test
method).
&lt;br/&gt;
	&lt;pre brush="java"&gt;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

import org.junit.Before;
import org.junit.Test;

public class CalculatorSimpleTest {

	Calculator calculator;

	@Before
	public void setUp() throws Exception {
		calculator = new Calculator();
	}

	@Test
	public void testAdd() {
		String errorMessage = "Adding failed";
		int expected = 3;
		int add = calculator.add(1, 2);
		assertEquals(errorMessage, expected, add);

		// Bad assertTrue(3==calculator.add(1, 2));
		// Bad assertSame(3, calculator.add(1, 2));
	}

	@Test
	public void testSubtract() {
		String errorMessage = "Subtracting failed";
		int expected = -1;
		int add = calculator.subtract(1, 2);
		assertEquals(errorMessage, expected, add);
	}

	@Test
	public void testMultiply() {
		String errorMessage = "Multiplying failed";
		int expected = 2;
		int add = calculator.multiply(1, 2);
		assertEquals(errorMessage, expected, add);
	}

	@Test
	public void testDivide() {
		String errorMessage = "Dividing failed";
		int expected = 0;
		int add = calculator.divide(1, 2);
		assertEquals(errorMessage, expected, add);
	}
}
&lt;/pre&gt;
As you can see every test method checks an expected value against an
actual computation result. If there is a mismatch an assertion error is
thrown. &lt;br/&gt;
If something went wrong (here i changed the expected result of the multiply method) you can see corresponding error message.
&lt;br/&gt;
&lt;img src="message.png"/&gt;

&lt;h2&gt;ExceptionHandling&lt;/h2&gt;
Now you are able to develop standard tests and in many cases this
should be sufficient (for the moment :)). But in view of testing
exceptions your test classes can suffer really fast. Considering the
calculator you can see easily that at least the divide method needs one
more test.
	&lt;pre brush="java"&gt;
	@Test
	public void testDivide_WithZero_WillFail() {
		assertEquals(0, calculator.divide(1, 0));
	}
	&lt;/pre&gt;
This test will fail because an
&lt;i&gt;ArithmeticException&lt;/i&gt; is thrown. But lets assume that this
behavior (throwing the exception) is correct because i want the
client handle the exception. So with a naive small refactoring i can get
this.

	&lt;pre brush="java"&gt;
	@Test
	public void testDivide_WithZero_WillFail() {
		try {
			assertEquals(0, calculator.divide(1, 0));
			fail();
		} catch (ArithmeticException e) {
			// Bad
		}
	}
	&lt;/pre&gt;
Ok, now i have tested the correct behavior but the resulting test code
does not look good. I have boiler-plate code and doubled the size of my previous test code therefore it is less
understandable. A better way to do that is using the
&lt;i&gt;@Test&lt;/i&gt; annotation the following way.
	&lt;pre brush="java"&gt;
	@Test(expected = ArithmeticException.class)
	public void testDivide_WithZero_WillFail() {
		assertEquals(0, calculator.divide(1, 0));
	}
	&lt;/pre&gt;
This test method only fails if the
&lt;i&gt;ArithmeticException&lt;/i&gt; is not thrown.&lt;br/&gt;&lt;br/&gt;

So this is what i consider as the JUnit basics but there will be more in the upcoming articles.&lt;br/&gt;
Have fun coding.
&lt;/div&gt;</content>
        <summary></summary>
    </entry>
    <entry>
        <title>Is your JUnit KnowHow up to date? - Part 1 Quiz</title>
        <category label="Java"/>
        <category label="JUnit"/>
        <category label="Test"/>
        <category label="Quiz"/>
        <published>2014-11-04T00:00:00+01:00</published>
        <author>
            <name>Alexander Bischof</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2014/11/04/is-your-junit-knowhow-up-to-date-part-.html&gt;Is your JUnit KnowHow up to date? - Part 1 Quiz&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2014-11-04 from &lt;a href="/team/alexander-bischof/"&gt;Alexander Bischof&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
This short review quiz is related to the previous article &lt;a href="http://www.rapidpm.org/2014/10/31/is-your-junit-knowhow-up-to-date-part-.html"&gt;here&lt;/a&gt;.
&lt;/p&gt;

&lt;b&gt;1.&lt;/b&gt; What JUnit version introduced annotations for handling the simple lifecycle?&lt;br/&gt;
    &lt;ul&gt;
    &lt;li&gt;since 1.0&lt;/li&gt;
    &lt;li&gt;since 3.6&lt;/li&gt;
    &lt;li&gt;since 4.0&lt;/li&gt;
    &lt;li&gt;since 4.7&lt;/li&gt;&lt;/ul&gt;

&lt;b&gt;3.&lt;/b&gt; Why should you prefer &lt;i&gt;@Before&lt;/i&gt; annotated methods in comparison to the constructor? Because&lt;br/&gt;
   &lt;ul&gt; &lt;li&gt;it does not break the symmetry of the lifecycle&lt;/li&gt;
    &lt;li&gt;&lt;i&gt;@Before&lt;/i&gt; should not be preferred&lt;/li&gt;
    &lt;li&gt;&lt;i&gt;@Before&lt;/i&gt; methods handle exceptions while constructors not&lt;/li&gt;
    &lt;li&gt;other frameworks rely on that&lt;/li&gt;
    &lt;/ul&gt;
&lt;b&gt;4.&lt;/b&gt; Can you use more than one &lt;i&gt;@Before&lt;/i&gt; annotated method in a test class?&lt;br/&gt;
   &lt;ul&gt; &lt;li&gt;yes&lt;/li&gt;
    &lt;li&gt;no&lt;/li&gt;&lt;/ul&gt;

&lt;b&gt;5.&lt;/b&gt; Which method qualifiers must be used for a &lt;i&gt;@AfterClass&lt;/i&gt; method?&lt;br/&gt;
   &lt;ul&gt; &lt;li&gt;protected&lt;/li&gt;
    &lt;li&gt;static&lt;/li&gt;
    &lt;li&gt;public&lt;/li&gt;
    &lt;li&gt;final&lt;/li&gt;&lt;/ul&gt;

&lt;b&gt;6.&lt;/b&gt; What happens if a public method is annotated with &lt;i&gt;@Before&lt;/i&gt;, &lt;i&gt;@Test&lt;/i&gt; and &lt;i&gt;@After&lt;/i&gt;?&lt;br/&gt;
    &lt;ul&gt;&lt;li&gt;Runtime-/ValidationError&lt;/li&gt;
    &lt;li&gt;CompilerError&lt;/li&gt;
    &lt;li&gt;Runs fine&lt;/li&gt;&lt;/ul&gt;

&lt;b&gt;7.&lt;/b&gt; What is the simplest way (considering clean code) to handle exceptions?&lt;br/&gt;
    &lt;ul&gt;&lt;li&gt;use try/catch&lt;/li&gt;
    &lt;li&gt;use @Test(expected=....class)&lt;/li&gt;
    &lt;li&gt;it is integrated in JUnit&lt;/li&gt;&lt;/ul&gt;
&lt;b&gt;8.&lt;/b&gt; What is the result of the following code?

&lt;pre brush="java"&gt;
public class LifecycleTest {

    @Before
    public void before() {
        System.out.print("3");
    }

    public LifecycleTest() {
        System.out.print("2");
    }

    @BeforeClass
    public static void beforeClass() {
        System.out.print("1");
    }

    @Test
    public void test() {
        System.out.print("4");
    }

    @Test
    public void test2(){
        System.out.print("5");
    }

    @After
    public void after() {
        System.out.print("6");
    }
}
&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;RuntimeException&lt;/li&gt;
&lt;li&gt;123456&lt;/li&gt;
&lt;li&gt;123462356&lt;/li&gt;
&lt;li&gt;Not predictable, depends on JVM&lt;/li&gt;
&lt;/ul&gt;

The solutions can be found here in white color: &lt;font color="white"&gt;1c; 2acd; 3a; 4bc; 5c; 6b; 7d; &lt;/font&gt;
&lt;/div&gt;</content>
        <summary></summary>
    </entry>
    <entry>
        <title>Is your JUnit KnowHow up to date? - Part 2</title>
        <category label="Java"/>
        <category label="JUnit"/>
        <category label="Test"/>
        <published>2014-11-24T00:00:00+01:00</published>
        <author>
            <name>Alexander Bischof</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2014/11/24/is-your-junit-knowhow-up-to-date-part-.html&gt;Is your JUnit KnowHow up to date? - Part 2&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2014-11-24 from &lt;a href="/team/alexander-bischof/"&gt;Alexander Bischof&lt;/a&gt;&lt;/p&gt;
This time i want to cover the topic of aggregating JUnit tests
 which is also part of my blog series &lt;i&gt;Is your JUnit knowhow up to date?&lt;/i&gt; The last article can be found
 &lt;a href="http://www.rapidpm.org/2014/10/31/is-your-junit-knowhow-up-to-date-part-.html"&gt;here&lt;/a&gt;. So let us get started.

&lt;h3&gt;Suites&lt;/h3&gt;

A JUnit &lt;i&gt;Suite&lt;/i&gt; is the simplest and oldest way to aggregate JUnit tests. You can use it by annotating your test suite
with &lt;i&gt;@Suite&lt;/i&gt; as you can see in the following code snippet:&lt;br/&gt;

&lt;pre class="brush: java"&gt;
@RunWith(Suite.class)
@Suite.SuiteClasses({CalculatorSimpleTest.class, CalculatorPerformanceTest.class})
public class CalculatorSuite {
}
&lt;/pre&gt;
Basically you tell JUnit to look out for the class array of the &lt;i&gt;@Suite.SuiteClasses&lt;/i&gt; which contains all the classes of
 the suite. But there is a little bit more. &lt;i&gt;Suite&lt;/i&gt; itself inherits from &lt;i&gt;ParentRunner&lt;/i&gt; which i covered in the last
 &lt;a href="http://www.rapidpm.org/2014/10/31/is-your-junit-knowhow-up-to-date-part-.html"&gt;article&lt;/a&gt;.
Therefore &lt;i&gt;Suites&lt;/i&gt; have a lifecycle but in comparison to the default runner only include the &lt;i&gt;Class Ready&lt;/i&gt; lifecycle methods
which are:&lt;br/&gt;
&lt;ul&gt;
&lt;li&gt;&lt;i&gt;@BeforeClass&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;&lt;i&gt;@AfterClass&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;&lt;i&gt;Class Rules (i have not covered it yet)&lt;/i&gt;&lt;/li&gt;
&lt;/ul&gt;
But although it is technically possible to used them it does not mean that it is good. In general a suite class should only act as an
aggregation container. One reason for that is that suite classes can be listed in suites and categories itself so that you can build up
hierarchical test structures. If you now use lifecycle methods in your suites you probably decrease understandability and your isolation
between your suites.&lt;br/&gt;&lt;br/&gt;

I also took a deep look at the &lt;i&gt;Suite.SuiteClasses&lt;/i&gt; annotation which i considered at first as a bad solution to the problem of aggregating test classes
and suites. The reason for that was the declarative nature of it which means that you have to declare every single class or suite. Even with IDE support nowadays this
could lead to some work if you have many classes. Considering bug fixes or enhancements of a system there is also the problem that those new tests maybe do not make
it in the test suites and therefore could lead to bad reports about the health or quality of the aggregation part.&lt;br/&gt;
On the second look i changed my mind. The first reason for that was that there are already some libraries with whom you can overcome the declarative nature problem. The
two most promising ones should be:&lt;br/&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://johanneslink.net/projects/cpsuite.jsp"&gt;ClasspathSuite&lt;/a&gt; - As the name suggests this library extends the suite idea for classpaths.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://code.google.com/p/junit-toolbox/"&gt;JUnit Toolbox&lt;/a&gt; - A JUnit extension library which provides among other things
a WildcardPatternSuite which extends the suite idea for wildcards.&lt;/li&gt;
&lt;/ul&gt;
The second reason came after thinking about when aggregate tests anyway which i would do for the following topics:&lt;br/&gt;
&lt;ul&gt;
&lt;li&gt;by domain or package&lt;/li&gt;
&lt;li&gt;by test stage (for example component, integration or performance tests)&lt;/li&gt;
&lt;/ul&gt;
There are probably more topics by which you can aggregate your tests. The point is that in such cases you explicitly want to declare which tests are in that suite and which
are not. &lt;br/&gt;&lt;br/&gt;

FYI: In the old days of JUnit 3 &lt;i&gt;suites&lt;/i&gt; were recognized by a &lt;i&gt;public static Test suite()&lt;/i&gt; method in which you had to add the test classes.
&lt;br/&gt;&lt;br/&gt;

&lt;h3&gt;Categories&lt;/h3&gt;

A more flexible way to aggregate tests are &lt;i&gt;Categories&lt;/i&gt; which were introduced with JUnit 4.8 and strangely enough are still in the experimental package.
The basic concept is similar to suites which means that there is a &lt;i&gt;Categories&lt;/i&gt; class which is a JUnit runner (in detail inherits from &lt;i&gt;Suite&lt;/i&gt;) and has to be declared with &lt;i&gt;@RunWith(Categories.class)&lt;/i&gt;
on top of your aggregation container. You also have to declare your test classes with &lt;i&gt;@Suite.SuiteClasses&lt;/i&gt;.&lt;br/&gt; The new part is that you can mark your test classes and/or test methods
with &lt;i&gt;@Category&lt;/i&gt; and a marker class which is used as a filter in your test aggregation container. For that there are two more annotations &lt;i&gt;@Categories.IncludeCategory&lt;/i&gt;
and &lt;i&gt;@Categories.ExcludeCategory&lt;/i&gt; which take a category filter class (the default behavior, without any include or exclude, includes all test methods).
The only limitation i found so far is that you can use only one category marker class on the test aggregation container and that you can not
repeat those annotations.&lt;br/&gt;
An example of an aggregate container would be look like this:&lt;br/&gt;

&lt;pre class="brush: java"&gt;
@RunWith(Categories.class)
@Categories.IncludeCategory(SlowTests.class)
@Suite.SuiteClasses( { CalculatorSimpleTest.class, CalculatorPerformanceTest.class})
public class OnlySlowTestSuite {}

public interface SlowTests{}
&lt;/pre&gt;

In this example i had declared a category suite which uses the test classes &lt;i&gt;CalculatorSimpleTest&lt;/i&gt; and &lt;i&gt;CalculatorPerformanceTest&lt;/i&gt; and include from that
classes only the test methods which are annotated with &lt;i&gt;@Category(SlowTests.class)&lt;/i&gt;. A &lt;i&gt;@Category&lt;/i&gt; annotation can be used on class and/or on method level and
expects an array of classes. In general it is recommended to use only one class because otherwise it could be really difficult
to understand your suite filters considering including and excluding.
&lt;br/&gt;
In the example above i declare the &lt;i&gt;SlowTests&lt;/i&gt; category class marker.

&lt;pre class="brush: java"&gt;
public class CalculatorSimpleTest {

    //snip..

    @Category(SlowTests.class)
    @Test
    public void testSubstract() {
        for (int i = 0; i &lt; 10000; i++) {
            try {Thread.sleep(10l);} catch (InterruptedException e) {
                e.printStackTrace();
            }

            String errorMessage = "Substracting failed";
            int expected = 1;
            int add = calculator.substract(i + 1, i);
            assertEquals(errorMessage, expected, add);
        }
    }
}
&lt;/pre&gt;

If you want to skip all slowtests you would exchange &lt;i&gt;IncludeCategory&lt;/i&gt;
with &lt;i&gt;ExcludeCategory&lt;/i&gt;.&lt;br/&gt;&lt;br/&gt;
At the time of writing this article JUnit 4.12 beta3 is released which already denotes a little change in the lifecycle handling
considering categories. Until now it was possible to use &lt;i&gt;@Category&lt;/i&gt; on lifecycle methods like &lt;i&gt;@Before&lt;/i&gt; which made
those tests very hard to understand. Therefore JUnit introduced a validation handling which prohibits this usage.&lt;br/&gt;&lt;br/&gt;




&lt;/div&gt;</content>
        <summary></summary>
    </entry>
    <entry>
        <title>Introducing TinkerForge-Fluent</title>
        <category label="Java"/>
        <category label="Tinkerforge"/>
        <category label="IOT"/>
        <category label="Fluent"/>
        <published>2014-12-19T00:00:00+01:00</published>
        <author>
            <name>Alexander Bischof</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2014/12/19/introducing-tinkerforge-fluent.html&gt;Introducing TinkerForge-Fluent&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2014-12-19 from &lt;a href="/team/alexander-bischof/"&gt;Alexander Bischof&lt;/a&gt;&lt;/p&gt;
Having engaged myself in contributing to &lt;a href="http://joel-costigliola.github.io/assertj/"&gt;AssertJ&lt;/a&gt; i stumbled over the idea of making
the Tinkerforge API more fluent. So this short article represents a first approach of a fluent Java-Tinkerforge API which
uses all the advantages of &lt;a href="http://de.wikipedia.org/wiki/Fluent_Interface"&gt;fluent interfaces&lt;/a&gt;.
&lt;br/&gt;&lt;br/&gt;

Consider the following example which connects to a temperature, an ambientlight, a barometer and a humdity sensor and prints all changes
 on the &lt;i&gt;System.out&lt;/i&gt;.
&lt;pre class="brush: java"&gt;
IPConnection ipcon = new IPConnection();
BrickletTemperature brickletTemperature = new BrickletTemperature("dXj", ipcon);
BrickletAmbientLight brickletAmbientLight = new BrickletAmbientLight("jy2", ipcon);
BrickletBarometer brickletBarometer = new BrickletBarometer("jY4", ipcon);
BrickletHumidity brickletHumidity = new BrickletHumidity("kfd", ipcon);

ipcon.connect("localhost", 4223);

brickletTemperature.setTemperatureCallbackPeriod(100);
brickletTemperature.addTemperatureListener(temperature -&gt; System.out.println("temperature: " + temperature));

brickletAmbientLight.setIlluminanceCallbackPeriod(100);
brickletAmbientLight.addIlluminanceListener(ambientLight -&gt; System.out.println("ambientLight: " + ambientLight));

brickletBarometer.setAirPressureCallbackPeriod(100);
brickletBarometer.addAirPressureListener(airpressure -&gt; System.out.println("airpressure: " + airpressure));

brickletHumidity.setHumidityCallbackPeriod(100);
brickletHumidity.addHumidityListener(humidity -&gt; System.out.println("humidity: " + humidity));

System.out.println("Press key to exit");
System.in.read();
ipcon.disconnect();
&lt;/pre&gt;

And now look at this one: ;)
&lt;pre class="brush: java"&gt;
IPConnection ipcon = Tinkerforges.connectTo("localhost")
 .withSensor(temperature("dXj").temperaturListener(e -&gt; System.out.println("temperature: " + e)))
 .withSensor(ambientLight("jy2").illuminanceListener(e -&gt; System.out.println("ambientLight: " + e)))
 .withSensor(barometer("jY4").airPressureListener(e -&gt; System.out.println("airpressure: " + e)))
 .withSensor(humidity("kfd").humidityListener(e -&gt; System.out.println("humidity: " + e)))
 .build();

 System.out.println("Press key to exit");
 System.in.read();
 ipcon.disconnect();
&lt;/pre&gt;

You are probably miss the port and callbackperiod which i have defaulted (ala configuration over convention) with reasonable values.
 With that you have to write less repititve code which makes the code more compact and therefore more readable.
&lt;br/&gt;&lt;br/&gt;
The snippet itself could be compacted more with the use of &lt;i&gt;java.lang.Closable&lt;/i&gt; on the internal &lt;i&gt;IPConnectionBase&lt;/i&gt; class. Unfortunately
the tinkerforge source is still on JDK5.
&lt;br/&gt;&lt;br/&gt;
Have a look at my &lt;a href="https://github.com/AlexBischof/Tinkerforge-Fluent.git"&gt;repository&lt;/a&gt; and feel free to contribute.
Currently it only contains the bricklets mentioned above.

&lt;/div&gt;</content>
        <summary></summary>
    </entry>
    <entry>
        <title>Started with Upsource Server for OS projects</title>
        <category label="Java"/>
        <category label="Upsource"/>
        <category label="Jetbrains"/>
        <category label="Github"/>
        <category label="bitbucket"/>
        <published>2015-01-03T00:00:00+01:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2015/01/03/started-with-upsource-server-for-os-pr.html&gt;Started with Upsource Server for OS projects&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2015-01-03 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
We started with an &lt;a href="https://www.jetbrains.com/upsource/"&gt;UPSOURCE&lt;/a&gt; Server for OpenSource projects.
Upsource is a very nice repository browser and code review tool from jetbrains. You can access our upsource installation
under &lt;a
        href="http://upsource.rapidpm.org:8866/"&gt;http://upsource.rapidpm.org:8866&lt;/a&gt;. We started with a few projects like
&lt;br/&gt;
&lt;ul&gt;
    &lt;li&gt;adambien-afterburner.fx - Last updated by Adam Bien on Nov 21, 2014&lt;/li&gt;
    &lt;li&gt;birdasaur - FXyz Last updated by jperedadnr 14 hours ago&lt;/li&gt;
    &lt;li&gt;boonproject - boon Last updated by Richard Hightower on Dec 15, 2014&lt;/li&gt;
    &lt;li&gt;callmeal - Flickr4Java Last updated by boncey on Nov 9, 2014&lt;/li&gt;
    &lt;li&gt;google - guava Last updated by clm 4 days ago&lt;/li&gt;
    &lt;li&gt;hazelcast - hazelcast Last updated by David Strom 3 days ago&lt;/li&gt;
    &lt;li&gt;hazelcast - hazelcast-code-samples Last updated by Mesut Celik 10 days ago&lt;/li&gt;
    &lt;li&gt;hivemq-hivemq-spi Last updated by Dominik Obermaier on Dec 16, 2014&lt;/li&gt;
    &lt;li&gt;jankotek - MapDB Last updated by Jan Kotek 9 days ago&lt;/li&gt;
    &lt;li&gt;orientechnologies - orientdb Last updated by tglman 20 hours ago&lt;/li&gt;
    &lt;li&gt;ronmamo - reflections Last updated by ronmamo on Nov 11, 2014&lt;/li&gt;
    &lt;li&gt;square - dagger Last updated by Jake Wharton on Dec 20, 2014&lt;/li&gt;
    &lt;li&gt;square - javawriter Last updated by Jake Wharton 5 days ago&lt;/li&gt;
    &lt;li&gt;TestFX - TestFX Last updated by Benjamin Gudehus on Dec 3, 2014&lt;/li&gt;
    &lt;li&gt;tinkerforge - generators Last updated by Olaf Lüke a day ago&lt;/li&gt;
    &lt;li&gt;TomasMikula - ReactFX Last updated by Tomas Mikula 2 days ago&lt;/li&gt;
    &lt;li&gt;weld - core Last updated by otaviojava on Dec 18, 2014&lt;/li&gt;
    &lt;li&gt;weld - wildfly Last updated by Jozef Hartinger on Jun 18, 2014&lt;/li&gt;
&lt;/ul&gt;
If you want to see more projects there..  let me know. I will ben happy to add it.

enjoy upsource.. ;-)






&lt;/div&gt;</content>
        <summary></summary>
    </entry>
    <entry>
        <title>Tinkerforge: Automatic Bricklet Setup</title>
        <category label="Java"/>
        <category label="IOT"/>
        <category label="Tinkerforge"/>
        <published>2015-01-29T00:00:00+01:00</published>
        <author>
            <name>Alexander Bischof</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2015/01/29/tinkerforge--automatic-bricklet-setup.html&gt;Tinkerforge: Automatic Bricklet Setup&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2015-01-29 from &lt;a href="/team/alexander-bischof/"&gt;Alexander Bischof&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
In the last couple of month i had several times small TinkerForge systems with different bricklet configurations which were programmed in Java.
And in order to work with them i always had to do the „BrickViewer-Find-UID-Dance“ which at some point really annoyed me.
&lt;/p&gt;

&lt;p&gt;
The problem of a changing setup will also occur if you have a broken bricklet and replace it with a new one.
You may say „Ok, that is prototyping“. But the idea behind TinkerForge is to write your prototype and if your are ready transfer
it to new hardware for production without any change. It is basically the same in Java „Write once, run everywhere“ and that is currently not the case.
This problem has also influence of your application design where you at one point outsource your bricklet uids into
a property file so that you can easily reconfigure it if something has changed. But from my point of view that should not be
 necessary and it should be possible to do that automatically.
&lt;/p&gt;

&lt;p&gt;
In order to do that i had taken a quick look at the TinkerForge-API where i found that every bricklet class (FYI: extends &lt;i&gt;Device&lt;/i&gt;)
has a &lt;i&gt;public static final int field DEVICE_INDENTIFIER&lt;/i&gt;. As the name suggests this is the identifier of the
 device which is not needed to be used by programmers. But in this case and also in case of &lt;a href="http://www.rapidpm.org/2014/05/12/mocking-iot-tinkerforge-sensors.html"&gt;Mocking Devices&lt;/a&gt;
 we can make an exception. So why is this important?&lt;br/&gt;
The point is that the IPConnection class has an enumeration listener which is triggered by every bricklet connected to the IPConnection when &lt;i&gt;IpConnection.enumerate()&lt;/i&gt; is called. And with that we can discover which bricklet-uid-combination is connected.
&lt;/p&gt;

&lt;p&gt;
So the idea is very simple:
(1) Create a simple lookup table of device identifier to bricklet classes so that you can use the (2) enumeration listener
 to look up the connected bricklet class. In order to do the first step i am using the Guava library reflections because it is
 currently not possible with plain Java to find all subclasses via the reflection API. In the example above i also introduced a small
 helper map so that in the end an application can really benefit of it. Especially if you are using more bricklets of the same
 type.
&lt;/p&gt;

&lt;pre class="brush: java"&gt;
public class BrickletReader {
  public static void main(String[] args) throws Exception {

    // (1) Find all Subclasses of Device
    Reflections reflections = new Reflections("com.tinkerforge");
    Set&amp;lt;Class&amp;lt;? extends Device&amp;gt;&amp;gt; subTypesOf = reflections.getSubTypesOf(Device.class);

    //Read all DeviceIdentifier into Map&amp;lt;Identifier, Class&amp;gt;
    final Map&amp;lt;Integer, Class&amp;lt;? extends Device&amp;gt;&amp;gt; allDeviceIdentifierMapping = new HashMap&amp;lt;&amp;gt;();
    for (Class&amp;lt;? extends Device&amp;gt; deviceClass : subTypesOf) {
      try {
    	Field deviceIdentifier = deviceClass.getDeclaredField("DEVICE_IDENTIFIER");
    	allDeviceIdentifierMapping.put(deviceIdentifier.getInt(null), deviceClass);
      } catch (IllegalAccessException | NoSuchFieldException e) {}  //Ignore
    }

    //Application bricklet class to uid map
    final BrickletUidMap brickletUidMap = new BrickletUidMap();

    // (2) Lookup connected bricklets with an EnumerateListener
    IPConnection ipConnection = new IPConnection();
    ipConnection.connect("localhost", 4223);
    ipConnection.addEnumerateListener(
    		(uid, connectedUid, position, hardwareVersion, firmwareVersion, deviceIdentifier, enumerationType) -&amp;gt; {
    		  if (enumerationType == IPConnection.ENUMERATION_TYPE_DISCONNECTED) {
    			return;
    		  }

    		  //Add class uid combination to map
    		  Class&amp;lt;? extends Device&amp;gt; aClass = allDeviceIdentifierMapping
    				  .get(deviceIdentifier);
    		  brickletUidMap.put(aClass, uid);
    		}
    );

    ipConnection.enumerate();

    //Example: 2 temperature and one ambientlight bricklets
    BrickletTemperature temperature1 = new BrickletTemperature(brickletUidMap.getBrickletUid(BrickletTemperature.class), ipConnection);
    BrickletTemperature temperature2 = new BrickletTemperature(brickletUidMap.getBrickletUid(BrickletTemperature.class), ipConnection);
    BrickletAmbientLight ambientLight = new BrickletAmbientLight(brickletUidMap.getBrickletUid(BrickletAmbientLight.class), ipConnection);
  }
}
&lt;/pre&gt;

&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;With the code above you can achieve now several things:
&lt;ul&gt;
&lt;li&gt;Improve coding time (and in terms of clean code DRY)&lt;/li&gt;
&lt;li&gt;Improve your application robustness (Write once, run everywhere)&lt;/li&gt;
&lt;li&gt;No more manually setup of bricklets uids&lt;/li&gt;
&lt;/ul&gt;

You can find the code &lt;a href="https://github.com/AlexBischof/Tinkerforge-BrickletReader.git"&gt;here&lt;/a&gt;
&lt;/p&gt;






&lt;/div&gt;</content>
        <summary></summary>
    </entry>
    <entry>
        <title>EJB Transaction Rollback and Timers</title>
        <category label="Java"/>
        <category label="JavaEE"/>
        <category label="EJB"/>
        <category label="Glassfish"/>
        <published>2015-02-08T00:00:00+01:00</published>
        <author>
            <name>Oliver Milke</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2015/02/08/ejb-transaction-rollback-and-timers.html&gt;EJB Transaction Rollback and Timers&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2015-02-08 from &lt;a href="/team/oliver-milke/"&gt;Oliver Milke&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
    &lt;!-- first paragraph is bla bla --&gt;
&lt;p&gt;Today I was a little confused when a colleague of mine tried to explain to me the transaction control directives our application depends on. The tough part was to consider all the
    possible rollback scenarios. To get more insight into rollback behaviour, I created a simple demo project.&lt;/p&gt;
&lt;p&gt;The project can be found on &lt;a href="https://github.com/omilke/ta-demo"&gt;github&lt;/a&gt;. It demonstrates all possible cases I could think of with respect to transaction rollback
    and programmatic timer manipulation. I have added TODO markers in places you choose between different scenarios. I also added a comment on what is expected to happen and why.
&lt;p&gt;It works with glassfish 3.2 and 4.1. Feel free to try it out and please share your thoughts. Please keep in mind, however, this project
    was primarily designed to run on both versions of glassfish.&lt;/p&gt;
&lt;p&gt;The specification (JSR-318 - EJB 3.1) can found at the &lt;a href="https://jcp.org/aboutJava/communityprocess/final/jsr318/index.html"&gt;JCP site&lt;/a&gt;. I added
    references to specification, which relate to this document.&lt;/p&gt;

&lt;h2&gt;EJB Transaction Rollback - When does it happen?&lt;/h2&gt;
&lt;p&gt;My primitive assumption was, that if the method that spans a transaction (e. g. by declaring &lt;code&gt;TransactionAttribute.REQUIRES_NEW&lt;/code&gt;) terminates with an exception,
    the associated transaction must be rolled back. However, this is not necessarily true.&lt;/p&gt;
&lt;p&gt;Actually it depends on the type of the exception. Transactions only rollback if the exception being thrown is marked for rollback (cf. chapter 14.3.1, Table 15).&lt;/p&gt;
&lt;p&gt;By the default, all checked exceptions are marked as &lt;code&gt;rollback=false&lt;/code&gt;, whereas the unchecked exception are marked as &lt;code&gt;rollback=true&lt;/code&gt;.
    You can explicitly specify rollback behaviour on exceptions with &lt;code&gt;@ApplicationException(rollback = true / false)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If you have an EJB that uses another EJB injected via @EJB / @Inject and the invoked method executes of the same transaction (e. g. because of
    &lt;code&gt;TransactionAttribut.REQUIRED)&lt;/code&gt;, this method can also induce a rollback of the transaction if it throws an appropriate exception.&lt;/p&gt;
&lt;p&gt;This means a business method may throw an exception and have the transaction committed at the same time. Conversely, by using another EJB a transaction can be
    rolled back even if you catch its exception. Both of these cases are shown in the demo project.&lt;/p&gt;

&lt;h2&gt;EJB Transaction Rollback and timers&lt;/h2&gt;

&lt;p&gt;Transaction rollback also influences timeout methods (i. e. methods annotated with &lt;code&gt;@Schedule&lt;/code&gt; / &lt;code&gt;@Timeout&lt;/code&gt;). If the transaction used for a timeout method shall
    be rolled back, it is required by the specification, that the method invocation will be retried at least once (cf. chapter 18.4.3). Glassfish retries the invocation 5 seconds later. However,
    if the second invocation induces a rollback as well, the timer will be expunged. That means you will loose all future invocation of that timer.&lt;/p&gt;
&lt;p&gt;The specification actually disallows timeout methods to throw application exceptions (cf. chapter 18.2.5.3), however glassfish can cope with that. Timeout method invocation is retried if either
    the method throws an exception or the associated transaction is marked for rollback. A timeout method can also have a committed transaction even though it throws an exception.
    However, since this is not allowed by the spec, its behaviour is specific to the application server in use.&lt;/p&gt;
&lt;p&gt;For glassfish, retrying timeouts and expunging timer can be configured in the admin interface (&lt;a href="http://www.rapidpm.org/2015/02/08/timerconfig.png"&gt;screenshot&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Programmatic manipulations of timers with the help of &lt;code&gt;@Resource TimerService&lt;/code&gt; are also subject to transaction rollback (cf. chapter 18.2.8). Therefore registering a new
    &lt;code&gt;@Timeout&lt;/code&gt; or cancelling and an existing &lt;code&gt;Timer&lt;/code&gt; will also be reverted of the corresponding transaction is rolled back.&lt;/p&gt;
&lt;/div&gt;</content>
        <summary></summary>
    </entry>
    <entry>
        <title>Is your JUnit KnowHow up to date? - Part 3</title>
        <category label="Java"/>
        <category label="JUnit"/>
        <category label="Test"/>
        <published>2015-04-26T00:00:00+02:00</published>
        <author>
            <name>Alexander Bischof</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2015/04/26/is-your-junit-knowhow-up-to-date-part-.html&gt;Is your JUnit KnowHow up to date? - Part 3&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2015-04-26 from &lt;a href="/team/alexander-bischof/"&gt;Alexander Bischof&lt;/a&gt;&lt;/p&gt;
This time i want to cover the topic of parameterizing JUnit tests with the &lt;i&gt;Parameterized&lt;/i&gt; runner
 which is also part of my blog series &lt;i&gt;Is your JUnit knowhow up to date?&lt;/i&gt; The last article can be found
 &lt;a href="http://www.rapidpm.org/2014/11/24/is-your-junit-knowhow-up-to-date-part-.html"&gt;here&lt;/a&gt;. So let us get started.
&lt;br/&gt;&lt;br/&gt;

For this article assume that we have a simple calculator which looks as follows:
&lt;pre class="brush: java"&gt;
public class Calculator {
    public static int add(int x, int y) {
        return x + y;
    }
}
&lt;/pre&gt;
and want to test the add method with several different combinations of parameters. A naive solution could look like this:

&lt;pre class="brush: java"&gt;
    import org.junit.Test;

    import static de.bischinger.junit.parameterized.Calculator.add;
    import static org.assertj.core.api.Assertions.assertThat;

    public class NaiveBadCalculatorAddTest {

        @Test
        public void should_pass() {

            //Test parameters 1
            int x = 1;
            int y = 2;
            assertThat(add(x, y)).isEqualTo(3);

            //Test parameters 2
            x = -1;
            y = -2;
            assertThat(add(x, y)).isEqualTo(-3);

            //Test parameters 3
            x = Integer.MAX_VALUE;
            y = Integer.MAX_VALUE;
            assertThat(add(x, y)).isEqualTo(-2);

            //Test parameters 4
            Integer boxedX = Integer.valueOf(1);
            Integer boxedY = Integer.valueOf(2);
            assertThat(add(boxedX, boxedY)).isEqualTo(3);
        }
    }
&lt;/pre&gt;
&lt;br/&gt;
To be honest...it works. But it lacks in two aspects:
&lt;ul&gt;
&lt;li&gt;Test isolation - which means your test method tests several different assumptions which are not separated from each other (here for example positive and negative addition as simple corner cases).
That way tests are harder to understand directly in the code and also in the reports if something went wrong.&lt;/li&gt;
&lt;li&gt;Clean code - the code itself is very declarative and grows badly with every new assumption you want to test.&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;
Maybe at one point you noticed that the code could be optimized if you extract your input parameters and expected results into an array. A possible solution could look like this:
&lt;pre class="brush: java"&gt;
    public class OptimizedNaivBadCalculatorAddTest {

        @Test
        public void should_pass() {

            int[][] parameters = new int[][] { { 1, 2, 3 }, { -1, -2, -3 }, { Integer.MAX_VALUE, Integer.MAX_VALUE, -2 },
                { Integer.valueOf(1), Integer.valueOf(2), 3 } };

            for (int[] parameter : parameters) {
                assertThat(Calculator.add(parameter[0], parameter[1])).isEqualTo(parameter[2]);
            }
        }
    }
&lt;/pre&gt;
Now the code is more compact and readable and everything should be fine. But wait...what if you want to do that in another test case? Do you copy that construct
into every test case? And what do you do if you have to do some stuff in &lt;i&gt;@Before&lt;/i&gt; or &lt;i&gt;@After&lt;/i&gt; with the parameters?&lt;br/&gt;
&lt;br/&gt;
This is the point where JUnit provides the concept of the &lt;i&gt;Parameterized&lt;/i&gt; runner. In fact the transposition from the code above is not that far away if you look at the following code
&lt;pre class="brush: java"&gt;
@RunWith(Parameterized.class)
public class NaivParameterizedCalculatorAddTest {

    @Parameters
    public static Iterable&lt;Object[]&gt; data() {
        return Arrays.asList(new Object[][] { { 1, 2, 3 }, { -1, -2, -3 }, { Integer.MAX_VALUE, Integer.MAX_VALUE, -2 },
            { Integer.valueOf(1), Integer.valueOf(2), 3 } });
    }

    private int x;
    private int y;
    private int expected;

    public NaivParameterizedCalculatorAddTest(int x, int y, int expected) {
        this.x = x;
        this.y = y;
        this.expected = expected;
    }

    @Test
    public void should_pass() {
        assertThat(Calculator.add(x,y)).isEqualTo(expected);
    }
}
&lt;/pre&gt;
As you can see the following changes have to be done:
&lt;ul&gt;
    &lt;li&gt;Annotate your test class with &lt;b&gt;@RunWith(Parameterized.class)&lt;/b&gt;. That way JUnit knows that it has to look out for the &lt;i&gt;@Parameters&lt;/i&gt;-Annotation&lt;/li&gt;
    &lt;li&gt;Provide a &lt;b&gt;public static&lt;/b&gt; method annotated with &lt;b&gt;@Parameters&lt;/b&gt;, a random name and a return value of either &lt;b&gt;Iterable&lt;/b&gt; or &lt;b&gt;Object[]&lt;/b&gt;&lt;/li&gt;
    &lt;li&gt;Provide a constructor with corresponding count and datatypes in which you can map the parameters to member fields&lt;/li&gt;
&lt;/ul&gt;
Now you can use the member fields in your test methods, have a small readable test and can use the full power of the JUnit lifecycle. But the constructor part still looks like it could
be optimized with Java reflections. Therefore JUnit provides the &lt;i&gt;@Parameter&lt;/i&gt;-Annotation as follows:

&lt;pre class="brush: java"&gt;
@RunWith(Parameterized.class)
public class ImprovedParameterizedCalculatorAddTest {

    @Parameters
    public static Iterable&lt;Object[]&gt; data() {
        return Arrays.asList(new Object[][] { { 1, 2, 3 }, { -1, -2, -3 }, { Integer.MAX_VALUE, Integer.MAX_VALUE, -2 },
            { Integer.valueOf(1), Integer.valueOf(2), 3 } });
    }

    @Parameter public int x;
    @Parameter(1) public int y;
    @Parameter(2) public int expected;


    @Test
    public void should_pass() {
        assertThat(Calculator.add(x,y)).isEqualTo(expected);
    }
}
&lt;/pre&gt;
So the constructor can be removed if you change the visibility of your member fields to public (thanks to reflection) and add &lt;i&gt;@Parameter&lt;/i&gt; to every member field. JUnit just
needs to know which field of the parameter array should be mapped to which member field. As you can see it works with an index number which is defaulted to 0. And again the code is more
compact then before considering clean code. But what happens if some parameter combination fails within the test?&lt;br/&gt;&lt;br/&gt;
&lt;figure style="float: right; margin: 5px 0 5px 15px; text-align: center"&gt;
    &lt;img src="http://www.rapidpm.org/2015/04/26/001/named.png" style="width: 350px;"&gt;
    &lt;figcaption&gt;configured @Parameters&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;figure style="float: right; margin: 5px 0 5px 15px; text-align: center"&gt;
    &lt;img src="http://www.rapidpm.org/2015/04/26/001/unnamed.png" style="width: 350px;"&gt;
    &lt;figcaption&gt;unconfigured @Parameters&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;
 I have changed the fourth test result from 1 to 3 and my IntelliJ shows me the result of the left picture. I think that is not very meaningful. But with a small detail of the &lt;i&gt;@Parameters&lt;/i&gt;-
 Annotation it can look like the right picture. In order to do that you can use the &lt;b&gt;name&lt;/b&gt; field of the &lt;i&gt;@Parameters&lt;/i&gt;-Annotation which is defaulted to the String &lt;i&gt;{index}&lt;/i&gt; and shows
 the index of the parameter field. To improve the output the following code snippet could be used to create a more meaningful output:
 &lt;pre class="brush: java"&gt;@Parameters(name = "{index}: Calculator.add({0},{1})={2}")&lt;/pre&gt;
&lt;br/&gt;&lt;br/&gt;
As usual all code samples can be found on my github account &lt;a href="https://github.com/AlexBischof/junit-parameters"&gt;https://github.com/AlexBischof/junit-parameters&lt;/a&gt;
&lt;/div&gt;</content>
        <summary></summary>
    </entry>
</feed>
