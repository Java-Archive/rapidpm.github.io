<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>JavaFX</title>
    <category label="JavaFX"/>
    <updated>2014-07-21T21:31:41.476+02:00</updated>
    <id>http://rapidpm.github.io</id>
    <author>
        <name>Sven Ruppert</name>
    </author>
    <entry>
        <title>cdi.commons.fx -JavaFX/CDI Bootstrap</title>
        <category label="Arquillian"/>
        <category label="CDI"/>
        <category label="IDEA"/>
        <category label="IntelliJ"/>
        <category label="Java"/>
        <category label="JavaFX"/>
        <category label="Weld"/>
        <published>2013-08-03T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/08/03/cdi.commons.fx-javafx-cdi-bootstrap.html&gt;cdi.commons.fx -JavaFX/CDI Bootstrap&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-08-03 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
The both technologies JavaFX and CDI are greate for itself.. but how to combine them? How I can get managed JavaFX - controller instances? &lt;br /&gt;
Starting from the JavaFX – side, we have to implement the Class extending &lt;strong&gt;javafx.application.Application.&lt;/strong&gt; The importand method will be &lt;br /&gt;
&lt;blockquote&gt;
&lt;em&gt;&lt;code&gt;public&lt;/code&gt; &lt;code&gt;void&lt;/code&gt; &lt;code&gt;start(Stage primaryStage) &lt;/code&gt;&lt;code&gt;throws&lt;/code&gt; &lt;code&gt;Exception&lt;/code&gt;&lt;/em&gt;&lt;/blockquote&gt;
&lt;code&gt;&lt;a href="https://bitbucket.org/svenruppert/cdi-commons-fx/src/204e32a360b4090661e7871330921609b628205b/src/main/java/org/rapidpm/demo/cdi/commons/fx/CDIJavaFXBaseApplication.java?at=develop" target="_blank"&gt;CDIJavaFXBaseApplication&lt;/a&gt;&lt;/code&gt; &lt;br /&gt;
&lt;a href="http://lh3.ggpht.com/-spRH4z861ZQ/Uf12wRaYx5I/AAAAAAABTJI/dma-IzG6hho/s1600-h/image%25255B3%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-IKNxCJX9Ma8/Uf12wwRsReI/AAAAAAABTJQ/MQTcwt1GbIU/image_thumb%25255B1%25255D.png?imgmax=800" height="274" style="border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline;" title="image" width="644" /&gt;&lt;/a&gt;  &lt;br /&gt;
&amp;nbsp; &lt;br /&gt;
With &lt;strong&gt;CDIContainerSingleton.getInstance()&lt;/strong&gt; you will get an instance of the Weld-Container. After the normal JavaFX – init&amp;nbsp; there will be an event fired with the primaryStage as attribute. Now the primaryStage is available in an managed environment. &lt;br /&gt;
JAvaFX –&amp;gt; CDI &lt;br /&gt;
&lt;blockquote&gt;
&lt;em&gt;&lt;code&gt;cdi.event()&lt;/code&gt;&lt;code&gt;.select(Stage.&lt;/code&gt;&lt;code&gt;class&lt;/code&gt;&lt;code&gt;, &lt;/code&gt;&lt;code&gt;new&lt;/code&gt; &lt;code&gt;AnnotationLiteral&amp;lt;CDIStartupScene&amp;gt;() {})&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
&lt;code&gt;&lt;em&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; .fire(primaryStage);&lt;/em&gt;&lt;/code&gt;&lt;/blockquote&gt;
The observer will catch this event. Hownthis will be donw, I show with the excample jUnit-test.&lt;br /&gt;
(&lt;a href="https://bitbucket.org/svenruppert/cdi-commons-fx/src/204e32a360b4090661e7871330921609b628205b/src/test/java/org/rapidpm/demo/cdi/commons/fx/JavaFXBaseTest.java?at=develop" target="_blank"&gt;JavaFXBaseTest&lt;/a&gt;)&lt;br /&gt;
&lt;a href="http://lh6.ggpht.com/-pe3l8kSIZrI/Uf12xUqXCaI/AAAAAAABTJY/4qNT0JYh-5o/s1600-h/image%25255B7%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh6.ggpht.com/-mYyW73L1y7A/Uf12xkbSleI/AAAAAAABTJg/GrkqVjLTMhM/image_thumb%25255B3%25255D.png?imgmax=800" height="345" style="border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline;" title="image" width="644" /&gt;&lt;/a&gt; &lt;br /&gt;
The final jUnit-Class (extends JavaFXBaseTest ) will implement the method –&amp;gt; testImpl(final Stage stage). The jUnit-Test will be a manged instance itself.&lt;br /&gt;
&lt;a href="http://lh3.ggpht.com/-rIZgDI2CmZc/Uf12yFhNcaI/AAAAAAABTJo/xmDBb7Nilas/s1600-h/image%25255B11%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-ANX-6HvYjEk/Uf12y-vIj3I/AAAAAAABTJw/sbkL-wTuD-A/image_thumb%25255B5%25255D.png?imgmax=800" height="484" style="border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline;" title="image" width="636" /&gt;&lt;/a&gt; &lt;br /&gt;
But how to get the manged controller class instance?&lt;br /&gt;
This is done by the &lt;code&gt;&lt;strong&gt;FXMLLoaderSingleton used from the jUnit-test.&lt;/strong&gt;&lt;/code&gt;&lt;br /&gt;
&lt;blockquote&gt;
&lt;pre class="brush:java"&gt;
final FXMLLoader fxmlLoader = fxmlLoaderSingleton.getFXMLLoader(LoginPane.class);
&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;br /&gt;
During the process of loading the fxml-file the used FxmlLoader will get an instance of an ControllerFactory-Callback.&lt;br /&gt;
&lt;a href="http://lh6.ggpht.com/-81g1FPtpMV0/Uf12zchLfMI/AAAAAAABTJ4/UZ6beCx-JkE/s1600-h/image%25255B15%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-snchFSsAGE8/Uf12zxccG1I/AAAAAAABTKA/WmMrwTqTh50/image_thumb%25255B7%25255D.png?imgmax=800" height="379" style="border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline;" title="image" width="644" /&gt;&lt;/a&gt; &lt;br /&gt;
The importand lines are the following &lt;br /&gt;
&lt;a href="http://lh6.ggpht.com/-TW3PcealhwQ/Uf120NC8jFI/AAAAAAABTKI/8Tz8jER8lbU/s1600-h/image%25255B19%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-2vpQxC1vfnI/Uf1207BA-xI/AAAAAAABTKQ/f8jnqwb7CC0/image_thumb%25255B9%25255D.png?imgmax=800" height="93" style="border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline;" title="image" width="644" /&gt;&lt;/a&gt; &lt;br /&gt;
The ControllerFactory-&amp;gt;Callback.call() will give back a manged instance of the controller class.&lt;br /&gt;
Now you can use CDI inside the pojo-fx-controller class.&lt;br /&gt;


&lt;pre class="prettyprint"&gt;
public class LoginController implements CDIJavaFxBaseController {
    // Standard FXML injected fields
 @FXML TextField loginField;
 @FXML PasswordField passwordField;
 @FXML Text feedback;
 
 // CDI Injected field
 @Inject LoginService loginService;
 
    // Default application parameters
 @Inject @CDIJavaFXBaseApp
    Parameters applicationParameters;
 
 @FXML protected void handleSubmitButtonAction(ActionEvent event) {
  feedback.setText(loginService.login(loginField.getText(), passwordField.getText()));
 }

 @Override
 public void initialize(URL location, ResourceBundle resources) {
  loginField.setText(applicationParameters.getNamed().get("user"));
 }
}
&lt;/pre&gt;



&lt;br /&gt;
So we are done..&amp;nbsp; Happy coding ;-)&lt;br /&gt;
&lt;br /&gt;
UML-Diagramm&lt;br /&gt;
&lt;img alt="" src="http://wiki.rapidpm.org/download/attachments/8093789/uml_fx_20130802_001.png?version=1&amp;amp;modificationDate=1375433878726&amp;amp;api=v2" height="479" width="640" /&gt;&lt;br /&gt;
&lt;br /&gt;

&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>JavaFX/CDI Bootstrap - Add On</title>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="Java"/>
        <category label="JavaFX"/>
        <category label="jUnit"/>
        <published>2013-08-14T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/08/14/javafx-cdi-bootstrap-add-on.html&gt;JavaFX/CDI Bootstrap - Add On&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-08-14 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
A few days ago I was writing about the JavaFX/CDI Bootstrap. &lt;br /&gt;
There are a few small changings until now. &lt;br /&gt;
&lt;blockquote&gt;
&lt;em&gt;The final jUnit-Class (extends JavaFXBaseTest ) will implement the method –&amp;gt; testImpl(final Stage stage). &lt;/em&gt;&lt;br /&gt;
&lt;em&gt;The jUnit-Test will be a manged instance itself.&lt;/em&gt;&lt;/blockquote&gt;
This is right.. but I forgot to Inject the a few things.&lt;br /&gt;
First the JavaFX component that is managed:&lt;br /&gt;
The jUnit example (&lt;b&gt;CDIJavaFXBaseApplication001Test&lt;/b&gt;, you will find this at cdi-commons-fx) is using the LoginPane.&lt;br /&gt;
This is changed from an empty class to the following implementation&lt;br /&gt;
&lt;script type="syntaxhighlighter" class="brush: js"&gt;&lt;![CDATA[
public class LoginPane extends GridPane {

    private @Inject FXMLLoaderSingleton fxmlLoaderSingleton;
    private @Inject LoginController controller;

    public LoginPane() {
    }

    @PostConstruct
    public void init(){
        final FXMLLoader fxmlLoader = fxmlLoaderSingleton.getFXMLLoader(LoginPane.class);
        fxmlLoader.setRoot(this);
        try {
            fxmlLoader.setController(controller);
            fxmlLoader.load();
        } catch (IOException exception) {
            throw new RuntimeException(exception);
        }
    }

    public LoginController getController() {
        return controller;
    }
}
]]&gt;&lt;/script&gt;
&lt;br /&gt;
Now you have to modify the fxml based on this first version.&lt;br /&gt;
&lt;br /&gt;
&lt;script type="syntaxhighlighter" class="brush: js"&gt;&lt;![CDATA[
&lt;fx:root type="javafx.scene.layout.GridPane" fx:controller="demo.LoginController"
         alignment="CENTER" hgap="10.0" stylesheets="/demo/login.css" vgap="10.0"
          xmlns:fx="http://javafx.com/fxml"
          &gt;

   &lt;!-- .... --&gt;

&lt;/fx:root&gt;
]]&gt;&lt;/script&gt;
&lt;br /&gt;
At this version you had to declare the controller itself. This can be done later by the init-phase. And the root – element was an pure GridPane.
&lt;br /&gt;
The new version looks like this:&lt;br /&gt;
&lt;script type="syntaxhighlighter" class="brush: js"&gt;&lt;![CDATA[
&lt;fx:root type="demo.LoginPane"
         alignment="CENTER" hgap="10.0" stylesheets="/demo/login.css" vgap="10.0"
          xmlns:fx="http://javafx.com/fxml"&gt;

&lt;!-- .... --&gt;

&lt;/fx:root&gt;
]]&gt;&lt;/script&gt;

The root – element is now the self defined class LoginPane and the the controller definition is removed. So you can inject a controller at runtime depending on the ContextResolver.&lt;br /&gt;
&lt;br /&gt;
The jUnit-Test itself changed a little bit. At the first version we used the fxml-Loader to get the LoginPane.. This can now be done by an Inject. (@Inject LoginPane root; )&lt;br /&gt;
&lt;br /&gt;
&lt;script type="syntaxhighlighter" class="brush: js"&gt;&lt;![CDATA[
        @Inject
        @CDISimpleDateFormatter(value = "date.yyyyMMdd")
        SimpleDateFormat sdf;
        @Inject
        @CDILogger
        Logger logger;

        @Inject LoginPane root;

        @Override
        public void testImpl(Stage stage) {
            if (logger.isDebugEnabled()) {
                logger.debug("testrunn at -&gt; " + sdf.format(new Date()));
            }
            stage.setTitle("Login");  //i18n
            stage.setScene(new Scene(root, 300, 275));
            //stage.show();
            final Scene scene = stage.getScene();

            //TestCode
            final TextField login = (TextField) scene.lookup("#loginField");
            login.setText("LOGIN");
            final PasswordField passwd = (PasswordField) scene.lookup("#passwordField");
            passwd.setText("LOGIN");

            final LoginController controller = root.getController();
            controller.handleSubmitButtonAction(new ActionEvent());

            final Text feedback = (Text) scene.lookup("#feedback");
            Assert.assertEquals("LOGIN logged in successfully", feedback.getText());
        }

]]&gt;&lt;/script&gt;
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>How to setup a JavaFX / CDI Component</title>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="Java"/>
        <category label="JavaFX"/>
        <category label="Weld"/>
        <published>2013-08-30T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/08/30/how-to-setup-a-javafx-cdi-component.html&gt;How to setup a JavaFX / CDI Component&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-08-30 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
With cdi-commons it is very easy to start with an JavaFX / CDI Component/Application.&lt;br /&gt;
As an example we will start with an small Table-App with i18n and CDI.&lt;br /&gt;
&lt;a href="http://lh4.ggpht.com/-5_UEi4MPRqU/UiBXeUvOy8I/AAAAAAABTTg/YGS8XJvlXHE/s1600-h/image%25255B4%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh4.ggpht.com/-9eP1fWM5Mq4/UiBXfE6n4nI/AAAAAAABTTo/hYmHY3_DOg8/image_thumb%25255B2%25255D.png?imgmax=800" height="118" style="background-image: none; border-bottom-width: 0px; border-left-width: 0px; border-right-width: 0px; border-top-width: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="244" /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
You need the following steps:&lt;br /&gt;
01) create the empty Controller;&lt;br /&gt;
&lt;a href="http://lh5.ggpht.com/-h_lnfIW1bP0/UiBcdWdzE3I/AAAAAAABTT4/Xjqng3D10bQ/s1600-h/image%25255B4%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-Qi1cIozCosk/UiBcd3dxqZI/AAAAAAABTUA/k1vZxh__QFo/image_thumb%25255B1%25255D.png?imgmax=800" height="120" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="644" /&gt;&lt;/a&gt;&lt;br /&gt;
02) create the Root JavaFX Component&lt;br /&gt;
&lt;a href="http://lh5.ggpht.com/-pyWO2opZ9SA/UiBceQb_ILI/AAAAAAABTUE/k50-cXu8ltU/s1600-h/image%25255B8%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-oXnNYmOYEwc/UiBcenXuo5I/AAAAAAABTUQ/HJuxITXt-zA/image_thumb%25255B3%25255D.png?imgmax=800" height="111" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="644" /&gt;&lt;/a&gt;&lt;br /&gt;
03) create the fxml-file&lt;br /&gt;
&lt;a href="http://lh6.ggpht.com/-GXCDEVy2Ve0/UiBcfIO5TlI/AAAAAAABTUY/SshqU6AVNXg/s1600-h/image%25255B15%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh4.ggpht.com/-3h_Uv3Dzxj0/UiBcf8T4FjI/AAAAAAABTUc/u3tYtlsIWJk/image_thumb%25255B6%25255D.png?imgmax=800" height="484" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="612" /&gt;&lt;/a&gt;&lt;br /&gt;
04) create the i18n-properties&lt;br /&gt;
&lt;a href="http://lh3.ggpht.com/-mRhBaxlqpC0/UiBcgJ1aI-I/AAAAAAABTUk/otKEBYNGIDM/s1600-h/image%25255B19%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh6.ggpht.com/-guqrvakcjms/UiBcg2nyZfI/AAAAAAABTUw/FhecBnTk40A/image_thumb%25255B8%25255D.png?imgmax=800" height="75" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="644" /&gt;&lt;/a&gt;&lt;br /&gt;
05) create the KeyMapper-Class&lt;br /&gt;
&lt;a href="http://lh4.ggpht.com/-atTY5fiaq_0/UiBchsr1r5I/AAAAAAABTU0/6aBTpP3jx70/s1600-h/image%25255B23%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh4.ggpht.com/-UN-1I-kG89A/UiBch5mI93I/AAAAAAABTU8/q4xcsQ50xeI/image_thumb%25255B10%25255D.png?imgmax=800" height="80" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="644" /&gt;&lt;/a&gt;&lt;br /&gt;
06) create the transient Row-Class&lt;br /&gt;
&lt;a href="http://lh3.ggpht.com/-RsZmGPbhFHk/UiBcifod8fI/AAAAAAABTVE/QerSAvdrYMc/s1600-h/image%25255B27%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh3.ggpht.com/-Hd0sCxIFHwI/UiBcjCxqRTI/AAAAAAABTVM/OoEW7vOupG0/image_thumb%25255B12%25255D.png?imgmax=800" height="240" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="644" /&gt;&lt;/a&gt;&lt;br /&gt;
07) create the TableFilters&lt;br /&gt;
&lt;a href="http://lh3.ggpht.com/-WZTIZm0jXL4/UiBcj_3fP7I/AAAAAAABTVQ/Pm8fDRz5zi8/s1600-h/image%25255B31%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh4.ggpht.com/-X-lxpy-bQ9k/UiBckeMSjqI/AAAAAAABTVY/zIFqN7MIrXI/image_thumb%25255B14%25255D.png?imgmax=800" height="303" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="644" /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://lh3.ggpht.com/-4j7YmxgvjW4/UiBckqbYfFI/AAAAAAABTVk/ZULr7ynlrQI/s1600-h/image%25255B35%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh4.ggpht.com/-jTw5ELuINIo/UiBclVVyEKI/AAAAAAABTVo/xBZ9ZlaS9r4/image_thumb%25255B16%25255D.png?imgmax=800" height="463" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="644" /&gt;&lt;/a&gt;&lt;br /&gt;
08) create the RowComparator&lt;br /&gt;
&lt;a href="http://lh3.ggpht.com/-KlUGUuDtrok/UiBcliRMB1I/AAAAAAABTVw/ltV7dDzcftc/s1600-h/image%25255B39%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh6.ggpht.com/-Ss-lT9MR8kc/UiBcmBCBd_I/AAAAAAABTV8/7WPFpEiFlO8/image_thumb%25255B18%25255D.png?imgmax=800" height="484" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="597" /&gt;&lt;/a&gt;&lt;br /&gt;
09) create the DemoDataBuilder&lt;br /&gt;
&lt;a href="http://lh4.ggpht.com/-i_PHNnfPiM8/UiBcmlZx4wI/AAAAAAABTWA/Webh62iZyG0/s1600-h/image%25255B43%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh6.ggpht.com/-EsCNI3UlX0g/UiBcnDjFDhI/AAAAAAABTWM/_0v-REDYjm8/image_thumb%25255B20%25255D.png?imgmax=800" height="258" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="644" /&gt;&lt;/a&gt;&lt;br /&gt;
10) implement the Controller methods&lt;br /&gt;
&lt;a href="http://lh4.ggpht.com/-HV0HNafku7A/UiBcnpsx3gI/AAAAAAABTWU/1kaLaDNhyvc/s1600-h/image%25255B47%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh3.ggpht.com/-7FId4UwLKss/UiBcoVG5XYI/AAAAAAABTWc/KBhjh1BLT00/image_thumb%25255B22%25255D.png?imgmax=800" height="484" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="552" /&gt;&lt;/a&gt;&lt;br /&gt;
11) create the jUnit Test-Class&lt;br /&gt;
&lt;a href="http://lh3.ggpht.com/-oOHz685ypLU/UiBco0QD5GI/AAAAAAABTWg/nZLFC0X8Dts/s1600-h/image%25255B51%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-RBGhQ0MJ9XM/UiBcpaR7sHI/AAAAAAABTWs/nu0UjOo2NuI/image_thumb%25255B24%25255D.png?imgmax=800" height="280" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="644" /&gt;&lt;/a&gt;&lt;br /&gt;
12) start implementing the Workflows….
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>MultiLevel DrillDownPieChart in less then 30min as component for TableViews</title>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="Java"/>
        <category label="JavaFX"/>
        <category label="RapidPM"/>
        <category label="TableView"/>
        <category label="Weld"/>
        <published>2013-09-03T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/09/03/multilevel-drilldownpiechart-in-less-t.html&gt;MultiLevel DrillDownPieChart in less then 30min as component for TableViews&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-09-03 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
&lt;div style="text-align: center;"&gt;
    &lt;i&gt;&lt;span style="font-size: x-small;"&gt;The full code and demo jUnit you will find under :&amp;nbsp;&lt;a href="https://bitbucket.org/rapidpm/modules/src/265b5f577e8f9b5a875408a9659d58a02f72b1af/javafx-chart-pie-drilldown?at=develop" target="_blank"&gt;BitBucket Repo - RapidPM - Modules - javafx-chart-pie-drilldown&lt;/a&gt;&amp;nbsp;&lt;/span&gt;&lt;/i&gt;&lt;/div&gt;
&lt;div style="text-align: center;"&gt;
    &lt;i&gt;&lt;span style="font-size: x-small;"&gt;Please use the develop branch and a commit after&amp;nbsp;&lt;a href="https://bitbucket.org/rapidpm/modules/commits/265b5f577e8f9b5a875408a9659d58a02f72b1af?at=develop"&gt;265b5f5&lt;/a&gt;&amp;nbsp;&lt;/span&gt;&lt;/i&gt;&lt;/div&gt;
&lt;br /&gt;
Sometimes you want to have a drill down pi chart for a tableview. This code often looks like the following &lt;br /&gt;
(example from the oracle side)&lt;br /&gt;
&lt;a href="http://lh5.ggpht.com/-5KuGN_tnaic/UiYI9GTqX6I/AAAAAAABTXI/CKp7qJaPg8M/s1600-h/image%25255B3%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-ydmWK3GgtJk/UiYI9gFkecI/AAAAAAABTXM/tsHeNgJAvL0/image_thumb%25255B1%25255D.png?imgmax=800" height="484" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="530" /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
What you can see, is the direct way of putting the data together for each drilldown-level.&lt;br /&gt;
But if you want to drill down more than one level.. the code will be long.&lt;br /&gt;
For this example I am using the following demo data table.&lt;br /&gt;
&lt;br /&gt;
&lt;a href="http://lh6.ggpht.com/-Dln9HPL38mw/UiYI-gzJA7I/AAAAAAABTXY/l7uE_hEpjOc/s1600-h/image%25255B8%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh3.ggpht.com/-SnrHBEPMMHM/UiYI_MHshTI/AAAAAAABTXc/jFwz7iu2k_w/image_thumb%25255B4%25255D.png?imgmax=800" height="244" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="231" /&gt;&lt;/a&gt;&lt;br /&gt;
What I want to reach is a short way for a developer to aggregate from one row to an other (in both directions)&lt;br /&gt;
Here the pie–chart for this demo data and clicking the following steps:&lt;br /&gt;
Rows: Vorname-&amp;gt;Nachname-&amp;gt;Datum-&amp;gt;Betrag &lt;br /&gt;
Data: Holger-&amp;gt;Hoppel-&amp;gt;2013.10.01-&amp;gt;122.0 &lt;br /&gt;
&lt;a href="http://lh6.ggpht.com/-M8cJy_3fHmw/UiYI_txlqdI/AAAAAAABTXo/RRn5gXIi2LU/s1600-h/image%25255B11%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-CQyGxK2HMYI/UiYJAPlSEII/AAAAAAABTXs/ZZZHHNwgSFE/image_thumb%25255B5%25255D.png?imgmax=800" height="244" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="206" /&gt;&lt;/a&gt;&lt;a href="http://lh4.ggpht.com/-2_gTKMNX8mE/UiYJApNHhRI/AAAAAAABTX4/WFwxYSfYKUY/s1600-h/image%25255B14%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-FKGgdz6m5Co/UiYJBcGFtsI/AAAAAAABTYA/3Kyxlx2ij9Q/image_thumb%25255B6%25255D.png?imgmax=800" height="244" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; margin: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="191" /&gt;&lt;/a&gt;&lt;a href="http://lh4.ggpht.com/-IUAsBkI3mcs/UiYJCFnpZSI/AAAAAAABTYI/ILGKNlZsSsU/s1600-h/image%25255B17%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-K3YgnWkqaZM/UiYJCmmseGI/AAAAAAABTYQ/hDD7FDcvN90/image_thumb%25255B7%25255D.png?imgmax=800" height="244" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; margin: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="221" /&gt;&lt;/a&gt;&lt;a href="http://lh5.ggpht.com/-uIxOkfx3ZxU/UiYJDFf2Z7I/AAAAAAABTYY/hNh3S0nL0yo/s1600-h/image%25255B21%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-YUPfZV8MP3U/UiYJD_HH73I/AAAAAAABTYg/ZtSsq2GJljo/image_thumb%25255B9%25255D.png?imgmax=800" height="244" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="244" /&gt;&lt;/a&gt;&lt;br /&gt;
You can see, that for each level you will get the aggregated data from the table..&amp;nbsp; But how to do it?&lt;br /&gt;
The basic is the Aggregator-Class&lt;br /&gt;
&lt;script type="syntaxhighlighter" class="brush: java"&gt;&lt;![CDATA[
public abstract class MapAggregator&lt;T, K&gt; {

    private @Inject @CDILogger Logger logger;

    public abstract K getKeyElement(T t);

    public Map&lt;K, List&lt;T&gt;&gt; aggregate(final Collection&lt;T&gt; dataCollection) {
        final Map&lt;K, List&lt;T&gt;&gt; result = new HashMap&lt;&gt;();
        for (final T dataObject : dataCollection) {
            final K key = getKeyElement(dataObject);
            if (result.containsKey(key)) {
                if (logger.isDebugEnabled()) {
                    logger.debug("key schon vorhanden -&gt; " + key);
                }
            } else {
                result.put(key, new ArrayList&lt;T&gt;());
            }
            result.get(key).add(dataObject);
        }
        return result;
    }
}
]]&gt;&lt;/script&gt;
&lt;br /&gt;
&lt;span class="nt" style="background-color: ghostwhite; color: navy; font-family: Consolas, 'Liberation Mono', Courier, monospace; font-size: 14px; line-height: 19px; white-space: pre;"&gt;&lt;/span&gt;

With this you can aggregate a collection to a map. The key is the aggregated value from the collection elements.&lt;br /&gt;
For this example: A Collection of the TransientDemoDataRow (Collection&lt;transientdemodatarow&gt;) aggregated over the attribute vorname.&lt;/transientdemodatarow&gt;&lt;br /&gt;

&lt;script type="syntaxhighlighter" class="brush: java"&gt;&lt;![CDATA[
public class TransientDemoDataRow {


    private String vorname;
    private String nachname;
    private String datum;
    private Double betrag;

    @PostConstruct
    public void init() {

    }

    public String getVorname() {
        return vorname;
    }

    public void setVorname(String vorname) {
        this.vorname = vorname;
    }

    public String getNachname() {
        return nachname;
    }

    public void setNachname(String nachname) {
        this.nachname = nachname;
    }

    public String getDatum() {
        return datum;
    }

    public void setDatum(String datum) {
        this.datum = datum;
    }

    public Double getBetrag() {
        return betrag;
    }

    public void setBetrag(Double betrag) {
        this.betrag = betrag;
    }
}
]]&gt;&lt;/script&gt;
With our demo data table you will get a map with two collections. &lt;br /&gt;
a) Holger –&amp;gt; List of 6 elements&lt;br /&gt;
b) Willi –&amp;gt; List of 4 elements&lt;br /&gt;
This is the data for the first level of the DrillDownPieChart. (first pic of the pie charts see above)&lt;br /&gt;
For our DrillDownPieChart we are using the following aggregator extending the MapAggregator&lt;t&gt;.&lt;/t&gt;&lt;br /&gt;
&lt;t&gt;&lt;/t&gt;&lt;br /&gt;
&lt;script type="syntaxhighlighter" class="brush: java"&gt;&lt;![CDATA[
public abstract class DrillDownPieChartMapAggregator&lt;T&gt; extends MapAggregator&lt;T, String&gt; {


    /**
     * Calculate the Value for the PiChart.Data based on the aggregated values
     *
     * @param aggregatedValues
     * @return
     */
    public abstract double aggregateValue(List&lt;T&gt; aggregatedValues);

    public abstract String getLevelName();

    private DrillDownPieChartMapAggregator&lt;T&gt; nextLevelAggregator;
    private DrillDownPieChartMapAggregator&lt;T&gt; parentLevelAggregator;

    public DrillDownPieChartMapAggregator&lt;T&gt; getNextLevelAggregator() {
        return nextLevelAggregator;
    }

    public DrillDownPieChartMapAggregator&lt;T&gt; getParentLevelAggregator() {
        return parentLevelAggregator;
    }

    public void setNextLevelAggregator(DrillDownPieChartMapAggregator&lt;T&gt; nextLevelAggregator) {
        this.nextLevelAggregator = nextLevelAggregator;
        this.nextLevelAggregator.parentLevelAggregator = this;
    }

    public boolean isLastOne() {
        if (nextLevelAggregator == null) {
            return true;
        } else {
            return false;
        }
    }

    public boolean isFirstOne() {
        if (parentLevelAggregator == null) {
            return true;
        } else {
            return false;
        }
    }

}
]]&gt;&lt;/script&gt;
&lt;br /&gt;
We are holding the reference to the next level aggregator and the reference to the parent aggregator.&lt;br /&gt;
To implement the aggregator for each col. we want to use for our DrillDownPieChart we have to write code like the following&lt;br /&gt;
&lt;script type="syntaxhighlighter" class="brush: java"&gt;&lt;![CDATA[
public static class BetragAggregator extends DrillDownPieChartMapAggregator&lt;TransientDemoDataRow&gt; {
        @Override public double aggregateValue(List&lt;TransientDemoDataRow&gt; aggregatedValues) {
            double betrag = 0;
            for (final TransientDemoDataRow aggregatedValue : aggregatedValues) {
                betrag = betrag + aggregatedValue.getBetrag();
            }
            return betrag;
        }

        @Override public String getLevelName() {
            return "Betrag";
        }

        @Override public String getKeyElement(TransientDemoDataRow transientDemoDataRow) {
            return transientDemoDataRow.getBetrag() + " € Beträge";
        }
    }

    public static class DatumAggregator extends DrillDownPieChartMapAggregator&lt;TransientDemoDataRow&gt; {
        @Override public double aggregateValue(List&lt;TransientDemoDataRow&gt; aggregatedValues) {
            return aggregatedValues.size();
        }

        @Override public String getLevelName() {
            return "Datum";
        }
        @Override public String getKeyElement(TransientDemoDataRow transientDemoDataRow) {
            return transientDemoDataRow.getDatum();
        }
    }

    public static class VornameAggregator extends DrillDownPieChartMapAggregator&lt;TransientDemoDataRow&gt; {
        @Override public double aggregateValue(List&lt;TransientDemoDataRow&gt; aggregatedValues) {
            return aggregatedValues.size();
        }

        @Override public String getLevelName() {
            return "Vorname";
        }

        @Override public String getKeyElement(TransientDemoDataRow transientDemoDataRow) {
            return transientDemoDataRow.getVorname();
        }
    }


    public static class NachnameAggregator extends DrillDownPieChartMapAggregator&lt;TransientDemoDataRow&gt; {
        @Override public double aggregateValue(List&lt;TransientDemoDataRow&gt; aggregatedValues) {
            return aggregatedValues.size();
        }

        @Override public String getLevelName() {
            return "Nachname";
        }
        @Override public String getKeyElement(TransientDemoDataRow transientDemoDataRow) {
            return transientDemoDataRow.getNachname();
        }
    }

]]&gt;&lt;/script&gt;
&lt;br /&gt;
The method getLevelName is to label the PieChart for the user.&lt;br /&gt;
The method getKeyElement is the value used for the aggregation.&lt;br /&gt;
The method aggregateValue is to calculate the double, used by the pie chart as value.&lt;br /&gt;
After this you have to put all together… the logic-part is done now..&lt;br /&gt;
&lt;script type="syntaxhighlighter" class="brush: java"&gt;&lt;![CDATA[
public class DrillDownPieChartPaneController implements CDIJavaFxBaseController {

    @FXML DemoDrillDownPieChart piechart;


    @Inject Instance&lt;VornameAggregator&gt; vornameAggregatorInstance;
    @Inject Instance&lt;NachnameAggregator&gt; nachnameAggregatorInstance;
    @Inject Instance&lt;DatumAggregator&gt; datumAggregatorInstance;
    @Inject Instance&lt;BetragAggregator&gt; betragAggregatorInstance;


    @Override public void initialize(URL url, ResourceBundle resourceBundle) {

        //setze Aggregatoren
        final VornameAggregator vornameAggregator = vornameAggregatorInstance.get();

        final NachnameAggregator nachnameAggregator = nachnameAggregatorInstance.get();
        vornameAggregator.setNextLevelAggregator(nachnameAggregator);

        final DatumAggregator datumAggregator = datumAggregatorInstance.get();
        nachnameAggregator.setNextLevelAggregator(datumAggregator);

        final BetragAggregator betragAggregator = betragAggregatorInstance.get();
        datumAggregator.setNextLevelAggregator(betragAggregator);

        piechart.setRootAggregator(vornameAggregator);

    }


    public void init() {
        piechart.init();
    }

]]&gt;&lt;/script&gt;
The gui part looks like this: Extending the DrillDownPieChart with the type you need as data holder, here the TransientDemoDataRow.&lt;br /&gt;
&lt;script type="syntaxhighlighter" class="brush: java"&gt;&lt;![CDATA[
public class TransientDemoDataRow {


    private String vorname;
    private String nachname;
    private String datum;
    private Double betrag;

    @PostConstruct
    public void init() {

    }

    public String getVorname() {
        return vorname;
    }

    public void setVorname(String vorname) {
        this.vorname = vorname;
    }

    public String getNachname() {
        return nachname;
    }

    public void setNachname(String nachname) {
        this.nachname = nachname;
    }

    public String getDatum() {
        return datum;
    }

    public void setDatum(String datum) {
        this.datum = datum;
    }

    public Double getBetrag() {
        return betrag;
    }

    public void setBetrag(Double betrag) {
        this.betrag = betrag;
    }
}
]]&gt;&lt;/script&gt;
and putting it to a fxml file.&lt;br /&gt;
&lt;script type="syntaxhighlighter" class="brush: javafx"&gt;&lt;![CDATA[
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;?import gui.org.rapidpm.modul.javafx.chart.pie.drilldown.DemoDrillDownPieChart?&gt;
&lt;?import javafx.scene.control.Label?&gt;
&lt;?import javafx.scene.layout.AnchorPane?&gt;
&lt;?import javafx.scene.layout.VBox?&gt;
&lt;fx:root type="gui.org.rapidpm.modul.javafx.chart.pie.drilldown.DrillDownPieChartPane"
         fx:id="DrillDownPieChartPane" xmlns:fx="http://javafx.com/fxml" style="-fx-background-color:#EEEEEE"&gt;

    &lt;children&gt;
        &lt;AnchorPane minHeight="0.0" minWidth="0.0" VBox.vgrow="ALWAYS"
                    AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0"&gt;
            &lt;children&gt;
                &lt;Label text="hallo Hier bin ich"/&gt;
                &lt;DemoDrillDownPieChart fx:id="piechart"&gt;

                &lt;/DemoDrillDownPieChart&gt;
            &lt;/children&gt;
        &lt;/AnchorPane&gt;
    &lt;/children&gt;
&lt;/fx:root&gt;
]]&gt;&lt;/script&gt;
ready…&amp;nbsp; &lt;br /&gt;
&lt;br /&gt;
The steps for a developer are:&lt;br /&gt;
1) writing the transient data holder for an row –&amp;gt; TransientDemoDataRow&lt;br /&gt;
2) extending the DrillDownPieChart –&amp;gt; DemoDrillDownPieChart extends&lt;transientdemodatarow&gt;&lt;/transientdemodatarow&gt;&lt;br /&gt;
3) extending the DrillDownPieChartMapAggregator –&amp;gt; NachnameAggregator extends DrillDownPieChartMapAggregator&lt;transientdemodatarow&gt;&lt;/transientdemodatarow&gt;&lt;br /&gt;
4) putting all aggregator implementations together –&amp;gt; Controller – Class&lt;br /&gt;
5) add the element to the fxml file, &lt;br /&gt;
6) init() and ready&lt;br /&gt;
For a normal TableView with a handfull of rows you will need less than 30 min.&lt;br /&gt;
&lt;br /&gt;
The basic classes to use for an developer:&lt;br /&gt;
&lt;a href="http://lh3.ggpht.com/-SJ-pDNpLOMc/UiYJNA9ohpI/AAAAAAABTaY/ofUQV5uIuEk/s1600-h/image%25255B54%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh4.ggpht.com/-WMXinq5fTd8/UiYJNoBLSEI/AAAAAAABTag/WlbvOUwDZsk/image_thumb%25255B26%25255D.png?imgmax=800" height="484" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="513" /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
All classes from the jUnit demo available at the javafx-chart-pie-drilldown module.&lt;br /&gt;
&lt;a href="http://lh6.ggpht.com/-lP1udVyDMVA/UiYJOSIqFfI/AAAAAAABTao/rEssoxks5Gs/s1600-h/image%25255B58%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh3.ggpht.com/-LiWMRqCVT5A/UiYJPDrwyVI/AAAAAAABTaw/huD7OwGJooI/image_thumb%25255B28%25255D.png?imgmax=800" height="362" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="644" /&gt;&lt;/a&gt;

&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>CDI - ComboBoxCell - How to reduce 80% of code</title>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="FilteredTableView"/>
        <category label="Java"/>
        <category label="JavaFX"/>
        <category label="RapidPM"/>
        <category label="TableView"/>
        <category label="Weld"/>
        <published>2013-09-06T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/09/06/cdi-comboboxcell-how-to-reduce-80%-of-.html&gt;CDI - ComboBoxCell - How to reduce 80% of code&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-09-06 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
&lt;div style="text-align: center;"&gt;
    &lt;i&gt;&lt;span style="font-size: x-small;"&gt;The full code and demo jUnit you will find under :&amp;nbsp;&lt;a href="https://bitbucket.org/rapidpm/modules/src/aec4f95e0ae3130f62bc79170c0233cf49e43299/javafx-filtered-tableview?at=develop" target="_blank"&gt;BitBucket Repo - RapidPM - Modules - javafx-filtered-tableview&lt;/a&gt;&amp;nbsp;&lt;/span&gt;&lt;/i&gt;&lt;/div&gt;
&lt;div style="text-align: center;"&gt;
    &lt;i&gt;&lt;span style="font-size: x-small;"&gt;Please use the develop branch and a commit after&amp;nbsp;&lt;a href="https://bitbucket.org/rapidpm/modules/commits/265b5f577e8f9b5a875408a9659d58a02f72b1af?at=develop"&gt;aec4f95&lt;/a&gt;&amp;nbsp;&lt;/span&gt;&lt;/i&gt;&lt;/div&gt;
&lt;br /&gt;
&lt;br /&gt;
Today I had a TableView with the following function.&lt;br /&gt;
- In one column there was a ComboBoxCell.&lt;br /&gt;
- The values of this ComboBox was calculated / loaded at the moment the combobox was used.&lt;br /&gt;
- Each ComboBox will have different values based on the context of this row.&lt;br /&gt;
&lt;br /&gt;
The first version was something like this:&lt;br /&gt;
A ComboBoxCell:&lt;br /&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class LegacyBetragComboBoxCell extends ComboBoxTableCell&lt;TransientDemoDataRow, Double&gt; {

    private @Inject @CDILogger Logger logger;
    private boolean readOnlyView = false;

    @Inject Instance&lt;contextlogic&gt; contextLogicInstance; //some injected business logic;

    @Override
    public void updateItem(Double o, boolean b) {
        if (logger.isDebugEnabled()) {
            logger.debug("ComboBoxTableCell-&gt;updateItem " + o);
        }
        super.updateItem(o, b);
        if (o == null) {
            //
        } else {
            final TableRow tableRow = getTableRow();
            final TransientDemoDataRow row = (TransientDemoDataRow) tableRow.getItem();
            getItems().clear();
            if (row.getBetrag() == null || row.getBetrag().isInfinite() || row.getBetrag().isNaN()) {
                this.setDisable(true);
            } else if (readOnlyView) {
                this.setDisable(true);
            } else {
                final ContextLogic contextLogic = contextLogicInstance.get();
                final List&lt;double&gt; doubleList = contextLogic.workOnContext(row.getBetrag());

                getItems().addAll(doubleList);

                this.setDisable(false);
            }
            //application logic on row itself
            //application logic external
        }
    }


    public boolean isReadOnlyView() {
        return readOnlyView;
    }

    public void setReadOnlyView(boolean readOnlyView) {
        this.readOnlyView = readOnlyView;
    }
}
]]&gt;&lt;/script&gt;


and the code called from the controller:&lt;br /&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
    @Inject Instance&lt;legacybetragcomboboxcell&gt; legacyBetragComboBoxCellInstance;

    private void initTable() {
        final ObservableList&lt;TableColumn&lt;TransientDemoDataRow, ?&gt;&gt; columns = tableView.getColumns();
        for (final TableColumn&lt;TransientDemoDataRow, ?&gt; column : columns) {
            if(column.getText().equals("betrag")){
                final TableColumn&lt;TransientDemoDataRow, Double&gt; colTyped =(TableColumn&lt;TransientDemoDataRow, Double&gt;) column;
                colTyped.setCellFactory(new Callback&lt;TableColumn&lt;TransientDemoDataRow, Double&gt;, TableCell&lt;TransientDemoDataRow, Double&gt;&gt;() {
                    @Override public TableCell&lt;TransientDemoDataRow, Double&gt; call(TableColumn&lt;TransientDemoDataRow, Double&gt; transientDemoDataRowTableColumn) {
                        final LegacyBetragComboBoxCell cell = legacyBetragComboBoxCellInstance.get();
                        cell.setComboBoxEditable(false);  //true if you want bidirectional dataflow
                        return  cell;
                    }
                });

            } else{
                //other col
            }
        }
    }
]]&gt;&lt;/script&gt;

&lt;br /&gt;
This is to much boilerplate code. So I started to reduce it.&lt;br /&gt;
&lt;br /&gt;
First step was reducing the generics..&lt;br /&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
    @Inject Instance&lt;betragcomboboxcell&gt; betragComboBoxCellInstance;

    private void initTable() {
        final ObservableList&lt;TableColumn&lt;TransientDemoDataRow, ?&gt;&gt; columns = tableView.getColumns();
        for (final TableColumn column : columns) {
            if (column.getText().equals("betrag")) {
                column.setCellFactory(new Callback&lt;TableColumn, TableCell&gt;() {
                    @Override public TableCell call(TableColumn tableColumn) {
                        final BetragComboBoxCell cell = betragComboBoxCellInstance.get();
                        cell.setComboBoxEditable(false);  //true if you want bidirectional dataflow
                        return cell;
                    }
                });

            } else {
                //other col
            }
        }
    }
]]&gt;&lt;/script&gt;
This is shorter, but not better...&amp;nbsp;
&lt;br /&gt;
&lt;br /&gt;
The solution is the abstract GenericComboBoxCell. (part of the &lt;a href="https://bitbucket.org/rapidpm/modules/src/cd6e925b21196fc3e3a5f7b26abe879ed6add129/javafx-filtered-tableview?at=develop" target="_blank"&gt;javafx-filtered-tableview module&lt;/a&gt;)&lt;br /&gt;
&lt;br /&gt;
Iterating over the columns are now part of the GenericComboBoxCell, and here will be the typesave code.&lt;br /&gt;
&lt;br /&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public abstract class GenericComboBoxCell&lt;RT, VT&gt; extends ComboBoxTableCell&lt;RT, VT&gt; {

    private @Inject @CDILogger Logger logger;
    private boolean readOnlyView = false;

    @Override
    public void updateItem(VT o, boolean b) {
        if (logger.isDebugEnabled()) {
            logger.debug("ComboBoxTableCell-&gt;updateItem " + o);
        }
        super.updateItem(o, b);
        if (o == null) {
            //
        } else {
            final TableRow tableRow = getTableRow();
            final RT row = (RT) tableRow.getItem();
            getItems().clear();
            if (disableComboBox(row)) {
                this.setDisable(true);
            } else if (readOnlyView) {
                this.setDisable(true);
            } else {

                final List&lt;vt&gt; comboBoxValues = createComboBoxValues(row);
                getItems().addAll(comboBoxValues);

                this.setDisable(false);
            }
            workOnRowItself(row);
        }
    }

    public void associateWithCol(final TableView&lt;rt&gt; tableView, final String colName) {
        final ObservableList&lt;TableColumn&lt;RT, ?&gt;&gt; columns = tableView.getColumns();
        for (final TableColumn&lt;RT, ?&gt; column : columns) {
            final String columnText = column.getText();
            if (columnText.equals(colName)) {
                if (logger.isDebugEnabled()) {
                    logger.debug("associating to col " + columnText);
                }
                associate((TableColumn&lt;RT, VT&gt;) column);
            } else {
                if (logger.isDebugEnabled()) {
                    logger.debug("not binding to this col : " + columnText);
                }
            }
        }
    }

    private void associate(TableColumn&lt;RT, VT&gt; column) {
        column.setCellFactory(new Callback&lt;TableColumn&lt;RT, VT&gt;, TableCell&lt;RT, VT&gt;&gt;() {
            @Override
            public TableCell&lt;RT, VT&gt; call(TableColumn&lt;RT, VT&gt; rtTableColumn) {
                final GenericComboBoxCell&lt;RT, VT&gt; mySelf = getComboBoxCellRef();
                mySelf.setComboBoxEditable(false);
                mySelf.setReadOnlyView(readOnlyView);
                return mySelf;
            }
        });
    }

    protected abstract GenericComboBoxCell&lt;RT, VT&gt; getComboBoxCellRef();

    /**
     * logic to disable the combobox, for example if the value ist null or ...
     *
     * @return
     */
    public abstract boolean disableComboBox(final RT row);

    public abstract List&lt;vt&gt; createComboBoxValues(final RT row);

    public abstract void workOnRowItself(final RT row);


    public boolean isReadOnlyView() {
        return readOnlyView;
    }

    public void setReadOnlyView(boolean readOnlyView) {
        this.readOnlyView = readOnlyView;
    }
}
]]&gt;&lt;/script&gt;

The developer must extend this class and has to implement the following methods only:&lt;br /&gt;
- protected abstract GenericComboBoxCell&lt;rt vt=""&gt; getComboBoxCellRef();&amp;nbsp;&lt;/rt&gt;&lt;br /&gt;
&lt;rt vt=""&gt;- public abstract boolean disableComboBox(final RT row); (optional)&amp;nbsp;&lt;/rt&gt;&lt;br /&gt;
&lt;rt vt=""&gt;- public abstract List&lt;vt&gt; createComboBoxValues(final RT row);&amp;nbsp;&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;rt vt=""&gt;&lt;vt&gt;- public abstract void workOnRowItself(final RT row); (optional)&amp;nbsp;&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;rt vt=""&gt;&lt;vt&gt;A demo implementation is shown here:&amp;nbsp;&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class BetragComboBoxCell extends GenericComboBoxCell&lt;TransientDemoDataRow, Double&gt; {

    @Inject Instance&lt;contextlogic&gt; contextLogicInstance; //business logic
    @Inject Instance&lt;betragcomboboxcell&gt; betragComboBoxCellInstance; //the cell instance itself

    @Override
    protected GenericComboBoxCell&lt;TransientDemoDataRow, Double&gt; getComboBoxCellRef() {
        return betragComboBoxCellInstance.get();
    }

    @Override public boolean disableComboBox(TransientDemoDataRow row) {
        return row.getBetrag() == null || row.getBetrag().isInfinite() || row.getBetrag().isNaN();
    }

    @Override public List&lt;double&gt; createComboBoxValues(TransientDemoDataRow row) {
        final ContextLogic contextLogic = contextLogicInstance.get();
        final List&lt;double&gt; doubleList = contextLogic.workOnContext(row.getBetrag());
        return doubleList;
    }

    @Override public void workOnRowItself(TransientDemoDataRow row) {
        //nothing for this example
    }
}
]]&gt;&lt;/script&gt;


&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;rt vt=""&gt;&lt;vt&gt;The controlle will need a piece of code like this:&amp;nbsp;&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
    @Inject Instance&lt;betragcomboboxcell&gt; betragComboBoxCellInstance;

    private void initTable() {
        final BetragComboBoxCell cell = betragComboBoxCellInstance.get();
        cell.associateWithCol(tableView, "betrag");
    }
]]&gt;&lt;/script&gt;

&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;rt vt=""&gt;&lt;vt&gt;With this you can test the context logic indepentend from the javafx stuff.&amp;nbsp;&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;rt vt=""&gt;&lt;vt&gt;All initializations inside a ComboBoxCell must be done in a PostConstruct - method.&amp;nbsp;&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;rt vt=""&gt;&lt;vt&gt;With the&amp;nbsp;GenericComboBoxCell&amp;nbsp;you can activate/deactivate the combobox, modify the row cell values, and create the combobox values.&amp;nbsp;&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;rt vt=""&gt;&lt;vt&gt;This implementation is based on the JavaFX/CDI bootstrap from cdi-commons-fx. (blog entry &lt;a href="http://www.rapidpm.org/2013/08/cdicommonsfx-javafxcdi-bootstrap.html" target="_blank"&gt;JavaFX/CDI bootstrap&lt;/a&gt; )&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://2.bp.blogspot.com/-AQ7GFqVQD4U/Uin3Zyv-FxI/AAAAAAABTbs/Kp70aYegR3U/s1600/tableview001.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://2.bp.blogspot.com/-AQ7GFqVQD4U/Uin3Zyv-FxI/AAAAAAABTbs/Kp70aYegR3U/s1600/tableview001.jpg" height="216" width="320" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://2.bp.blogspot.com/-8qDppXPeXes/Uin3Z_Su-pI/AAAAAAABTb4/BLIB0FT2cLI/s1600/tableview002.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://2.bp.blogspot.com/-8qDppXPeXes/Uin3Z_Su-pI/AAAAAAABTb4/BLIB0FT2cLI/s1600/tableview002.jpg" height="218" width="320" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;rt vt=""&gt;&lt;vt&gt;UML of this demo:&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://1.bp.blogspot.com/-ePJ6s1IzMKE/Uiny8-L--tI/AAAAAAABTbY/3hK_OgfHDPc/s1600/uml.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img alt="" border="0" src="http://1.bp.blogspot.com/-ePJ6s1IzMKE/Uiny8-L--tI/AAAAAAABTbY/3hK_OgfHDPc/s1600/uml.png" height="608" title="" width="640" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;rt vt=""&gt;&lt;vt&gt;Full CDI dependicies&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://4.bp.blogspot.com/-1CreRx6oh_I/UinzViniCcI/AAAAAAABTbg/E6C0MdnnRTQ/s1600/cdi-deps.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://4.bp.blogspot.com/-1CreRx6oh_I/UinzViniCcI/AAAAAAABTbg/E6C0MdnnRTQ/s1600/cdi-deps.png" height="254" width="640" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>Where to find the cdi-commons and javafx modules ?</title>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="JavaFX"/>
        <category label="RapidPM"/>
        <published>2013-09-10T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/09/10/where-to-find-the-cdi-commons-and-java.html&gt;Where to find the cdi-commons and javafx modules ?&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-09-10 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
Since RapidPM-Modules is available at the central repo (&lt;a href="http://www.sonatype.org/central"&gt;Thanks SonarType&lt;/a&gt;), we are using the following repositories.&lt;br /&gt;
&lt;br /&gt;
For development: (no stable builds/ development branch ci )&lt;br /&gt;
&lt;br /&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href="http://nexus.rapidpm.org/nexus/index.html#welcome"&gt;http://nexus.rapidpm.org/nexus/index.html#welcome&lt;/a&gt;/ (snapshots)&lt;/li&gt;
    &lt;li&gt;&lt;a href="http://nexus.rapidpm.org/nexus/index.html#welcome"&gt;http://nexus.rapidpm.org/nexus/content/groups/public&lt;/a&gt;&amp;nbsp;(mirror
        for needed artifacts)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;
    For Releases and Snapshots from the release-branches/master-branch&lt;/div&gt;
&lt;div&gt;
    &lt;ul&gt;
        &lt;li&gt;Releases&amp;nbsp;&lt;a href="http://search.maven.org/#search%7Cga%7C1%7Crapidpm"&gt;http://search.maven.org/&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;RC &lt;a href="https://oss.sonatype.org/index.html#view-repositories;snapshots~browsestorage"&gt;https://oss.sonatype.org/&lt;/a&gt;&amp;nbsp;&lt;/li&gt;
    &lt;/ul&gt;
    &lt;div&gt;
        &lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>FullText - SearchBox for TableView Part I</title>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="JavaFX"/>
        <category label="RapidPM"/>
        <published>2013-09-10T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/09/10/fulltext-searchbox-for-tableview-part-.html&gt;FullText - SearchBox for TableView Part I&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-09-10 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
How to combine a FullTextSearch with a TableView?&lt;br /&gt;
I would say, you will need 30 min max ;-) But How?&lt;br /&gt;
Short version :&lt;br /&gt;
&lt;br /&gt;
&lt;ul&gt;
    &lt;li&gt;implementing 2 small methods&lt;/li&gt;
    &lt;li&gt;put a SearchBox element to the fxml file&lt;/li&gt;
    &lt;li&gt;combine the TableView with the SearchBox&amp;nbsp;&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
Long version:&lt;br /&gt;
Let´s start with the correspondings jUnit.&lt;br /&gt;
&lt;br /&gt;
As described (&lt;a href="http://www.rapidpm.org/2013/09/cdi-comboboxcell-how-to-reduce-80-of.html"&gt;here&lt;/a&gt;)&amp;nbsp;we will start with a small demo - jUnit, containing a TableView.&lt;br /&gt;
To make the example smaller I will use a default TableView.&lt;br /&gt;
&lt;br /&gt;
&lt;div style="text-align: center;"&gt;
    &lt;span style="font-size: x-small;"&gt;&lt;i&gt;The full code and demo jUnit you will find under : BitBucket Repo - RapidPM - Modules - javafx-searchbox&amp;nbsp;&lt;/i&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="text-align: center;"&gt;
    &lt;span style="font-size: x-small;"&gt;&lt;i&gt;Please use &amp;nbsp;a commit after&amp;nbsp;&lt;/i&gt;&lt;/span&gt;&lt;a class="execute" href="https://bitbucket.org/rapidpm/modules/commits/59237d342eec977e8aece0c83a96ab3d0dca5856?at=release/1.1.1" style="background-color: whitesmoke; color: #3b73af; font-family: Monaco, monospace; font-size: 12px;"&gt;59237d3&lt;/a&gt;&lt;/div&gt;
&lt;br /&gt;
The application based on the &lt;b&gt;SearchBoxDemoPane&lt;/b&gt;&lt;br /&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class SearchBoxDemoPane extends CDIBaseAnchorPane&lt;SearchBoxDemoPane, SearchBoxDemoPaneController&gt; {
    @Override public Class&lt;searchboxdemopane&gt; getPaneClass() {
        return SearchBoxDemoPane.class;
    }
}
]]&gt;&lt;/script&gt;

with the &lt;b&gt;SearchBoxDemoPaneController&lt;/b&gt;.&lt;br /&gt;
&lt;br /&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class SearchBoxDemoPaneController implements CDIJavaFxBaseController {

    private @Inject @CDILogger Logger logger;

    @Inject @CDIPropertyRegistryService PropertyRegistryService propertyRegistryService;
    @Inject DemoKeyMapper keyMapper;
    @Inject Instance&lt;transientdemorowcomparator&gt; comparatorInstance;

    @FXML public TableView&lt;transientdemodatarow&gt; tableView;
    @FXML public SearchBox SearchBox;

    @Override public void initialize(URL url, ResourceBundle resourceBundle) {
        initTable();
        setI18n();

        //init SearchBox
        refreshIndex();

    }

    private void refreshIndex() {
        final ObservableList&lt;transientdemodatarow&gt; items = tableView.getItems();
        SearchBox.refreshIndex(items);
    }

    private void initTable() {

    }

    private void setI18n() {
        final ObservableList&lt;TableColumn&lt;TransientDemoDataRow, ?&gt;&gt; col = tableView.getColumns();
        for (final TableColumn column : col) {
            final String text = column.getText();
            final String map = map(text);
            if (logger.isDebugEnabled()) {
                logger.debug("text -&gt; " + text);
                logger.debug("map -&gt; " + map);
            }
            column.setText(map);
        }
    }

    private String map(final String key) {
        return propertyRegistryService.getRessourceForKey(keyMapper.map(key));
    }

}
]]&gt;&lt;/script&gt;

and the transient data for the TableView&amp;nbsp;&lt;b&gt;TransientDemoDataRow&lt;/b&gt;&lt;br /&gt;
The importand part is the implementation of the Interface SearchBoxDataElement, this will make the connection between the index and the full-text search later.&lt;br /&gt;
&lt;br /&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class TransientDemoDataRow implements Serializable, SearchBoxDataElement {

    @Inject @CDIPropertyRegistryService PropertyRegistryService propertyRegistryService;
    @Inject DemoKeyMapper keyMapper;

    private StringProperty vorname;
    private StringProperty nachname;
    private StringProperty datum;
    private SimpleDoubleProperty betrag;

    private SimpleLongProperty ID; //normaly a normal Long, not shown at the table

    @PostConstruct
    public void init() {
        vorname = new SimpleStringProperty(this, map("vorname"));
        nachname = new SimpleStringProperty(this, map("nachname"));
        datum = new SimpleStringProperty(this, map("datum"));
        betrag = new SimpleDoubleProperty(this, map("betrag"));
        ID = new SimpleLongProperty(this, map("ID"));
    }

    private String map(final String key) {
        return propertyRegistryService.getRessourceForKey(keyMapper.map(key));
    }

//.. snip getter / setter

    public Long getID() {
        return ID.get();
    }

    public SimpleLongProperty IDProperty() {
        return ID;
    }

    public void setID(long ID) {
        this.ID.set(ID);
    }

    @Override public List&lt;string&gt; getValues() {
        return Lists.newArrayList(getID() + "", getVorname(), getNachname(), getDatum(), getBetrag() + "");
    }

    @Override public String shortInfo() {
        return getID() + " - " + getVorname() + " - " + getNachname() + " - " + getDatum() + " - " + getBetrag() + "";
    }
}
]]&gt;&lt;/script&gt;

&lt;br /&gt;
&lt;div&gt;
    Now we will put the SearchBox to the fxml.&lt;/div&gt;
&lt;div&gt;
    This is only one line&amp;nbsp;&lt;/div&gt;
&lt;div&gt;
    &lt;span style="font-size: x-small;"&gt;&lt;i&gt;&lt;b&gt;&amp;nbsp;&amp;lt;SearchBox fx:id="SearchBox" visible="true" minHeight="24.00"&lt;/b&gt;&lt;/i&gt;&lt;/span&gt;&lt;i style="font-size: small;"&gt;&lt;b&gt;&amp;nbsp;prefWidth="1024.0" maxWidth="-Infinity"/&amp;gt;&lt;/b&gt;&lt;/i&gt;&lt;/div&gt;
&lt;div&gt;
    &lt;br /&gt;&lt;/div&gt;
&lt;script class="brush: javafx" type="syntaxhighlighter"&gt;&lt;![CDATA[
&lt;?import java.net.URL?&gt;
&lt;?import javafx.scene.control.cell.PropertyValueFactory?&gt;
&lt;?import javafx.scene.control.ScrollPane?&gt;
&lt;?import javafx.scene.control.TableColumn?&gt;
&lt;?import javafx.scene.control.TableView?&gt;
&lt;?import javafx.scene.layout.AnchorPane?&gt;
&lt;?import javafx.scene.layout.HBox?&gt;
&lt;?import javafx.scene.layout.VBox?&gt;
&lt;?import org.rapidpm.demo.javafx.searchbox.searchbox.SearchBox?&gt;
&lt;fx:root type="gui.org.rapidpm.demo.javafx.searchbox.demo.SearchBoxDemoPane"
         fx:id="SearchBoxDemoPane" xmlns:fx="http://javafx.com/fxml" style="-fx-background-color:#EEEEEE"&gt;
    &lt;stylesheets&gt;
        &lt;url value="@/main.css"/&gt;
    &lt;/stylesheets&gt;
    &lt;children&gt;
        &lt;vbox AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0"&gt;
            &lt;hbox maxHeight="24.00" maxWidth="Infinity" VBox.vgrow="NEVER"&gt;
                &lt;searchbox fx:id="SearchBox" visible="true" minHeight="24.00" prefWidth="5000.0" maxWidth="-Infinity"/&gt;
            &lt;/HBox&gt;
            &lt;anchorpane minHeight="0.0" minWidth="0.0" VBox.vgrow="ALWAYS"
                        AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0"&gt;
                &lt;children&gt;
                    &lt;scrollpane fitToHeight="true" fitToWidth="true" AnchorPane.bottomAnchor="0.0"
                                AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0"&gt;
                        &lt;tableview fx:id="tableView" editable="true" VBox.vgrow="ALWAYS" style="-fx-font-size: 80%"
                                   tableMenuButtonVisible="true"&gt;
                            &lt;columns&gt;
                                &lt;tablecolumn prefWidth="120.0" text="id"&gt;
                                    &lt;cellvaluefactory&gt;
                                        &lt;propertyvaluefactory property="ID"/&gt;
                                    &lt;/cellValueFactory&gt;
                                &lt;/TableColumn&gt;
                                &lt;tablecolumn prefWidth="120.0" text="vorname"&gt;
                                    &lt;cellvaluefactory&gt;
                                        &lt;propertyvaluefactory property="vorname"/&gt;
                                    &lt;/cellValueFactory&gt;
                                &lt;/TableColumn&gt;
                                &lt;tablecolumn prefWidth="120.0" text="nachname"&gt;
                                    &lt;cellvaluefactory&gt;
                                        &lt;propertyvaluefactory property="nachname"/&gt;
                                    &lt;/cellValueFactory&gt;
                                &lt;/TableColumn&gt;
                                &lt;tablecolumn prefWidth="120.0" text="datum"&gt;
                                    &lt;cellvaluefactory&gt;
                                        &lt;propertyvaluefactory property="datum"/&gt;
                                    &lt;/cellValueFactory&gt;
                                &lt;/TableColumn&gt;
                                &lt;tablecolumn prefWidth="120.0" text="betrag"&gt;
                                    &lt;cellvaluefactory&gt;
                                        &lt;propertyvaluefactory property="betrag"/&gt;
                                    &lt;/cellValueFactory&gt;
                                &lt;/TableColumn&gt;
                            &lt;/columns&gt;
                        &lt;/TableView&gt;
                    &lt;/ScrollPane&gt;
                &lt;/children&gt;
            &lt;/AnchorPane&gt;
        &lt;/VBox&gt;
    &lt;/children&gt;
&lt;/fx:root&gt;

]]&gt;&lt;/script&gt;

Finally we are implementing the jUnit Test (&lt;a href="http://www.rapidpm.org/2013/08/cdicommonsfx-javafxcdi-bootstrap.html"&gt;more info about cdi javaFX bootstraping&lt;/a&gt;)&lt;br /&gt;
like this one.&lt;br /&gt;
&lt;br /&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class SearchBoxTest extends JavaFXBaseTest {
    @Override protected Class&lt;? extends JavaFXBaseTest&gt; getTestClass() {
        return SearchBoxTest.class;
    }

    public static class TestImpl extends JavaFXBaseTest.JavaFXBaseTestImpl {

        @Inject SearchBoxDemoPane root;
        @Inject DemoDataBuilder dataBuilder;

        @Override public boolean isExitAfterTest() {
            return false;
        }

        @Override protected Class&lt;? extends JavaFXBaseTest&gt; getParentTestClass() {
            return SearchBoxTest.class;
        }

        @Override public void testImpl(Stage stage) {
            stage.setTitle("SearchBoxTest");  //i18n
            stage.setScene(new Scene(root, 1024, 786));

            final SearchBoxDemoPaneController controller = root.getController();
            final ObservableList&lt;transientdemodatarow&gt; transientDemoDataRows = dataBuilder.create();
            controller.tableView.setItems(transientDemoDataRows);
            controller.SearchBox.refreshIndex(transientDemoDataRows);
        }
    }
}
]]&gt;&lt;/script&gt;

After this we have a full funktional combination between a full-text SearchBox and a TableView.&lt;br /&gt;
The SearchBox itself is working in this version with a transient Lucene-Index.&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://2.bp.blogspot.com/-O8e8Q0v6s90/Ui7Srr4pCkI/AAAAAAABTcQ/UJKEGo-evK4/s1600/search_step_01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://2.bp.blogspot.com/-O8e8Q0v6s90/Ui7Srr4pCkI/AAAAAAABTcQ/UJKEGo-evK4/s1600/search_step_01.jpg" height="171" width="320" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://3.bp.blogspot.com/-oOSZA0ASumQ/Ui7SrqsW-JI/AAAAAAABTcU/HqrSusRzrNw/s1600/search_step_02.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://3.bp.blogspot.com/-oOSZA0ASumQ/Ui7SrqsW-JI/AAAAAAABTcU/HqrSusRzrNw/s1600/search_step_02.jpg" height="171" width="320" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://1.bp.blogspot.com/-yp873G-WUjM/Ui7Srm3nH3I/AAAAAAABTcs/YyNnboufSgE/s1600/search_step_03.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://1.bp.blogspot.com/-yp873G-WUjM/Ui7Srm3nH3I/AAAAAAABTcs/YyNnboufSgE/s1600/search_step_03.jpg" height="170" width="320" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://1.bp.blogspot.com/-p4AJX4aNNWE/Ui7SsIn5yyI/AAAAAAABTcc/7qzRFXf1BE8/s1600/search_step_04.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://1.bp.blogspot.com/-p4AJX4aNNWE/Ui7SsIn5yyI/AAAAAAABTcc/7qzRFXf1BE8/s1600/search_step_04.jpg" height="170" width="320" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://1.bp.blogspot.com/-IX3WYgvaJJc/Ui7SsbXUntI/AAAAAAABTck/0QwrIf_nm1o/s1600/search_step_05.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://1.bp.blogspot.com/-IX3WYgvaJJc/Ui7SsbXUntI/AAAAAAABTck/0QwrIf_nm1o/s1600/search_step_05.jpg" height="170" width="320" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;span style="font-size: x-small;"&gt;&lt;i&gt;&lt;br /&gt;&lt;/i&gt;&lt;/span&gt;
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>11 lines of code for optimal col size (TableView)</title>
        <category label="JavaFX"/>
        <category label="RapidPM"/>
        <published>2013-09-11T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/09/11/11-lines-of-code-for-optimal-col-size-.html&gt;11 lines of code for optimal col size (TableView)&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-09-11 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
To combine the property &lt;b&gt;tableMenuButtonVisible&lt;/b&gt;="true" from the TableView with the column.&lt;b&gt;prefWidthProperty&lt;/b&gt;() you need not more than 11 lines of code. The result will be a TableView with automatic resizing columns if you are hiding one ore more columns and reverse.&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
        //set optimal size
        final ObservableList&lt;TableColumn&lt;TransientDemoDataRow, ?&gt;&gt; columns = tableView.getColumns();
        final ObservableList&lt;TableColumn&lt;TransientDemoDataRow, ?&gt;&gt; visibleLeafColumns = tableView.getVisibleLeafColumns();
        final int size = visibleLeafColumns.size();
        final SimpleDoubleProperty newSizeProperty = new SimpleDoubleProperty(size);
        visibleLeafColumns.addListener(new ListChangeListener&lt;TableColumn&lt;TransientDemoDataRow, ?&gt;&gt;() {
            @Override public void onChanged(Change&lt;? extends TableColumn&lt;TransientDemoDataRow, ?&gt;&gt; change) {
                final int newSize = change.getList().size();
                newSizeProperty.set(newSize);
            }
        });
        for (final TableColumn&lt;TransientDemoDataRow, ?&gt; column : columns) {
            column.prefWidthProperty().bind(tableView.widthProperty().divide(newSizeProperty));
        }
]]&gt;&lt;/script&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://3.bp.blogspot.com/-EQXJrt8k68w/UjA_-XKLRwI/AAAAAAABTdM/uoG3ewVQJrw/s1600/step01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://3.bp.blogspot.com/-EQXJrt8k68w/UjA_-XKLRwI/AAAAAAABTdM/uoG3ewVQJrw/s1600/step01.jpg" height="266" width="640" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://3.bp.blogspot.com/-C6xLs44_QCI/UjA_-ZVUSeI/AAAAAAABTdQ/pzoOckJdYkc/s1600/step02.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://3.bp.blogspot.com/-C6xLs44_QCI/UjA_-ZVUSeI/AAAAAAABTdQ/pzoOckJdYkc/s1600/step02.jpg" height="250" width="640" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://3.bp.blogspot.com/-mxpi-V1ddkY/UjA_-R66JUI/AAAAAAABTdU/zmQMvA_o-4U/s1600/step03.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://3.bp.blogspot.com/-mxpi-V1ddkY/UjA_-R66JUI/AAAAAAABTdU/zmQMvA_o-4U/s1600/step03.jpg" height="250" width="640" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br /&gt;
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>CDI Callback&lt;TableColumn, TableCell&gt; cellFactory - from FXML</title>
        <category label="Callback"/>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="JavaFX"/>
        <category label="RapidPM"/>
        <category label="TableView"/>
        <published>2013-09-19T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/09/19/cdi-callback-tablecolumn-tablecell-cel.html&gt;CDI Callback&lt;TableColumn, TableCell&gt; cellFactory - from FXML&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-09-19 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
How to get a full managed JavaFX-element declared in the fxml-file?&lt;br/&gt;

Let´s say we have something like the following:&lt;br/&gt;

&lt;script class="brush: javafx" type="syntaxhighlighter"&gt;&lt;![CDATA[
&lt;TableView fx:id="tableView" editable="true" VBox.vgrow="ALWAYS" style="-fx-font-size: 80%"
                   tableMenuButtonVisible="true"&gt;
    &lt;columns&gt;
        &lt;FilterableStringTableColumn prefWidth="120.0" text="vorname"&gt;
            &lt;cellFactory&gt;
                &lt;EditingAutoCompleteStringCellFactory/&gt;
            &lt;/cellFactory&gt;
            &lt;cellValueFactory&gt;
                &lt;PropertyValueFactory property="vorname"/&gt;
            &lt;/cellValueFactory&gt;
        &lt;/FilterableStringTableColumn&gt;
        &lt;FilterableStringTableColumn prefWidth="120.0" text="nachname"&gt;
            &lt;cellFactory&gt;
                &lt;EditingStringCellFactoryCallback/&gt;
            &lt;/cellFactory&gt;
            &lt;cellValueFactory&gt;
                &lt;PropertyValueFactory property="nachname"/&gt;
            &lt;/cellValueFactory&gt;
        &lt;/FilterableStringTableColumn&gt;
        &lt;FilterableDateTableColumn prefWidth="120.0" text="datum"&gt;
            &lt;cellFactory&gt;
                &lt;EditingDateCellFactoryCallback/&gt;
            &lt;/cellFactory&gt;
            &lt;cellValueFactory&gt;
                &lt;PropertyValueFactory property="datum"/&gt;
            &lt;/cellValueFactory&gt;
        &lt;/FilterableDateTableColumn&gt;
        &lt;FilterableDoubleTableColumn prefWidth="120.0" text="betrag"&gt;
            &lt;cellValueFactory&gt;
                &lt;PropertyValueFactory property="betrag"/&gt;
            &lt;/cellValueFactory&gt;
        &lt;/FilterableDoubleTableColumn&gt;
    &lt;/columns&gt;
&lt;/TableView&gt;
]]&gt;&lt;/script&gt;

This looks like a normal definition of a TableView with some cell-factories.
The intressting part is the instantiating of the cellFactory elements. They are
created from the JavaFX part. How to get them as full managed bean?&lt;br/&gt;

Based on my blog entry about  (&lt;a href="http://www.rapidpm.org/2013/08/cdicommonsfx-javafxcdi-bootstrap.html"&gt;CDI-JavaFX bootstrapping&lt;/a&gt;) I wanted to have full cdi managed JavaFX elements but defined in my fxml-file.&lt;br/&gt;

How to get this with a ComboBoxCell you can see here (&lt;a href="http://www.rapidpm.org/2013/09/cdi-comboboxcell-how-to-reduce-80-of.html"&gt;cdi comboboxcell how to reduce 80 of code&lt;/a&gt;)&lt;br/&gt;

The aproach was to define an element that is able to associate itself as CellFactory.
Only two line of code are used during the init - phase:&lt;br/&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
@Inject Instance&lt;BetragComboboxCell&gt; betragComboBoxCellInstance;
 
private void initTable() {
    final BetragComboBoxCell cell = betragComboBoxCellInstance.get();
    cell.associateWithCol(tableView, "betrag");
}
]]&gt;&lt;/script&gt;


BUT: the definition inside the fxml-file is &lt;br/&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
        &lt;FilterableDoubleTableColumn prefWidth="120.0" text="betrag"&gt;
            &lt;cellValueFactory&gt;
                &lt;PropertyValueFactory property="betrag"/&gt;
            &lt;/cellValueFactory&gt;
        &lt;/FilterableDoubleTableColumn&gt;
]]&gt;&lt;/script&gt;

You only could (implicit)define a normal CellFactory, because the creation of this element would be done by JavaFX.&lt;br/&gt;

Now I want to write a more precise fxml file.&lt;br/&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
&lt;FilterableStringTableColumn prefWidth="120.0" text="vorname"&gt;
            &lt;cellFactory&gt;
                &lt;EditingAutoCompleteStringCellFactory/&gt;
            &lt;/cellFactory&gt;
            &lt;cellValueFactory&gt;
                &lt;PropertyValueFactory property="vorname"/&gt;
            &lt;/cellValueFactory&gt;
        &lt;/FilterableStringTableColumn&gt;
]]&gt;&lt;/script&gt;

Now you could see, the CellFactory is well defined. Here an EditingAutoCompleteStringCellFactory.
This is an element with injected autocomplete functions/data.&lt;br/&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class EditingAutoCompleteStringCellFactory 
                implements Callback&lt;TableColumn&lt;FilteredTableDataRow, ?&gt;,
                                      TableCell&lt;FilteredTableDataRow, ?&gt;&gt;
]]&gt;&lt;/script&gt;

Inside this class you can use all cdi features.&lt;br/&gt;

The missing part is: How to get this as managed instance?&lt;br/&gt;
The short answer is.. make it managed by yourself ;-)&lt;br/&gt;

Let´s say the controller is a managed instance, you can get the BeanManager with&lt;br/&gt;

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
@Inject BeanManager beanManager;
]]&gt;&lt;/script&gt;

Now I started to get during the init-phase the right column&lt;br/&gt;

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
final ObservableList&lt;TableColumn&lt;TransientDemoDataRow, ?&gt;&gt; columns = tableView.getColumns();
for (final TableColumn&lt;TransientDemoDataRow, ?&gt; column : columns) {
 if(column.getText().equals("vorname")){ 
   //do something on column
 } else{
  //nothing to do
 }
}
]]&gt;&lt;/script&gt;

After you found the right column, start with the CDI-stuff
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
final TableColumn&lt;TransientDemoDataRow, String&gt; columnString = (TableColumn&lt;TransientDemoDataRow, String&gt;) column;

final Callback&lt;? extends TableColumn&lt;TransientDemoDataRow, String&gt;, ? extends TableCell&lt;TransientDemoDataRow,String&gt;&gt; cellFactory = columnString.getCellFactory();

final AnnotatedType&lt;EditingAutoCompleteStringCellFactory&gt; annotationType = beanManager.createAnnotatedType(EditingAutoCompleteStringCellFactory.class);

final InjectionTarget injectionTarget = beanManager.createInjectionTarget(annotationType);

final CreationalContext&lt;EditingAutoCompleteStringCellFactory&gt; creationalContext = beanManager.createCreationalContext(null);

                injectionTarget.inject(cellFactory, creationalContext);
                injectionTarget.postConstruct(cellFactory);

]]&gt;&lt;/script&gt;

Ready..   but this code is not nice...  and done for every column this is toooooo much code.&lt;br/&gt;

So I started to reduce it.&lt;br/&gt;
- reducing the generics..&lt;br/&gt;
- getting the class from the instance itself&lt;br/&gt;

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
final Callback cellFactory = column.getCellFactory();
final AnnotatedType annotationType = beanManager.createAnnotatedType(cellFactory.getClass());
final InjectionTarget injectionTarget = beanManager.createInjectionTarget(annotationType);
final CreationalContext creationalContext = beanManager.createCreationalContext(null);
injectionTarget.inject(cellFactory, creationalContext);
injectionTarget.postConstruct(cellFactory);
]]&gt;&lt;/script&gt;

Done..  OK, this is short and easy..  and you can do it for every column..&lt;br/&gt;

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
final ObservableList&lt;TableColumn&lt;TransientDemoDataRow, ?&gt;&gt; columns = tableView.getColumns();
for (final TableColumn&lt;TransientDemoDataRow, ?&gt; column : columns) {
 final Callback cellFactory = column.getCellFactory();
 final AnnotatedType annotationType = beanManager.createAnnotatedType(cellFactory.getClass());
 final InjectionTarget injectionTarget = beanManager.createInjectionTarget(annotationType);
 final CreationalContext creationalContext = beanManager.createCreationalContext(null);
 injectionTarget.inject(cellFactory, creationalContext);
 injectionTarget.postConstruct(cellFactory);
}
]]&gt;&lt;/script&gt;

or more generic...&lt;br/&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
final ObservableList&lt;TableColumn&lt;?, ?&gt;&gt; columns = tableView.getColumns();
for (final TableColumn&lt;?, ?&gt; column : columns) {
 final Callback cellFactory = column.getCellFactory();
 final AnnotatedType annotationType = beanManager.createAnnotatedType(cellFactory.getClass());
 final InjectionTarget injectionTarget = beanManager.createInjectionTarget(annotationType);
 final CreationalContext creationalContext = beanManager.createCreationalContext(null);
 injectionTarget.inject(cellFactory, creationalContext);
 injectionTarget.postConstruct(cellFactory);
}
]]&gt;&lt;/script&gt;

Now you can use CDI-managed elements as CellFactories and define them inside your fxml. &lt;br/&gt;

Nice, Managed and TypeSave&lt;br/&gt;
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>CDI ButtonCell</title>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="JavaFX"/>
        <category label="RapidPM"/>
        <category label="TableView"/>
        <category label="Weld"/>
        <published>2013-10-02T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/10/02/cdi-buttoncell.html&gt;CDI ButtonCell&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-10-02 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
&lt;div style="text-align: center;"&gt;
    &lt;i&gt;&lt;span style="font-size: x-small;"&gt;The full code and demo jUnit you will find under :&amp;nbsp;&lt;a href="https://bitbucket.org/rapidpm/modules/src/6e440e241875/javafx-filtered-tableview?at=release/1.1.1" target="_blank"&gt;BitBucket Repo - RapidPM - Modules - javafx-filtered-tableview&lt;/a&gt;&amp;nbsp;&lt;/span&gt;&lt;/i&gt;&lt;/div&gt;
&lt;div style="text-align: center;"&gt;
    &lt;i&gt;&lt;span style="font-size: x-small;"&gt;Please use the release/1.1.1 branch and a commit after&amp;nbsp;&lt;a href="https://bitbucket.org/rapidpm/modules/commits/6e440e241875c2f574741bd1f0e0749054996326"&gt;6e440e2&lt;/a&gt;&amp;nbsp;&lt;/span&gt;&lt;/i&gt;&lt;/div&gt;
&lt;br /&gt;

Today I needed a button inside my TableView.

Something needed to be activated, based on some other values in this row.

How to do this in a nice, lean and decoupled way? One goal was the possibillity that the definition could be done inside the fxml - file.

Let´s start with the basic cdi managed &lt;b&gt;ButtonCell&lt;/b&gt;:

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[ 
public abstract class ButtonCell&lt;T&gt; extends TableCell&lt;T, Boolean&gt; {

    public Button cellButton;
    public abstract String getButtonLabelText();
    private List&lt;ButtonCellAction&lt;T&gt;&gt; actionList = new ArrayList&lt;&gt;();

    private @Inject @CDILogger Logger logger;

    public ButtonCell() {

    }

    @PostConstruct
    public void init(){
        if (logger.isDebugEnabled()) {
            logger.debug("ButtonCell-&gt;init");
        }
        cellButton = new Button(getButtonLabelText());
        cellButton.setOnAction(new EventHandler&lt;ActionEvent&gt;() {
            @Override
            public void handle(ActionEvent t) {
                for (final ButtonCellAction&lt;T&gt; buttonCellAction : actionList) {
                    if (logger.isDebugEnabled()) {
                        logger.debug("execute buttonCellAction-&gt; " + buttonCellAction);
                    }
                    buttonCellAction.execute(ButtonCell.this, t);
                }
            }
        });
    }

    @Override
    protected void updateItem(Boolean t, boolean empty) {
        super.updateItem(t, empty);
        if (!empty) {
            setGraphic(cellButton);
        }
    }

    public static abstract class ButtonCellAction&lt;T&gt; {
        public abstract void execute(ButtonCell&lt;T&gt; buttonCell, ActionEvent t);
    }


    public List&lt;ButtonCellAction&lt;T&gt;&gt; getActionList() {
        return actionList;
    }
}
]]&gt;&lt;/script&gt;

The main part here is the method &lt;b&gt;setOnAction()&lt;/b&gt;: With this we are iterating over a list of ButtonCellActions.
&lt;br/&gt;
Now we have to implement a class for our used TableView. In this example an simple delete-button.
&lt;br/&gt;

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class DeleteButtonCell extends ButtonCell&lt;TransientDemoDataRow&gt; {

    private @Inject @CDILogger Logger logger;
    private @Inject @CDIPropertyRegistryService PropertyRegistryService propertyRegistryService;
    private @Inject DeleteButtonLogic logic;

    @Override public String getButtonLabelText() {
        return propertyRegistryService.getRessourceForKey("delete");
    }

    public DeleteButtonCell() {

    }

    @PostConstruct
    public void init(){
        super.init();
        if (logger.isDebugEnabled()) {
            logger.debug("DeleteButtonCell-&gt;init");
        }
        getActionList().add(new ButtonCellAction&lt;TransientDemoDataRow&gt;() {
            @Override public void execute(ButtonCell&lt;TransientDemoDataRow&gt; buttonCell, ActionEvent t) {
                if (logger.isDebugEnabled()) {
                    final Object source = t.getSource();
                    logger.debug("ButtonCellAction -&gt; " + source);
                }
                final TableRow tableRow = buttonCell.getTableRow();
            }
        });
    }
}
]]&gt;&lt;/script&gt;

At this point we are able to inject all the needed logic (here :&lt;b&gt;DeleteButtonLogic&lt;/b&gt;) to fullfill our task. The logic will be activated inside an implementtion of the class &lt;b&gt;ButtonCellAction&lt;/b&gt;. The order you are filling the Actions is the order the actions are processed. quite easy and mostly all you need.
&lt;br/&gt;
The implementation is easy, but we want to put this to an fxml file like the following?:

&lt;script class="brush: javafx" type="syntaxhighlighter"&gt;&lt;![CDATA[
&lt;TableColumn text="tcdelete" sortable="false"&gt;
 &lt;cellFactory&gt;
  &lt;DeleteButtonCellFactory/&gt;
 &lt;/cellFactory&gt;
 &lt;cellValueFactory&gt;
  &lt;DeleteButtonCellValueFactory/&gt;
 &lt;/cellValueFactory&gt;
&lt;/TableColumn&gt;
]]&gt;&lt;/script&gt;

For this we need the CellFactory and the CellValueFactory.
Both implementations are small:

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class DeleteButtonCellFactory
        implements Callback&lt;TableColumn&lt;TransientDemoDataRow, ?&gt;, TableCell&lt;TransientDemoDataRow, ?&gt;&gt; {

    @Inject Instance&lt;DeleteButtonCell&gt;  deleteButtonCellInstance;

    public DeleteButtonCellFactory() {
        CDIContainerSingleton.getInstance().activateCDI(this);
    }

    @Override public TableCell&lt;TransientDemoDataRow, ?&gt; call(TableColumn&lt;TransientDemoDataRow, ?&gt; column) {
        return deleteButtonCellInstance.get();
    }
}
]]&gt;&lt;/script&gt;

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class DeleteButtonCellValueFactory
        implements Callback&lt;TableColumn.CellDataFeatures&lt;TransientDemoDataRow, Boolean&gt;,ObservableValue&lt;Boolean&gt;&gt; {


    @Override public ObservableValue&lt;Boolean&gt; call(TableColumn.CellDataFeatures&lt;TransientDemoDataRow, Boolean&gt; p) {
        final TransientDemoDataRow value = p.getValue();
        return new SimpleBooleanProperty(value != null);
    }
}
]]&gt;&lt;/script&gt;

This is all..  and the result is nice and clean..
&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://4.bp.blogspot.com/-2UVVaH6biHA/Ukw537ReTJI/AAAAAAABUVc/mULLql4jTi0/s1600/uml-buttoncell.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://4.bp.blogspot.com/-2UVVaH6biHA/Ukw537ReTJI/AAAAAAABUVc/mULLql4jTi0/s400/uml-buttoncell.png" /&gt;&lt;/a&gt;&lt;/div&gt;

 
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>complex PropertyBindings</title>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="Java"/>
        <category label="JavaFX"/>
        <category label="PropertyBinding"/>
        <category label="RapidPM"/>
        <published>2013-10-08T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/10/08/complex-propertybindings.html&gt;complex PropertyBindings&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-10-08 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
Today I had to deal with different dependent input-fields.
&lt;br/&gt;
Let´s say you have (only) two TextFields, leftTextField and rightTextField.
If you writing something into the left TextField you have to calculate something (Logic A) and write it to the right TextField.
If you are writing to the right one you have to calculate something (Logic B) and write it to the left TextField.
&lt;br/&gt;
This example is quite simple, but if you have to deal with a lot of fields with different deps based on a transient context
you have to solve:
&lt;br/&gt;
- cycles between the different components.
&lt;br/&gt;
- in this case, the transient context that was changing the logic (here Logic A and Logic B).
&lt;br/&gt;
&lt;br/&gt;
First the component called PairedTextField.
&lt;br/&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[ 
public class PairedTextField extends Pane {

    private final TextField leftTextField = new TextField();
    private final TextField rightTextField = new TextField();

    private final HBox hb = new HBox();
    private int spacing = 10;

    public PairedTextField() {
        setAnchors(hb, 0.0);
        hb.getChildren().addAll(leftTextField, rightTextField);
        hb.setSpacing(spacing);
        getChildren().add(hb);
        setPadding(new Insets(0, 10, 0, 10));
    }

    private void setAnchors(Node node , Double anchor){
        AnchorPane.setBottomAnchor(node, anchor);
        AnchorPane.setLeftAnchor(node, anchor);
        AnchorPane.setRightAnchor(node, anchor);
        AnchorPane.setTopAnchor(node, anchor);
    }
}

]]&gt;&lt;/script&gt;

Now, how to bind both TextFields to get the result?
If you are binding bidirectional you will get a Stackoverflow. To solve this you can do something like the following:
&lt;br/&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
leftTextField.setOnKeyTyped(new EventHandler&lt;KeyEvent&gt;() {
            @Override public void handle(KeyEvent keyEvent) {
                rightTextField.textProperty().bind(leftTextFieldBinding);
            }
        });
        leftTextField.setOnKeyReleased(new EventHandler&lt;KeyEvent&gt;() {
            @Override public void handle(KeyEvent keyEvent) {
                rightTextField.textProperty().unbind();
            }
        });

        rightTextField.setOnKeyTyped(new EventHandler&lt;KeyEvent&gt;() {
            @Override public void handle(KeyEvent keyEvent) {
                leftTextField.textProperty().bind(rigthTextFieldBinding);
            }
        });
        rightTextField.setOnKeyReleased(new EventHandler&lt;KeyEvent&gt;() {
            @Override public void handle(KeyEvent keyEvent) {
                leftTextField.textProperty().unbind();
            }
        });
 ]]&gt;&lt;/script&gt;

This simple solution is working well. Binding if you need it, unbind after this. Thanks to JavaFX PropertyBinding ;-)
Finally we have to deal with the different implementations of the logic-part for every request.
&lt;br/&gt;
The class Bindings will give you the method createStringBinding(Callable, Property), with this you can create the Bindings (leftTextFieldBinding, rigthTextFieldBinding).
What you need now is the implementation of the Callable&lt;String&gt;. If you are doing it in the "normal" way you have to write it like the following
    &lt;br/&gt;
    &lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class LeftTextFieldBindingCallable extends Callable&lt;String&gt;{
    final DemoLogic demoLogic = new DemoLogic();

    @Override public String call() throws Exception {
        return "leftTextField - " + demoLogic.doIt();
    }
}
]]&gt;&lt;/script&gt;

    With this solution you are not able to switch the implementation of the attribute "demoLogic". Nicer would be something like
    &lt;br/&gt;
    &lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class LeftTextFieldBindingCallable extends CDICallable&lt;String&gt;{
    @Inject Instance&lt;DemoLogic&gt; demoLogic;

    @Override public String call() throws Exception {
        return "leftTextField - " + demoLogic.get().doIt();
    }
}
]]&gt;&lt;/script&gt;

    With every request you will get the possibility to change the implementation of DemoLogic. The Producer will decide wich implementation will be used.
    &lt;br/&gt;
    &lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class DemoLogicProducer {

    @Produces
    public DemoLogic create(BeanManager beanManager, InjectionPoint injectionPoint){
        //decide which implementation to use...
        //here simple version..
        return  new DemoLogic();
    }
}
]]&gt;&lt;/script&gt;
    &lt;br/&gt;
    Now, putting all together:
    &lt;br/&gt;
    &lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class PairedTextField extends Pane {

    private final TextField leftTextField = new TextField();
    private final TextField rightTextField = new TextField();

    private final HBox hb = new HBox();
    private int spacing = 10;

    @Inject Instance&lt;LeftTextFieldBindingCallable&gt; leftTextFieldBindingCallableInstance;
    @Inject Instance&lt;RightTextFieldBindingCallable&gt; rightTextFieldBindingCallableInstance;


    public PairedTextField() {
        setAnchors(hb, 0.0);
        hb.getChildren().addAll(leftTextField, rightTextField);
        hb.setSpacing(spacing);
        getChildren().add(hb);
        setPadding(new Insets(0, 10, 0, 10));

        CDIContainerSingleton.getInstance().activateCDI(this);

    }

    @PostConstruct
    public void init(){
        final StringBinding leftTextFieldBinding = Bindings.createStringBinding(leftTextFieldBindingCallableInstance.get(), leftTextField.textProperty());

        final StringBinding rigthTextFieldBinding = Bindings.createStringBinding(rightTextFieldBindingCallableInstance.get(), rightTextField.textProperty());


        leftTextField.setOnKeyTyped(new EventHandler&lt;KeyEvent&gt;() {
            @Override public void handle(KeyEvent keyEvent) {
                rightTextField.textProperty().bind(leftTextFieldBinding);
            }
        });
        leftTextField.setOnKeyReleased(new EventHandler&lt;KeyEvent&gt;() {
            @Override public void handle(KeyEvent keyEvent) {
                rightTextField.textProperty().unbind();
            }
        });

        rightTextField.setOnKeyTyped(new EventHandler&lt;KeyEvent&gt;() {
            @Override public void handle(KeyEvent keyEvent) {
                leftTextField.textProperty().bind(rigthTextFieldBinding);
            }
        });
        rightTextField.setOnKeyReleased(new EventHandler&lt;KeyEvent&gt;() {
            @Override public void handle(KeyEvent keyEvent) {
                leftTextField.textProperty().unbind();
            }
        });
    }


    private void setAnchors(Node node , Double anchor){
        AnchorPane.setBottomAnchor(node, anchor);
        AnchorPane.setLeftAnchor(node, anchor);
        AnchorPane.setRightAnchor(node, anchor);
        AnchorPane.setTopAnchor(node, anchor);
    }
}
]]&gt;&lt;/script&gt;
    &lt;br/&gt;
    The importand parts are:
    &lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[

public abstract class  CDICallable&lt;T&gt; implements Callable&lt;T&gt; {
    protected CDICallable() {
        CDIContainerSingleton.getInstance().activateCDI(this);
    }
}

//...
CDIContainerSingleton.getInstance().activateCDI(this);
//..
 
        final StringBinding leftTextFieldBinding = Bindings.createStringBinding(leftTextFieldBindingCallableInstance.get(), leftTextField.textProperty());

        final StringBinding rigthTextFieldBinding = Bindings.createStringBinding(rightTextFieldBindingCallableInstance.get(), rightTextField.textProperty());


]]&gt;&lt;/script&gt;

    &lt;br/&gt;
    &lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://1.bp.blogspot.com/-VJn5X9vrTig/UlQZiDC4LfI/AAAAAAABUV4/GKtv6srW2SY/s1600/diagram.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://1.bp.blogspot.com/-VJn5X9vrTig/UlQZiDC4LfI/AAAAAAABUV4/GKtv6srW2SY/s400/diagram.png" /&gt;&lt;/a&gt;&lt;/div&gt;


&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>use Kotlin inside JavaFX with CDI</title>
        <category label="Callback"/>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="JavaFX"/>
        <category label="Kotlin"/>
        <published>2013-10-09T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/10/09/use-kotlin-inside-javafx-with-cdi.html&gt;use Kotlin inside JavaFX with CDI&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-10-09 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
I tried the combination of JavaFX with CDI and injection of &lt;a href="http://kotlin.jetbrains.org/"&gt;Kotlin&lt;/a&gt; and it works very well.
&lt;br/&gt;
First the CDI - managed Callable
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[ 
public abstract class CDICallable&lt;T&gt; implements Callable&lt;T&gt; {
    protected CDICallable() {
        CDIContainerSingleton.getInstance().activateCDI(this);
    }
}
]]&gt;&lt;/script&gt;
&lt;br/&gt;
Second the TextFieldBindingCallable for the JavaFX-binding
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class LeftTextFieldBindingCallable extends CDICallable&lt;String&gt; {

    @Inject Instance&lt;DemoLogic&gt; demoLogic;

    @Override public String call() throws Exception {
        return "leftTextField - " + demoLogic.get().doIt();
    }
}
]]&gt;&lt;/script&gt;
&lt;br/&gt;
Third the implementation of the DemoLogic

Java - Version
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class DemoLogic {

    public String doIt() {
        return System.nanoTime() + "";
    }
}
]]&gt;&lt;/script&gt;
&lt;br/&gt;
changed to &lt;b&gt;Kotlin&lt;/b&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public open class DemoLogic() {
    public open fun doIt(): String? {
        return System.nanoTime().toString()  ;
    }
}
]]&gt;&lt;/script&gt;
&lt;br/&gt;

The code with the @Inject of DemoLogic isn´t changed inside the class &lt;b&gt;LeftTextFieldBindingCallable&lt;/b&gt;
and it is running well..
&lt;/br&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class PairedTextField extends Pane {

    private final TextField leftTextField = new TextField();
    private final TextField rightTextField = new TextField();

    private final HBox hb = new HBox();
    private int spacing = 10;

    @Inject Instance&lt;LeftTextFieldBindingCallable&gt; leftTextFieldBindingCallableInstance;
    @Inject Instance&lt;RightTextFieldBindingCallable&gt; rightTextFieldBindingCallableInstance;


    public PairedTextField() {
        setAnchors(hb, 0.0);
        hb.getChildren().addAll(leftTextField, rightTextField);
        hb.setSpacing(spacing);
        getChildren().add(hb);
        setPadding(new Insets(0, 10, 0, 10));

        CDIContainerSingleton.getInstance().activateCDI(this);

    }

    @PostConstruct
    public void init() {
        final StringBinding leftTextFieldBinding = Bindings.createStringBinding(leftTextFieldBindingCallableInstance.get(), leftTextField.textProperty());

        final StringBinding rigthTextFieldBinding = Bindings.createStringBinding(rightTextFieldBindingCallableInstance.get(), rightTextField.textProperty());


        leftTextField.setOnKeyTyped(new EventHandler&lt;KeyEvent&gt;() {
            @Override public void handle(KeyEvent keyEvent) {
                rightTextField.textProperty().bind(leftTextFieldBinding);
            }
        });
        leftTextField.setOnKeyReleased(new EventHandler&lt;KeyEvent&gt;() {
            @Override public void handle(KeyEvent keyEvent) {
                rightTextField.textProperty().unbind();
            }
        });

        rightTextField.setOnKeyTyped(new EventHandler&lt;KeyEvent&gt;() {
            @Override public void handle(KeyEvent keyEvent) {
                leftTextField.textProperty().bind(rigthTextFieldBinding);
            }
        });
        rightTextField.setOnKeyReleased(new EventHandler&lt;KeyEvent&gt;() {
            @Override public void handle(KeyEvent keyEvent) {
                leftTextField.textProperty().unbind();
            }
        });
    }


    private void setAnchors(Node node, Double anchor) {
        AnchorPane.setBottomAnchor(node, anchor);
        AnchorPane.setLeftAnchor(node, anchor);
        AnchorPane.setRightAnchor(node, anchor);
        AnchorPane.setTopAnchor(node, anchor);
    }
}
]]&gt;&lt;/script&gt;
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>The power of the ContextResolver Part I</title>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="JavaFX"/>
        <category label="RapidPM"/>
        <published>2013-10-17T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/10/17/the-power-of-the-contextresolver-part-.html&gt;The power of the ContextResolver Part I&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-10-17 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
How to use a ContextResolver? What can you do with this?
&lt;br/&gt;
Let´s say you have something like the following:

&lt;pre class="brush: java"&gt;
@Inject @DemoLogicContext DemoLogic demologic;
&lt;/pre&gt;

But it depends on the transient context of the application to decide what is the right implementation of the interface DemoLogic.
&lt;br/&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://2.bp.blogspot.com/-duqsdVLfujI/Ul66G0S0ZdI/AAAAAAABUXc/75QGLk5n0tk/s1600/DemoLogic.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://2.bp.blogspot.com/-duqsdVLfujI/Ul66G0S0ZdI/AAAAAAABUXc/75QGLk5n0tk/s400/DemoLogic.jpg" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br/&gt;
The implementation DemoLogicB is a normal JavaClass, KotlinDemoLogic is writen in &lt;a href="http://kotlin.jetbrains.org/"&gt;Kotlin&lt;/a&gt;.
Both implementations are paired with a qualifier and a producer like the following in the picture.
&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://2.bp.blogspot.com/-Gcbyha4grzI/Ul688KeBy6I/AAAAAAABUXo/TyTdcQC4VnY/s1600/DemoLogicB.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://2.bp.blogspot.com/-Gcbyha4grzI/Ul688KeBy6I/AAAAAAABUXo/TyTdcQC4VnY/s400/DemoLogicB.jpg" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br/&gt;
At this point you have n implementations with n qualiefiers and maybe n producer. Or it must be possible to extend the running system with a few more different customer dependent implementations. To write this inside your code with an big if else tree it is not a good style. From the busineslogic point of view the right definition is:
&lt;pre class="brush: java"&gt;
@Inject @DemoLogicContext DemoLogic demologic;
&lt;/pre&gt;
&lt;br/&gt;
For this you can use the producer methods from cdi. The way is quite easy:

&lt;pre class="brush: java"&gt;
@Produces @DemoLogicContext
public DemoLogic create(){...}
&lt;/pre&gt;
With this you have the entry-point for the final injection point. You can extend the signature of the create method with more attributes. Mostly used is the BeanManager and/or InjectioPoint, but you can use your own classes. For example the &lt;b&gt;ContextResolver&lt;/b&gt;.

&lt;pre class="brush: java"&gt;
@Produces @DemoLogicContext
public DemoLogic create(ContextResolver contextResolver){...}
&lt;/pre&gt;
The ContextResolver itself is an interface.. this means you have to use an qualifier to define the producer or implementing class for this interface.
&lt;pre class="brush: java"&gt;
@Produces @DemoLogicContext
public DemoLogic create(@DemoLogicContext ContextResolver contextResolver){...}
&lt;/pre&gt;

&lt;br/&gt;
Now we have to implement the first class, called DemoContextResolver. The DemoContextResolver will be injected into every producer that must be able to decide something.
&lt;pre class="brush: java"&gt;
public class DemoLogicProducer {
    private @Inject ManagedInstanceCreator creator;

    @Produces @DemoLogicContext
    public DemoLogic create(@New DemoContextResolver contextResolver){
        final Class&lt;DemoLogic&gt; beanType = DemoLogic.class;
    final AnnotationLiteral annotationLiteral = contextResolver.resolveContext(beanType);
    final DemoLogic demoLogic = creator.getManagedInstance(beanType, annotationLiteral);
    return demoLogic;
    }
    }
&lt;/pre&gt;
From this point you are able to decide what will be the implementation to use. For this example I wrote a very simple
version, but you can extend this to a tree of deciding ContextResolvers.
&lt;pre class="brush: java"&gt;
public class DemoContextResolver implements ContextResolver {

    @Inject DemoContext demoContext;

    @Override public AnnotationLiteral resolveContext(Class&lt;?&gt; targetClass) {
        if(demoContext.getContextInfo()){
            return new AnnotationLiteral&lt;KotlinDemoLogicContext&gt;() {};
    } else{
    return new AnnotationLiteral&lt;DemoLogicContextB&gt;() {};
        }
        }
        }
&lt;/pre&gt;


The good thing is, that every module will be usable for itself. You can write jUnit-Tests per implementation. At runtime you can add more implementations.

Think about the possibility to change the controller for a GUI in this way ;-)
I will show this more in detail in my next blog entry (Part II)
&lt;br/&gt;

&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://2.bp.blogspot.com/-pvUtFOprIyE/Ul-dDY48llI/AAAAAAABUX4/_HjQF9mLpyE/s1600/full-uml.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://2.bp.blogspot.com/-pvUtFOprIyE/Ul-dDY48llI/AAAAAAABUX4/_HjQF9mLpyE/s400/full-uml.png" /&gt;&lt;/a&gt;&lt;/div&gt;



&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>New series about JavaFX and CDI [GER]</title>
        <category label="CDI"/>
        <category label="JavaFX"/>
        <category label="JAXenter.de"/>
        <published>2013-10-23T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/10/23/new-series-about-javafx-and-cdi-[ger].html&gt;New series about JavaFX and CDI [GER]&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-10-23 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
Today we started the new series about JavaFX and CDI at JAXenter.de.
&lt;a href="http://jaxenter.de/Developer-Cafe-168241"&gt;http://jaxenter.de/Developer-Cafe-168241&lt;/a&gt;

&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>JAXenter.de - articles about CDI and JavaFX [GER]</title>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="JavaFX"/>
        <category label="JAXenter.de"/>
        <category label="Weld"/>
        <published>2013-10-31T00:00:00+01:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/10/31/jaxenter.de-articles-about-cdi-and-jav.html&gt;JAXenter.de - articles about CDI and JavaFX [GER]&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-10-31 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
All articles [GER] are available under :&amp;nbsp;&lt;a href="http://jaxenter.de/Developer-Cafe-168241"&gt;http://jaxenter.de/Developer-Cafe-168241&lt;/a&gt;&lt;br /&gt;
The series is about CDI and JavaFX in combination. First we are writing about the needed CDI basics and best-practices we need for the CDI/JavaFX bootstrapping.&lt;br /&gt;
&lt;br /&gt;
&lt;a href="http://jaxenter.de/artikel/CDI-lean-fuer-Alt-Neu-168240"&gt;0001 - CDI – lean für Alt und Neu&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://jaxenter.de/artikel/CDI-entscheide-spaet-entscheide-gut-168301"&gt;0002 - CDI – entscheide spät, entscheide gut&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://jaxenter.de/artikel/CDI-teile-reduziere-168466"&gt;0003 - CDI – teile und reduziere&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>SpeedUp from Charts with Streams</title>
        <category label="JavaFX"/>
        <category label="JDK8"/>
        <category label="Streams"/>
        <published>2013-11-09T00:00:00+01:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/11/09/speedup-from-charts-with-streams.html&gt;SpeedUp from Charts with Streams&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-11-09 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
Today we I am writing about the possibillity to speedup the JavaFX GUI elements with the new streams-API from JDK8.
&lt;br /&gt;
Let´s play with the original example from Oracle. The LineChart demo will be used as base for the following.
We are collecting/generating values for a line of points for every hundreds step. Al steps between are interpolated with splines.
For calculating the splines I am using the jakarta-commons math3 lib.&lt;a href="http://commons.apache.org/proper/commons-math/"&gt; [1]&lt;/a&gt;&lt;br /&gt;
Normaly the following steps are needed to generate a LineChart.
- get the base values to show&lt;br /&gt;
- calculate the interpolated values&lt;br /&gt;
- create the line-elements&lt;br /&gt;
- fill the Line-Chart and show it&lt;br /&gt;
&lt;br /&gt;

&lt;b&gt;Get the base values to show&lt;/b&gt;&lt;br /&gt;

For this example we are generating the values we are needing. To hold the values for a List of curves
I am using a
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
List&lt;List&lt;Integer&gt;&gt;
]]&gt;&lt;/script&gt;

Without streams you could do it like this:
&lt;br /&gt;

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public List&lt;List&lt;Integer&gt;&gt; generateDemoValueMatrix(){
final List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
   for (int i = 0; i&lt;200; i++){
   	final List&lt;Integer&gt; generatedDemoValuesForY = generateDemoValuesForY();
        	result.add(generatedDemoValuesForY);            
}
   	return result;
}

public List&lt;Integer&gt; generateDemoValuesForY(){
final Random random = new Random();
   final List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
   for(int i = 0; i&lt;10; i++){
   	result.add(random.nextInt(100));
   }
   return result;
}
]]&gt;&lt;/script&gt;

But with streams I could write this in a more compact form.
The nice here is the possibility to concat the single steps. But this is only to show the new streams api.
There is no parallel part.

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public List&lt;List&lt;Integer&gt;&gt; generateDemoValueMatrix(){
return Stream
   	.generate(this::generateDemoValuesForY)
         .limit(200)	//Anzahl Kurven
         .collect(Collectors.toList());
}

public List&lt;Integer&gt; generateDemoValuesForY(){
final Random random = new Random();
   return Stream
   	.generate(() -&gt; random.nextInt(100))
         .limit(10)
         .collect(Collectors.toList());
}
]]&gt;&lt;/script&gt;
&lt;b&gt; Calculate the interpolated values &lt;/b&gt;

Now I will start to caclculate the interpolated values. For this I am using the commons-math3 lib from Apache.
The way to do this is short and straid forward.
- Get the base values from the curve you want to calculate on &lt;br /&gt;
- Choose the algorithm you want to use&lt;br /&gt;
- Fill the base values as init into the function&lt;br /&gt;

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
private UnivariateFunction createInterpolateFunction(
final List&lt;Integer&gt; values){

   final double[] valueArrayX = new double[values.size()];
   for (int i = 0; i &lt; valueArrayX.length; i++) {
   	valueArrayX[i] = (double)i* STEP_SIZE;
  	}

   final double[] valueArrayY = new double[values.size()];
   int i=0;
   for (final Integer value : values) {
   	valueArrayY[i] = (double) value.intValue();
         i= i+1;
  	}

   final UnivariateInterpolator interpolator = 
new SplineInterpolator();
   final UnivariateFunction function = 
interpolator.interpolate(valueArrayX, valueArrayY);
  	return function;
}
]]&gt;&lt;/script&gt;

Now we are able to caculate the interpolated values.
This is something we can do in parallel for every curve. This means that we can start with the speed up.
The importand parts are the
".parallelStream()" to start a Thread for eveery elements of the List
and during the "map(v-&amp;gt; ... )" phase the calculation is done. Every task is put to the Root - Fork-And-Join Pool.

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
private List&lt;List&lt;Double&gt;&gt; getValuesForSeries() {
final List&lt;List&lt;Integer&gt;&gt; demoValueMatrix =
generateDemoValueMatrix();
   final List&lt;List&lt;Double&gt;&gt; collect = demoValueMatrix
   	.parallelStream()
         	.map(v -&gt; {
         		final UnivariateFunction interpolateFunction = 
createInterpolateFunction(v);
              	//baue Kurve auf
                final int anzahlValuesInterpolated = 
(v.size()-1) * STEP_SIZE;
               	final List&lt;Double&gt; result = new ArrayList&lt;&gt;();
                for (int i = 0; i &lt; anzahlValuesInterpolated-1; i++) {
                	final double valueForY = 
interpolateFunction.value(i);
                     	result.add(valueForY);
              	}
                return result;
       	})
         .collect(Collectors.toList());
return collect;
}

]]&gt;&lt;/script&gt;
&lt;b&gt;Create the line-elements&lt;/b&gt;

The grafical elements for the Line-Chart are created in the same way. In parallel for every curve.

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[

private List&lt;XYChart.Series&gt; generateNextSeries(){
final List&lt;XYChart.Series&gt; chartSeries = getValuesForSeries()
   	.parallelStream()
         	.map(v -&gt; {
        		final XYChart.Series nextSeries = new XYChart.Series();
               	int i = 0;
                for (final Double valueForY : v) {
                	final XYChart.Data data 
= new XYChart.Data(i, valueForY);
                  	nextSeries.getData().add(data);
                     	i = i + 1;
              	}
                return nextSeries;
        	}).collect(Collectors.toList());
   return chartSeries;
}
]]&gt;&lt;/script&gt;
&lt;b&gt; Fill the Line-Chart and show it&lt;/b&gt;

Now the last step is the filling of the Line-Chart itself.
This is done in a seriel way. No parralel way is possible in the moment.
But this is not the part that could bring a speed-up.

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
final List&lt;XYChart.Series&gt; serieses = generateNextSeries();
final ObservableList&lt;XYChart.Series&gt; data = lineChart.getData();
data.addAll(serieses);
]]&gt;&lt;/script&gt;

&lt;b&gt; Lesson Learned&lt;/b&gt;


What we can see is the possibillity to speed up the GUI part in several ways.
Not only the generating of the values itself. The creation of the grafical elements could be done in parralel too.
The seriell Version LineChartSerialDemo, needed for the 11´th round 2.799.209.417ns and the parralel version
LineChartDemo was done in 261.545.220ns.
This is a speed up of 10 at my MacBookPro.

Happy coding..








&lt;!--10--&gt;&lt;/integer&gt;&lt;/integer&gt;&lt;!--200--&gt;&lt;/list&gt;&lt;/list&gt;&lt;/pre&gt;
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>Adam Bien´s afterburner.fx internals explained</title>
        <category label="Adam Bien afterburner.fx"/>
        <category label="CDI"/>
        <category label="dependency injection"/>
        <category label="JavaFX"/>
        <category label="MVP"/>
        <category label="relection"/>
        <published>2013-12-09T00:00:00+01:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/12/09/adam-biens-afterburner.fx-internals-ex.html&gt;Adam Bien´s afterburner.fx internals explained&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-12-09 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
Today I am writing about Adam´s framework afterburner.fx.
This is a MVP framework for dependency injection into JavaFX apps.
It is very small, containing only two classes.&lt;br /&gt;
&lt;br /&gt;
What could you do with this afternburner.fx? What are the restrictions?&lt;br /&gt;
&lt;br /&gt;
Let´s start with the project init. You will need only a normal pom.xml, plain no special libs are needed. I am using JDK8 because of the simple JavaFX config. (no config ;-) )&lt;br /&gt;
&lt;br /&gt;
Convention over Configuration:&lt;br /&gt;
CoC is the main in this framework. This means, that you don´t need to configure something. But you have to follow the base structure that this framework is expecting.&lt;br /&gt;
&lt;br /&gt;
As app-base-pkg I am using &lt;b&gt;org.rapidpm.demo.jaxenter.blog008&lt;/b&gt;. (you could get all from my git repo under&amp;nbsp;&lt;a href="https://bitbucket.org/rapidpm/jaxenter.de-0008-afterburner"&gt;https://bitbucket.org/rapidpm/jaxenter.de-0008-afterburner&lt;/a&gt;&amp;nbsp;) The main class will be Main, this is the JavaFX Application Class with the basic boostrapping intro. The sup-pkg orig contains the pkg presentation with only one GUI module called demo. For every GUI Module you will need two classes. The first one is a class with a name ending with View and the second one will end with Presenter. In our examplke you will find the two classes, DemoView and DemoPresenter.&lt;br /&gt;
&lt;br /&gt;
The DemoPresenter is nothing else as the Controller class for the View, declared inside the fxml file.&lt;br /&gt;
The fxml File itself must be named demo.fxml and at the same place as the Presenter/Controller class.&lt;br /&gt;
&lt;br /&gt;
&amp;nbsp;The DemoView is the GUI Component itself and must extend the FXMLView class from the framework.&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;The View - FXMView&amp;nbsp;&lt;/b&gt;&lt;br /&gt;
The DemoView have a default constructor, calling the init method. &lt;b&gt;init(Class clazz, String conventionalName)&amp;nbsp;&lt;/b&gt;&lt;br /&gt;
&lt;b&gt;&lt;br /&gt;&lt;/b&gt;

&lt;br /&gt;
&lt;pre class="brush: java"&gt;public FXMLView() {
    this.init(getClass(), getFXMLName());
}

private void init(Class clazz, String conventionalName) {
    final URL resource = clazz.getResource(conventionalName);
    String bundleName = getBundleName();
    ResourceBundle bundle = getResourceBundle(bundleName);
    this.loader = new FXMLLoader(resource, bundle);
    this.loader.setControllerFactory(new Callback&lt;class&gt;, Object&amp;gt;() {
        @Override
        public Object call(Class p) {
        return InjectionProvider.instantiatePresenter(p);
        }
        });
        try {
        loader.load();
        } catch (Exception ex) {
        throw new IllegalStateException("Cannot load "
        + conventionalName, ex);
        }
        }
    &lt;/class&gt;&lt;/pre&gt;
The init will load the ResourceBundle and the fxml-file with an instance of the class FXMLLoader. The most importand step is the setting of the ControllerFactory. Inside the instance of the ControllerFactory you will see the methodcall&lt;b&gt; InjectionProvider.instantiatePresenter(p);&lt;/b&gt;&amp;nbsp; This ist the place where the injection will be taken place. One big point to know is, only inside a controller/presenter you will be able to use injection. Inside the Presenter no injection is available.&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;The InjectionProvider - DI with reflection&lt;/b&gt;&lt;br /&gt;
The InjectionProvider ist the heart of the framework. The base steps are the following:&lt;br /&gt;
- create an instance&lt;br /&gt;
- inject the attributes with the annotation Inject&lt;br /&gt;
- call the method with annotation Postconstruct&lt;br /&gt;
Thats all... but how it is realized?&lt;br /&gt;
&lt;br /&gt;
The first step is quite easy, just call &lt;b&gt;clazz.newInstance()&lt;/b&gt;.&lt;br /&gt;
&lt;br /&gt;
Step two is a littele bit more complex. You have to instantiate the attributes but the the attributes inside too. Thes means the injection must be done recursive. To do this you will check the attributes if they are annotated with Inject, if so, do the same for this instance.. and so on..&lt;br /&gt;
There is a small thig to know. The implementation from Adam will only create one instance of every used class. This means you will get &lt;b&gt;only singletons!!&lt;/b&gt;&amp;nbsp;And this for the complete application.&lt;br /&gt;
&lt;br /&gt;
The last step is easy again, call all methods with the annotation Postconstruct per reflection.&lt;br /&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;static Object instantiateModel(Class clazz) {
    Object product = models.get(clazz);
    if (product == null) {
        try {
            product = injectAndInitialize(clazz.newInstance());
            models.put(clazz, product);
        } catch (InstantiationException | IllegalAccessException ex) {
            throw new IllegalStateException(
                "Cannot instantiate view: " + clazz, ex);
        }
    }
    return product;
}

static Object injectAndInitialize(Object product) {
    injectMembers(product);
    initialize(product);
    return product;
}

static void injectMembers(final Object instance) {
    Class aClass = instance.getClass();
    Field[] fields = aClass.getDeclaredFields();
    for (final Field field : fields) {
        if (field.isAnnotationPresent(Inject.class)) {
            Class type = field.getType();
            final Object target = instantiateModel(type);
            AccessController.doPrivileged(new PrivilegedAction() {
                @Override
                public Object run() {
                    boolean wasAccessible = field.isAccessible();
                    try {
                        field.setAccessible(true);
                        field.set(instance, target);
                        return null; // return nothing...
                    } catch (IllegalArgumentException | 
                                IllegalAccessException ex) {
                        throw new IllegalStateException(
                            "Cannot set field: " + field, ex);
                    } finally {
                        field.setAccessible(wasAccessible);
                    }
                }
            });
        }
    }
}
static void initialize(Object instance) {
    invokeMethodWithAnnotation(instance, PostConstruct.class);
}
&lt;/pre&gt;
&lt;b&gt;Lesson Learned&lt;/b&gt;&lt;br /&gt;
The framework afterburner.fx from Adam Bien is really small without any configuration. You could use this to inject Instances per annotation Inject. If you want to use this inside your application you have to know the following:&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;ul&gt;
    &lt;li&gt;There are no Scopes, all instances will have the the lifecycle of the application. The only way to terminate them earlier is to call the method forgettAll(), but this will terminate all instances. The method annotated with PreDestroy will be called before. You could not select the order the instances are destroyed.&lt;/li&gt;
    &lt;li&gt;All instances are singletons&lt;/li&gt;
    &lt;li&gt;No Producers, this means you could not abstract over an Interface layer. Or you can not switch between different implementations like you could do with Qualifiers.&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;
    If you could deal with this limitations, this will be good form you. But to use this to learn more about injection works, this is a good project to play with.&lt;/div&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>TestFX internals explained</title>
        <category label="Java"/>
        <category label="JavaFX"/>
        <category label="jUnit"/>
        <category label="TestFX"/>
        <published>2014-01-03T00:00:00+01:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2014/01/03/testfx-internals-explained.html&gt;TestFX internals explained&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2014-01-03 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
TestFX a small but powerful framework for JavaFX GUI Testing with jUnit.&lt;br/&gt;
How it is used and how it is working inside?&lt;br/&gt;
&lt;br/&gt;
TDD for GUI development is for a lot of developers something that make them feeling uncomfortable.&lt;br/&gt;
Using jUnit for the testing of the GUI Elements is mostly not what you want to do. &lt;br/&gt;
But with TestFX it is quite simple to write short but reusable tests.&lt;br/&gt;
&lt;br/&gt;
Let´s start with the project initialization. You need only a few entries in you pom.xml.&lt;br/&gt;
jUnit, hamcrest and testfx, that is it.. and nothing more.&lt;br/&gt;

&lt;br /&gt;
&lt;pre class="brush: xml"&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.loadui&lt;/groupId&gt;
    &lt;artifactId&gt;testFx&lt;/artifactId&gt;
    &lt;version&gt;3.0.0 &lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.hamcrest&lt;/groupId&gt;
    &lt;artifactId&gt;hamcrest-all&lt;/artifactId&gt;
    &lt;version&gt;1.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;version&gt;4.11&lt;/version&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.hamcrest&lt;/groupId&gt;
            &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
    &lt;/class&gt;&lt;/pre&gt;
After we added this entries to the pom.xml, we can start with the first jUnitTest using TestFX.&lt;br/&gt;
We will start with the traditional &lt;b&gt;HelloWorld&lt;/b&gt;. The first step is the creation of a TestClass.&lt;br/&gt;
The TestClass must extend from GuiTest, a base class from the TestFX Framework. &lt;br/&gt;
This class is abstract and you have to implement the method &lt;b&gt;protected Parent getRootNode()&lt;/b&gt;&lt;br/&gt;
This method must create the GUI element that you will test. I our example we want to test a simple button.&lt;br/&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;
@Category(TestFX.class)
public class SimpleButtonTest extends GuiTest {
    @Override
    protected Parent getRootNode() {
        final Button btn = new Button();
        btn.setId("btn");
        btn.setText("Hello World");
        btn.setOnAction((actionEvent)-&gt; btn.setText( "was clicked" ));
        return btn;
    }
}
    &lt;/class&gt;&lt;/pre&gt;
You can see, that you don´t have to create a holder for your GUI element.&lt;br/&gt;
Now we can start with the first test itself.&lt;br/&gt;
The button will change the text from "Hello World" to "was clicked" if the user will click the button.&lt;br/&gt;
How we can test this?&lt;br/&gt;

As normal we have to write a test method annotated with the @Test from jUnit.&lt;br/&gt;
The first question will be, how to get the reference of the button? &lt;br/&gt;
For this you can use one of the service methods. With find and the id you will get the instance.&lt;br/&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;
@Test
public void shouldClickButton(){
    final Button button = find( "#btn" );
    click(button);
    verifyThat( "#btn", hasText("was clicked") );
}
    &lt;/class&gt;&lt;/pre&gt;
As you can see, we can start with the functional tests after we got the reference. Here we are simulating the click.&lt;br/&gt;
After this we are checking if the result is as expected.&lt;br/&gt;
Writing tests looks now like , writing the use case with methods organized with the builder pattern.&lt;br/&gt;
If you want to write your own check like hasText() you have to write it with the framework hamcrest.&lt;br/&gt;
But TestFX will provide a lot of default checks and test-steps. Mostly you don not need more.&lt;br/&gt;
&lt;br/&gt;
But how TestFX is doing all this?&lt;br/&gt;
Starting with the test class GUITest, we know that we have to create the GUI element we want to test.&lt;br/&gt;
The class GUITest itself contains a lot of methods to describe the use case with &lt;br/&gt;
actions like click,drag,move,push, scroll, rightClick and so on.&lt;br/&gt;
But how the application is started? This will be done by the internal class TestFXApp inside GUITest. &lt;br/&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;
public static class TestFxApp extends Application
{
    private static Scene scene = null;

    @Override
    public void start( Stage primaryStage ) throws Exception
    {
        primaryStage.initStyle(StageStyle.UNDECORATED);
        primaryStage.show();
        stageFuture.set( primaryStage );
    }

    public static void setRoot( Parent rootNode )
    {
        scene.setRoot( rootNode );
    }
}
    &lt;/class&gt;&lt;/pre&gt;
Every developer that was writing the first few jUnit tests for an JavaFX application &lt;br/&gt;
came to the point where the JVM was telling something like &lt;br/&gt;
"please, only one instance of the JavaFX Application please"&lt;br/&gt;
How to deal with this?&lt;br/&gt;
The basic is quite simple. You have to start the application in one thread, save this as an singleton over all jUnit tests in one JVM.&lt;br/&gt;
After this, put every junit test method in one Callable and start them one after an other.&lt;br/&gt;
The first step will be done with the method setupStage, annotated with @Before.&lt;br/&gt;
Inside this there is a check if the singleton is already there or not. If not, it will be created. FXTestUtils.launchApp(TestFxApp.class);&lt;br/&gt;
After this the GUI element from getRootNode() will be placed in a new Runnable.&lt;br/&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;
@Before
public void setupStage() throws Throwable{
    showNodeInStage();
}

private void showNodeInStage(){
    showNodeInStage(null);
}

private void showNodeInStage( final String stylesheet ){
    GuiTest.stylesheet = stylesheet;

    if( stage == null ){
        FXTestUtils.launchApp(TestFxApp.class);
        try{
            stage = targetWindow(stageFuture.get( 25,TimeUnit.SECONDS ) );
            FXTestUtils.bringToFront( stage );
        }catch( Exception e ) {
            throw new RuntimeException( "Unable to show stage", e );
        }
    }

    try{
        FXTestUtils.invokeAndWait( new Runnable(){
            @Override
            public void run(){
                Scene scene = SceneBuilder
                    .create()width( 600 ) height( 400 )
                    .root( getRootNode() ).build();

                if(stylesheet!=null) 
                    scene.getStylesheets().add(stylesheet);
                stage.setScene( scene );
            }
        }, 5 );
    }catch( Exception e ) {
        e.printStackTrace();
    }
}

    &lt;/class&gt;&lt;/pre&gt;

That´s it. Quite simple and easy to use for a developer.&lt;br/&gt;
The good thing is, that TestFX is good usable in an CI environment. &lt;br/&gt;
You only have to configure jUnit if not already done.&lt;br/&gt;
&lt;br/&gt;
But this is not the end..  I am working in the moment at the full CDI support inside &lt;br/&gt;
TestFX. We will see it in one of the next versions from TestFX. stay tuned...&lt;br/&gt;
&lt;br/&gt;
If you have any ideas what we can improve..    let me know..&lt;br/&gt;
&lt;br/&gt;
happy javafx testing&lt;br/&gt;
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>FXController with CDI managed DynamicObjectAdapter - Part 1</title>
        <category label="Arquillian"/>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="Java"/>
        <category label="JavaFX"/>
        <category label="JDK8"/>
        <category label="Reflection"/>
        <category label="Weld"/>
        <published>2014-01-10T00:00:00+01:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2014/01/10/fxcontroller-with-cdi-managed-dynamico.html&gt;FXController with CDI managed DynamicObjectAdapter - Part 1&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2014-01-10 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
Today I will show the first step how you can use a dynamic proxy for JavaFX Controller.&lt;br/&gt;
This we will need for the CDI support inside TestFX.. but this later..&lt;br/&gt;
&lt;br/&gt;
During I was writing on my reflection shortcut together with Dr. Heinz Kabutz&lt;br/&gt;
(will be first available in german, later in english if asked for) I was thinking about his Newsletter &lt;br/&gt;
about "Object Adapter based on Dynamic Proxy". &lt;br/&gt;
Based on this we will now transform this into an CDI pattern for JavaFX Controller.&lt;br/&gt;
&lt;br/&gt;
The basic target will be an decorator for an CDI environment, to switch between implementations of defined methods&lt;br/&gt;
of an controller. Ok, there is an decorator defined inside the CDI environment but with some hard limitations.&lt;br/&gt;
&lt;br/&gt;
First of all, you have to define the decorator inside the beans.xml. I don´t like this. &lt;br/&gt;
If something will be changed you have to restart the container. And the definition is static.&lt;br/&gt;
The second I not like, is the usage of an decorator. &lt;br/&gt;
&lt;br/&gt;
You have to annotate the class, &lt;br/&gt;
you have to inject the basic implementation&lt;br/&gt;
and you have to extend the basic implementation.  &lt;br/&gt;
&lt;br/&gt;
This is too much and the main disadvantage: you have to decide what decorator to use in the static context.&lt;br/&gt;
&lt;br/&gt;
How to solve this? &lt;br/&gt;
&lt;br/&gt;
Let´s start with the basic step. With the default methods in JDK8 you don´t need a basic Implementation class.&lt;br/&gt;
But you have an interface. Let´s say we have an interface called DemoLogic.&lt;br/&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;
@CDINotMapped
public interface DemoLogic {

    public default int add(int a, int b){
        return a+b;
    }

    public default int sub(int a, int b){
        return a-b;
    }
}
    &lt;/class&gt;&lt;/pre&gt;

Importand is the annotation, to exclude this from the default scope inside CDI. You will see it later why..&lt;br/&gt;
&lt;br/&gt;
The next thing we want to have is an special implementation from the add method. This we will implement inside a class &lt;br/&gt;
called DemoLogicAdapter_A.&lt;br/&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;
@CDINotMapped
public class DemoLogicAdapter_A implements DemoLogic{

    public int add(int a, int b){
        System.out.println("DemoLogicAdapter_A.add");
        return a+b + 100;
    }
}
    &lt;/class&gt;&lt;/pre&gt;

Same here with the annotation. The good thing is, you really have to implement the changed method only.&lt;br/&gt;
No other delegator stuff.&lt;br/&gt;
&lt;br/&gt;
Next we need, is something to decide dynamically if we want to use the original implementation or the special one.&lt;br/&gt;
This we will simulate with a singleton calles Context. This class with only one boolean attribute called original&lt;br/&gt;
is to simulate a decicion logic.&lt;br/&gt;
If the attribute is true, we are in context original otherwise we are inside the context customer specific.&lt;br/&gt;

&lt;br /&gt;
&lt;pre class="brush: java"&gt;
@Singleton
public class Context {

    public boolean original = true;
}
    &lt;/class&gt;&lt;/pre&gt;

Now we will use it like the developer will do it later in a high level way.&lt;br/&gt;
For this we write a jUnit Test to test this.&lt;br/&gt;
The test will do the following.&lt;br/&gt;
Inject the DemoLogic, call the method add and test if the original version was used.&lt;br/&gt;
After this switch the context by setting the attribut original to false.&lt;br/&gt;
Now get the demologic again and call the method add. &lt;br/&gt;
If all is all right we will get the customer specific result.&lt;br/&gt;


&lt;br /&gt;
&lt;pre class="brush: java"&gt;
@RunWith(Arquillian.class)
public class DemoLogicTest {
    @Deployment
    public static JavaArchive createDeployment() {
        return ShrinkWrap.create(JavaArchive.class)
                .addPackages(true, "org.rapidpm.commons")
                .addAsManifestResource(EmptyAsset.INSTANCE, "beans.xml");
    }

    @Inject @DynamicDecoratorTest Instance&lt;DemoLogic&gt; demoLogic;
    @Inject Context context;
    @Test
    public void testDemoLogicOriginalTest() throws Exception {
    Assert.assertNotNull(demoLogic);
    final DemoLogic demoLogic1 = demoLogic.get();
    final int add = demoLogic1.add(1, 1);
    Assert.assertEquals(2,add);
    System.out.println("add = " + add);

    context.original = false;
    final DemoLogic demoLogic2 = demoLogic.get();
    final int addAdapted = demoLogic2.add(1, 1);
    Assert.assertEquals(102,addAdapted);
    System.out.println("addAdapted = " + addAdapted);
    }
    }
    &lt;/class&gt;&lt;/pre&gt;
I am using arquillian to have CDI support inside my jUnit Tests.&lt;br/&gt;
The annotation DynamicDecoratorTest is to separate this test from the rest of my tests.&lt;br/&gt;
&lt;br/&gt;
You see the usage quite clear. The developer will only see the interface. He will use it like &lt;br/&gt;
he will do it as normal. No change to see! Let´s asume the context switch is done by the system,&lt;br/&gt;
hidden, so the the develper is not able to see it. &lt;br/&gt;
He will write code only with the thinking about the business logic to implement.&lt;br/&gt;
&lt;br/&gt;
Afer we described what we want to have, we will implement the core. &lt;br/&gt;
To get an instance of the DemoLogic, we need a producer. We will call the class DemoLogicProducer.&lt;br/&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;
public class DemoLogicProducer {

    @Inject Instance&lt;DynamicObjectAdapterFactory&gt; dynamicObjectAdapterFactoryInstance;

    @Inject Context context;

    @Produces @DynamicDecoratorTest
    public DemoLogic create(ManagedInstanceCreator instanceCreator){
    final DemoLogic demoLogic = instanceCreator.activateCDI(new DemoLogic() {});

    final DynamicObjectAdapterFactory dynamicObjectAdapterFactory = dynamicObjectAdapterFactoryInstance.get();

    final Object adapter;
    if (context.original){
    adapter = new Object();
    } else {
    adapter = instanceCreator.activateCDI(new DemoLogicAdapter_A());
    }

    return dynamicObjectAdapterFactory.adapt(demoLogic, DemoLogic.class, adapter);
    }
    }
    &lt;/class&gt;&lt;/pre&gt;
The basic what we are simulating here ist the switch between original and customer specific.&lt;br/&gt;
This will be more comfortable in the next post. (using a ContextResolver)&lt;br/&gt;
But to show the basic step this is made explicite simple.&lt;br/&gt;
If the attribute is true, use the original one otherwise use the customer specific.&lt;br/&gt;
Very simple.. Both instances are manually put inside the CDI environment. &lt;br/&gt;
This ist only to show that the adapter itself can be managed too.&lt;br/&gt;
&lt;br/&gt;
The most importand step is the transparent wrapping with the DynamicObjectAdapterFactory.&lt;br/&gt;
The developer will not see this, until he is debugging ;-)&lt;br/&gt;
&lt;br/&gt;
How this factory is working? &lt;br/&gt;
The factory is using the java.lang.reflect.Proxy from the JDK itself. An old but very usefull class.&lt;br/&gt;
In my case I will use this in side a CDI managed environment. &lt;br/&gt;

&lt;br /&gt;
&lt;pre class="brush: java"&gt;
public class DynamicObjectAdapterFactory {

    @Inject Instance&lt;CDIInvocationHandler&gt; cdiInvocationHandlerInstance;

    public  &lt;T&gt; T adapt(final Object adaptee,final Class&lt;T&gt; target,final Object adapter) {

        final CDIInvocationHandler invocationHandler = cdiInvocationHandlerInstance
        .get()
        .adapter(adapter)
        .adaptee(adaptee);

        return (T) Proxy.newProxyInstance(
        target.getClassLoader(),
        new Class[]{target},
        invocationHandler
        );
        }

        }
        &lt;/class&gt;&lt;/pre&gt;
This means I will be able to inject, for example, the InvocationHandler. &lt;br/&gt;
This I need, because I need a managed InvocationHandler. &lt;br/&gt;
The usage of the Proxy is nothing complex. But the InvocationHandler is the final and importand step.&lt;br/&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;
public class CDIInvocationHandler implements InvocationHandler {

    @Inject @CDILogger Logger logger;

    private Map&lt;MethodIdentifier, Method&gt; adaptedMethods = new HashMap&lt;&gt;();

    private Object adapter;
    private Object adaptee;

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

        if (adaptedMethods.isEmpty()){
            final Class&lt;?&gt; adapterClass = adapter.getClass();
            Method[] methods = adapterClass.getDeclaredMethods();
            for (Method m : methods) {
                adaptedMethods.put(new MethodIdentifier(m), m);
            }
        }else{
            if (logger.isDebugEnabled()) {
                logger.debug("adaptedMethods is initialized..");
            }
        }
        try {
            Method other = adaptedMethods.get(new MethodIdentifier(method));
            if (other != null) {
                return other.invoke(adapter, args);
            } else {
                return method.invoke(adaptee, args);
            }
        } catch (InvocationTargetException e) {
            throw e.getTargetException();
        }
    }

    public CDIInvocationHandler adapter(final Object adapter) {
        this.adapter = adapter;
        return this;
    }

    public CDIInvocationHandler adaptee(final Object adaptee) {
        this.adaptee = adaptee;
        return this;
    }


}

public class MethodIdentifier {
    private final String name;
    private final Class[] parameters;

    public MethodIdentifier(Method m) {
        name = m.getName();
        parameters = m.getParameterTypes();
    }

    // we can save time by assuming that we only compare against
    // other MethodIdentifier objects
    public boolean equals(Object o) {
        MethodIdentifier mid = (MethodIdentifier) o;
        return name.equals(mid.name) &amp;&amp;
                Arrays.equals(parameters, mid.parameters);
    }

    public int hashCode() {
        return name.hashCode();
    }
}

    &lt;/class&gt;&lt;/pre&gt;

The method invoke is called every time a method is called on the proxy. This is the place to decide which method will be called.&lt;br/&gt;
From the adapter we will get all methods and put them inside a HashMap. The key is based on method-name and attributes. &lt;br/&gt;
If a method is called with this key, we will get the adapter instance of this method from the map and &lt;br/&gt;
will call this instead of the original one.&lt;br/&gt;
If not key found, we will call the original nethod.&lt;br/&gt;
This is really simple!&lt;br/&gt;
&lt;br/&gt;
This means you have everywhere CDI managed instances.&lt;br/&gt;
You have only to implement what you whant to change.&lt;br/&gt;
It is dynamic with every request.&lt;br/&gt;
No beans.xml must be edited.&lt;br/&gt;
&lt;br/&gt;
You never need the decorator from CDI anymore. ;-)  &lt;br/&gt;
&lt;br/&gt;
Next step will be the integration iside an JavaFX controller.. and TestFX CDI Support&lt;br/&gt;
&lt;br/&gt;

&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>IoT with Java8 and TinkerForge Part 1</title>
        <category label="IoT"/>
        <category label="Java"/>
        <category label="JavaFX"/>
        <category label="JDK8"/>
        <category label="TinkerForge"/>
        <published>2014-01-13T00:00:00+01:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2014/01/13/iot-with-java8-and-tinkerforge-part-1.html&gt;IoT with Java8 and TinkerForge Part 1&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2014-01-13 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
IoT is something cool, but I think you know it already.&lt;br /&gt;
Today I started with TinkerForge.
TinkerForge is a german company that are building electronic elements. You can put them together like LEGO.
This means, that you don´t need any special electronic stuff or knowledge.
&lt;br /&gt;
And the best, you can code plain Java to use them.&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;But how we can start?
&lt;/b&gt;&lt;br /&gt;
&lt;br /&gt;
First of all, you need a MasterBrick and at minimumm one sensor. For my first experiment I am using
the simple temperature sensor. After unpacking it I needed around 3 min to put all together.
After this you can plug it into your USB port. Now the hardware part is ready.
&lt;br /&gt;
&lt;br /&gt;
To speak with this components you have to install two things.&lt;br /&gt;
First the usb-driver, that is used for the communication with the MasterBrick,&lt;br /&gt;
second the BrickViewr. With this you can check the installation, update the firmware and so on.
&lt;br /&gt;
&lt;br /&gt;
You will find the software for&lt;b&gt; linux/osx/windows&lt;/b&gt;.
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Hello IoT World:&amp;nbsp;&lt;/b&gt;&lt;br /&gt;
&lt;br /&gt;
We will start with the first HelloWorld. Here with the Hello IoTWorld.&lt;br /&gt;
After you connected the MasterBrick with the USB-port you will see a blue light
and the MasterBrick will be ready for communication.
&lt;br /&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://1.bp.blogspot.com/-L4kMEQNQn7U/UtRZqJ_UlPI/AAAAAAABVGA/q_UgrGaqkdQ/s1600/SvenRuppert_IoT_TinkerForge_001_BrickV_001.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://1.bp.blogspot.com/-L4kMEQNQn7U/UtRZqJ_UlPI/AAAAAAABVGA/q_UgrGaqkdQ/s1600/SvenRuppert_IoT_TinkerForge_001_BrickV_001.jpg" height="140" width="320" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br /&gt;
Now we could start the BrickViewer to check the installation.
The importand part is the UID from the sensor. With this we can connect it later.
After you pressed the connect button, you can see all the informations.
&lt;br /&gt;
&lt;br /&gt;
At &lt;a href="https://bitbucket.org/rapidpm/jaxenter.de-0012-iot-tinkerforge"&gt;https://bitbucket.org/rapidpm/jaxenter.de-0012-iot-tinkerforge&lt;/a&gt; are all source codes you will need, including the TinkerForge API itself.&lt;br /&gt;
I spoke with TinkerForge and we decided to put the API into maven.&lt;br /&gt;
&lt;br /&gt;
After we have done this, I will inform you.
If you are interested, follow me on Twitter please ( &lt;b&gt;&lt;a href="https://twitter.com/SvenRuppert"&gt;@SvenRuppert&lt;/a&gt;&lt;/b&gt; )
&lt;br /&gt;
&lt;br /&gt;
The basic steps are quite simple to use this sensor.&lt;br /&gt;
&lt;br /&gt;
&lt;ul&gt;
    &lt;li&gt;create a IPConnection&amp;nbsp;&lt;/li&gt;
    &lt;li&gt;create an instance of the class BrickletTemperature&amp;nbsp;&lt;/li&gt;
    &lt;li&gt;configure the sensor&amp;nbsp;&lt;/li&gt;
    &lt;li&gt;add an ActionListener.&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
That is all.
&lt;br /&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;import com.tinkerforge.BrickletTemperature;
import com.tinkerforge.IPConnection;

public class ExampleCallback {
    private static final String host = "localhost";
    private static final int port = 4223;
    private static final String UID = "dXj"; 
    public static void main(String args[]) throws Exception {
        IPConnection ipcon = new IPConnection(); 
        BrickletTemperature temp = new BrickletTemperature(UID, ipcon); 
        ipcon.connect(host, port); 
        temp.setTemperatureCallbackPeriod(1000);
        temp.addTemperatureListener(new 
          BrickletTemperature.TemperatureListener() {
            public void temperature(short temperature) {
                System.out.println("Temperature: " 
                   + temperature/100.0 + " °C");
            }
        });
        ipcon.disconnect();
    }
}
&lt;/pre&gt;
After this short example we could do our first javafx test.
We want to check the temperature over some time and show this inside an LineChart.&lt;br /&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://2.bp.blogspot.com/-q7AnTcjRQz4/UtRaLcWsJFI/AAAAAAABVGI/lUAYpFuc87g/s1600/SvenRuppert_IoT_TinkerForge_001_Temp_001.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://2.bp.blogspot.com/-q7AnTcjRQz4/UtRaLcWsJFI/AAAAAAABVGI/lUAYpFuc87g/s1600/SvenRuppert_IoT_TinkerForge_001_Temp_001.jpg" height="199" width="320" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br /&gt;
&lt;br /&gt;
Here we are... and please note, the DateAxis is from&lt;a href="http://myjavafx.blogspot.de/2013/09/javafx-charts-display-date-values-on.html"&gt; http://myjavafx.blogspot.de/2013/09/javafx-charts-display-date-values-on.html&lt;/a&gt;&lt;br /&gt;
&lt;pre class="brush: java"&gt; 
 public class HelloTinkerForge extends Application {

    private static final String host = "localhost";
    private static final int port = 4223;
    private static final String UID = "dXj"; 


    public static void main(String args[]) throws Exception {
        launch(args);
    }

    public static XYChart.Series series;

    @Override
    public void start(Stage stage) {
        stage.setTitle("Line Chart TinkerForge Sample");
        final DateAxis dateAxis = new DateAxis();
        final NumberAxis yAxis = new NumberAxis();
        dateAxis.setLabel("Time of Temp");
        final LineChart&lt;date number=""&gt; lineChart
    = new LineChart&amp;lt;&amp;gt;(dateAxis, yAxis);

    lineChart.setTitle("Temp Monitoring");

    series = new XYChart.Series();
    series.setName("My temps");
    final ObservableList seriesData = series.getData();

    lineChart.getData().add(series);
    Scene scene = new Scene(lineChart, 800, 600);
    stage.setScene(scene);
    stage.show();
    new Worker(seriesData).start();

    }

    public static class Worker extends Thread {
    final ObservableList seriesData;
    public Worker(final ObservableList seriesData) {
    setDaemon(true);
    setName("Thread Temp");
    this.seriesData = seriesData;
    }

    @Override
    public void run() {
    Platform.runLater(new Runnable() {
    @Override
    public void run() {
    IPConnection ipcon = new IPConnection();
    BrickletTemperature temp
    = new BrickletTemperature(UID, ipcon);
    try {
    ipcon.connect(host, port);
    temp.setTemperatureCallbackPeriod(1000);
    temp.addTemperatureListener(
    new BrickletTemperature.TemperatureListener() {
    public void temperature(short temperature) {
    Platform.runLater(new Runnable() {
    @Override
    public void run() {
    final double temp
    = temperature / 100.0;
    final int counter
    = seriesData.size() + 1;
    final XYChart.Data data
    = new XYChart.Data(
    new Date(), temp);
    seriesData.add(data);
    }
    });
    }
    });
    } catch (IOException |
    AlreadyConnectedException |
    TimeoutException |
    NotConnectedException e) {
    e.printStackTrace();
    }
    }
    });
    }
    }
    }
&lt;/date&gt;&lt;/pre&gt;
&lt;pre class="brush: java"&gt;&lt;date number=""&gt;
&lt;/date&gt;&lt;/pre&gt;
Short and simple.. Well this is a simple example, but the next step will be with more sensor-elements...&lt;br /&gt;
&amp;nbsp;stay tuned..  and happy coding.
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>IoT with Java8 and TinkerForge Part 2</title>
        <category label="IoT"/>
        <category label="Java"/>
        <category label="JavaFX"/>
        <category label="JDK8"/>
        <category label="TinkerForge"/>
        <published>2014-01-20T00:00:00+01:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2014/01/20/iot-with-java8-and-tinkerforge-part-2.html&gt;IoT with Java8 and TinkerForge Part 2&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2014-01-20 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
One of the interesting features of &lt;a href="http://www.tinkerforge.com/"&gt;TinkerForge&lt;/a&gt; is the possibility to
put different elements like sensors, physical buttons, and more on a MasterBrick&lt;br /&gt;
&lt;br /&gt;
This is what we want to do today.
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;The Barometer&lt;/b&gt;&lt;br /&gt;
Today we are using the &lt;a href="http://www.tinkerforge.com/en/doc/Hardware/Bricklets/Barometer.html"&gt;Barometer-Bricklet&lt;/a&gt;.
The Barometer Bricklet can be used to extend the features of Bricks
by the capability to measure air pressure in range of 10 to 1200mbar
with a resolution of 0.012mbar. The measurement is temperature
compensated internally. The Bricklet is equipped with
a MS5611-01BA01 sensor which is designed to be used as an altimeter, too.
&lt;br /&gt;
&lt;br /&gt;
&lt;i&gt;At &lt;a href="https://bitbucket.org/rapidpm/jaxenter.de-0012-iot-tinkerforge"&gt;https://bitbucket.org/rapidpm/jaxenter.de-0012-iot-tinkerforge&lt;/a&gt; are all source codes you will need, including the TinkerForge API itself.
    I spoke with TinkerForge and we decided to put the API into maven. After we have done this, I will inform you.
    If you are interested, follow me on Twitter please ( &lt;b&gt;@SvenRuppert&lt;/b&gt; )
&lt;/i&gt;&lt;br /&gt;
&lt;br /&gt;
The most interesting part for us today will be the presents of two sensors inside of one Bricklet.&lt;br /&gt;
How we can handle it and how we will get the data to the screen?&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Connect to n - Sensor-units&lt;/b&gt;&lt;br /&gt;
To remember... To connect to a sensor you need an instance of the representing class.
To get the value from the sensor you have to implement an ActionListener.
Here the short example from my last blog about TinkerForge. &lt;i&gt;(&lt;a href="http://www.rapidpm.org/2014/01/iot-with-java8-and-tinkerforge-part-1.html"&gt;engl&lt;/a&gt; /&lt;a href="http://jaxenter.de/artikel/Internet-of-Things-mit-Java-8-und-TinkerForge-Teil-1-170511"&gt; ger&lt;/a&gt;)&lt;/i&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;import com.tinkerforge.BrickletTemperature;
import com.tinkerforge.IPConnection;
public class ExampleCallback {
  private static final String host = "localhost";
  private static final int port = 4223;
  private static final String UID = "dXj";
  public static void main(String args[]) throws Exception {
    IPConnection ipcon = new IPConnection();
    BrickletTemperature temp = new BrickletTemperature(UID, ipcon);
    ipcon.connect(host, port);
    temp.setTemperatureCallbackPeriod(1000);
    temp.addTemperatureListener(new
    BrickletTemperature.TemperatureListener() {
      public void temperature(short temperature) {
        System.out.println("Temperature: "
        + temperature/100.0 + " °C");
      }
    });
    ipcon.disconnect();
}
}
&lt;/pre&gt;
The same will be with the two sensor-units inside the Barometer-Bricklet.
The class name will be BrickletBarometer, and you have to implement two ActionListeners.
One for the air-pressure called AirPressureListener and one for the altitude called AltitudeListener.
&lt;br /&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;public class ExampleCallback {
    private static final String host = "localhost";
    private static final int port = 4223;
    private static final String UID = "jY4";

    public static void main(String args[]) throws Exception {
        IPConnection ipcon = new IPConnection();
        BrickletBarometer b = new BrickletBarometer(UID, ipcon);
        ipcon.connect(host, port);
        b.setAirPressureCallbackPeriod(1000);
        b.setAltitudeCallbackPeriod(1000);
        b.addAirPressureListener(
                new BrickletBarometer.AirPressureListener() {
                    public void airPressure(int airPressure) {
                        System.out.println("Air Pressure: "
                                + airPressure / 1000.0 + " mbar");
                    }
                }
        );
        b.addAltitudeListener(new BrickletBarometer.AltitudeListener() {
            public void altitude(int altitude) {
                System.out.println("Altitude: " + altitude / 100.0 + " m");
            }
        });
        ipcon.disconnect();
    }
}
&lt;/pre&gt;
&lt;b&gt;Connection to JavaFX&lt;/b&gt;&lt;br /&gt;
The connection to JavaFX could be simple. The basic steps are always the same.
You have to start an Thread outside our JavaFX GUI Thread. Inside this thread you have to configure the sensor
and inside the run()- method you have to add the action listener.
All steps that are manipulating the GUI, you have to start again inside a Platform.runLater()
Now, we have to sensor-units. This means that we are doing this twice.
To reuse the code later, we are extracting it into an separate class.
If we would do it for the temperature sensor we used last time, it will look like the following.
&lt;br /&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;public class Temp implements Runnable {

  private String UID;
  private ObservableList seriesData;

  public Temp(final String UID, final XYChart.Series series) {
      this.UID = UID;
      this.seriesData = series.getData();
  }

  @Override
  public void run() {
      IPConnection ipcon = new IPConnection();
      BrickletTemperature temp = new BrickletTemperature(UID, ipcon);
      try {
          ipcon.connect(Barometer.host, Barometer.port);
          temp.setTemperatureCallbackPeriod(1000);
          temp.addTemperatureListener(new BrickletTemperature.TemperatureListener() {
              public void temperature(short temperature) {
                  Platform.runLater(new Runnable() {
                      @Override
                      public void run() {
                          final double temp = temperature / 100.0;
                          System.out.println("Temperature: " + temp + " °C");
                          final XYChart.Data data = new XYChart.Data(new Date(), temp);
                          seriesData.add(data);
       }
                  });
              }
          });
      } catch (IOException 
       | AlreadyConnectedException 
    | TimeoutException 
    | NotConnectedException e) {
          e.printStackTrace();
      }
  }
}
&lt;/pre&gt;
For the Barometer-Bricklet I was writing two classes. One for the airpressure and one for the altitude.
Both are identically, with one difference. The implementation of the ActionListener.
Every sensor will put his data to a separate LineChart.&lt;br /&gt;
&amp;nbsp;This implementation is not perfect, because we are not disconnecting
from the sensor in the end, and for one Bricklet we have two representing classes.
Both instances are in a different thread.
But this is still running over a longer period. (at least a few days with my laptop)
How to encapsulate this in better way we will see in one of my next posts.

&lt;br /&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;public class Altitude implements Runnable {

    private String UID;
    private ObservableList seriesData;

    public Altitude(final String UID, final XYChart.Series series) {
        this.UID = UID;
        this.seriesData = series.getData();
    }

    @Override
    public void run() {
        IPConnection ipcon = new IPConnection();
        BrickletBarometer b = new BrickletBarometer(UID, ipcon);

        try {
            ipcon.connect(Barometer.host, Barometer.port);
            b.setAirPressureCallbackPeriod(1000);
            b.addAltitudeListener(new BrickletBarometer.AltitudeListener() {
                public void altitude(int altitude) {
                    System.out.println("Altitude: " + altitude / 100.0 + " m");
                    Platform.runLater(new Runnable() {
                        @Override
                        public void run() {
                            final double temp = altitude / 100.0;
                            final XYChart.Data data = new XYChart.Data(new Date(), temp);
                            seriesData.add(data);
                        }
                    });
                }
            });
        } catch (IOException | AlreadyConnectedException | TimeoutException | NotConnectedException e) {
            e.printStackTrace();
        }
    }
}
&lt;/pre&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;public class Airpressure implements Runnable {

    private String UID;
    private ObservableList seriesData;

    public Airpressure(final String UID, final XYChart.Series series) {
        this.UID = UID;
        this.seriesData = series.getData();
    }

    @Override
    public void run() {
        IPConnection ipcon = new IPConnection();
        BrickletBarometer b = new BrickletBarometer(UID, ipcon);

        try {
            ipcon.connect(Barometer.host, Barometer.port);
            b.setAirPressureCallbackPeriod(1000);
            b.addAirPressureListener(new BrickletBarometer.AirPressureListener() {
                public void airPressure(int airPressure) {
                    System.out.println("Air Pressure: " + airPressure / 1000.0 + " mbar");
                    Platform.runLater(new Runnable() {
                        @Override
                        public void run() {
                            final double temp = airPressure / 1000.0 ;
                            final XYChart.Data data = new XYChart.Data(new Date(), temp);
                            seriesData.add(data);
                        }
                    });
                }
            });
        } catch (IOException 
     | AlreadyConnectedException 
     | TimeoutException 
     | NotConnectedException e) {
            e.printStackTrace();
        }
    }
}
&lt;/pre&gt;
Putting all together we will get the following main.

&lt;br /&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;public class Barometer extends Application {
    public static final String host = "localhost";
    public static final int port = 4223;


    public static void main(String args[]) throws Exception {
        launch(args);
    }

    public static XYChart.Series seriesTemp = new XYChart.Series();
    public static XYChart.Series seriesAirpressure = new XYChart.Series();
    public static XYChart.Series seriesAltitude = new XYChart.Series();

    @Override
    public void start(Stage stage) {
        stage.setTitle("Line Chart TinkerForge Sample");

        final VBox box = new VBox();
        seriesTemp.setName("Temp");
        seriesAirpressure.setName("Airpressure");
        seriesAltitude.setName("Altitude");

        final ObservableList&lt;node&gt; boxChildren = box.getChildren();
        boxChildren.add(createLineChart("Temp", seriesTemp));
        boxChildren.add(createLineChart("Airpressure", seriesAirpressure));
        boxChildren.add(createLineChart("Altitude", seriesAltitude));

        Scene scene = new Scene(box, 2000, 1500);

        stage.setScene(scene);
        stage.show();
        Platform.runLater(new Temp("dXj", seriesTemp));
        Platform.runLater(new Airpressure("jY4", seriesAirpressure));
        Platform.runLater(new Altitude("jY4", seriesAltitude));
        }

        private LineChart createLineChart(final String chartName,final XYChart.Series series ){
        final DateAxis dateAxis = new DateAxis();
        dateAxis.setLabel("Time");
        final NumberAxis yAxis = new NumberAxis();

        final LineChart&lt;date number=""&gt; lineChart = new LineChart&amp;lt;&amp;gt;(dateAxis, yAxis);
            lineChart.setTitle(chartName);
            lineChart.getData().add(series);

            return lineChart;
            }
            }
        &lt;/date&gt;&lt;/node&gt;&lt;/pre&gt;
&lt;br /&gt;
&lt;i&gt;At&amp;nbsp;&lt;a href="https://bitbucket.org/rapidpm/jaxenter.de-0012-iot-tinkerforge"&gt;https://bitbucket.org/rapidpm/jaxenter.de-0012-iot-tinkerforge&lt;/a&gt;&amp;nbsp;are all source codes you will need, including the TinkerForge API itself. I spoke with TinkerForge and we decided to put the API into maven. After we have done this, I will inform you. If you are interested, follow me on Twitter please (&amp;nbsp;&lt;b&gt;@SvenRuppert&lt;/b&gt;&amp;nbsp;)&lt;/i&gt;&lt;br /&gt;
&lt;i&gt;&lt;br /&gt;&lt;/i&gt;
Short and simple.. as always ..
But if we are using more sensors in a way like this, we will get performance problems.
To solve this we are connecting different &lt;b&gt;NoSQL&lt;/b&gt; systems soon. And we have to build the next version of JavaFX GUI-Elements...
.... stay tuned..  and happy coding.

&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>TestFX a must for jUnit Tests inside JavaFX environments!</title>
        <category label="CDI"/>
        <category label="Java"/>
        <category label="JavaFX"/>
        <category label="TestFX"/>
        <published>2014-02-04T00:00:00+01:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2014/02/04/testfx-a-must-for-junit-tests-inside-j.html&gt;TestFX a must for jUnit Tests inside JavaFX environments!&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2014-02-04 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
&lt;b&gt;You have written jUnit Tests for JavaFX applications?&amp;nbsp;&lt;/b&gt;&lt;br /&gt;
&lt;b&gt;You want to simulate user interactions?&lt;/b&gt;&lt;br /&gt;
&lt;br /&gt;
If you are starting from scratch this will be a long task.&lt;br /&gt;
But the Team from TestFX is working on a solution.&lt;br /&gt;
TestFX (&lt;a href="https://github.com/SmartBear/TestFX"&gt;https://github.com/SmartBear/TestFX&lt;/a&gt;) is an OpenSource framework from Henrik Olsson (SmartBear) with the goal to be an easy-to-use framework for testing JavaFX.&lt;br /&gt;
&lt;br /&gt;
This framework is ready for Java8 and supports JavaFX 2.&lt;br /&gt;
With this you are able to test featured JavaFX based GUIs.&lt;br /&gt;
&lt;br /&gt;
No License needed, no costs, complete OpenSource and extensible.&lt;br /&gt;
&lt;br /&gt;
The fluent and clean API is simple to use for the interaction with the controls. No special wrapper must be implemented, no boilerplate code is needed to test a simple control. Extend the jUnit Test-class and create an instance of your JavaFX control.&lt;br /&gt;
&lt;br /&gt;
That´s all you need. After this you are able to interact directly with the instance you created.&lt;br /&gt;
TestFX will give you a lot of service methods to interact and verify the behavior of the tested control.&lt;br /&gt;
And, if something goes wrong, you will get an screenshot of the failed test.&lt;br /&gt;
&lt;br /&gt;
One of the really big advantages is the easy possibility to extend TestFX by yourself. The framework is clean and well structured.&lt;br /&gt;
The support for Hamcrest Matchers and Lambdas will give you all you need to build complex tests.&lt;br /&gt;
&lt;br /&gt;
There is only one more thing....&lt;br /&gt;
... &amp;nbsp;we are working on the&lt;b&gt; CDI support&lt;/b&gt; for TestFX.&lt;br /&gt;
&lt;br /&gt;
stay tuned and happy coding.&lt;br /&gt;
&lt;br /&gt;
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>FXController with CDI managed DynamicObjectAdapter - Part 2</title>
        <category label="Arquillian"/>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="Java"/>
        <category label="JavaFX"/>
        <category label="JDK8"/>
        <category label="Reflection"/>
        <category label="Weld"/>
        <published>2014-02-07T00:00:00+01:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2014/02/07/fxcontroller-with-cdi-managed-dynamico.html&gt;FXController with CDI managed DynamicObjectAdapter - Part 2&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2014-02-07 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
Based on my &lt;a href="http://www.rapidpm.org/2014/01/fxcontroller-with-cdi-managed.html"&gt;blog article part 1&lt;/a&gt; we want to integrate the DynamicObjectAdapter into an JavaFX application.
To remember: We have an interface called DemoLogic with two methods. add(..) and sub(..)
The implementation is really simple, but at runtime we could switch the implementation partially.
For this we needed an adapter.
&lt;br/&gt;
The biggest tdifference compared to the default CDI decorator was,
that we need no definition inside the beans.xml. The implementation is smaller
and no need for Qualifiers and other biolder-plate code.
&lt;br/&gt;
This DemoLogic we want to use now inside an JavaFX application.
For this we ned first an fxml.file called DemoPane.fxml. Here we will define a few elements.

&lt;br /&gt;
&lt;pre class="brush: javafx"&gt;
&amp;lt;?import javafx.scene.control.Button?&amp;gt;
&amp;lt;?import javafx.scene.control.TextField?&amp;gt;
&amp;lt;?import javafx.scene.layout.VBox?&amp;gt;
&amp;lt;?import javafx.scene.control.Label?&amp;gt;
&amp;lt;?import javafx.scene.control.CheckBox?&amp;gt;
&amp;lt;fx:root type=&amp;quot;javafx.scene.layout.AnchorPane&amp;quot;
            xmlns:fx=&amp;quot;http://javafx.com/fxml&amp;quot;&amp;gt;
    &amp;lt;children&amp;gt;
        &amp;lt;VBox&amp;gt;
            &amp;lt;children&amp;gt;
                &amp;lt;Button fx:id=&amp;quot;button&amp;quot; text=&amp;quot;Hello World&amp;quot; /&amp;gt;
                &amp;lt;CheckBox fx:id=&amp;quot;checkbox&amp;quot; text=&amp;quot;switch context&amp;quot;/&amp;gt;
                &amp;lt;TextField fx:id=&amp;quot;textFieldA&amp;quot;/&amp;gt;
                &amp;lt;TextField fx:id=&amp;quot;textFieldB&amp;quot;/&amp;gt;
                &amp;lt;Label fx:id=&amp;quot;label&amp;quot;/&amp;gt;
            &amp;lt;/children&amp;gt;
        &amp;lt;/VBox&amp;gt;

    &amp;lt;/children&amp;gt;

&amp;lt;/fx:root&amp;gt;
    &lt;/class&gt;&lt;/pre&gt;

With the button we will activate the calculation, with the checkbox we will switch the context.
To have a small as possible implementation, there is no error checking.
&lt;br/&gt;
The next will be the controller called DemoController. This is a normal JavaFX Controller, but CDI managed.
How to get this? Well there is a good blog article here ;-) &lt;a href="http://www.rapidpm.org/2013/08/javafxcdi-bootstrap-add-on.html"&gt;CDI JavaFX bootstrapping&lt;/a&gt;.
&lt;br/&gt;
Inside the DemoController we will get an Instance of the DemoLogic and the Context.
&lt;br /&gt;
&lt;pre class="brush: java"&gt;
@Inject
    @DynamicDecoratorTest
    Instance&amp;lt;DemoLogic&amp;gt; demoLogicInstance;

    @Inject
    Context context;
    &lt;/class&gt;&lt;/pre&gt;

The full implementation will be like the following.
&lt;br /&gt;
&lt;pre class="brush: java"&gt;
@DynamicDecoratorTest
public class DemoController implements Initializable{

    @FXML public TextField textFieldA;
    @FXML public TextField textFieldB;
    @FXML public Button button;
    @FXML public Label label;
    @FXML public CheckBox checkbox;

    @Inject
    @DynamicDecoratorTest
    Instance&amp;lt;DemoLogic&amp;gt; demoLogicInstance;

    @Inject
    Context context;

    @Override
    public void initialize(URL url, ResourceBundle resourceBundle) {
        button.setText(&amp;quot;klick me&amp;quot;);
        button.setOnAction(actionEvent -&amp;gt; {

            final DemoLogic demoLogic = demoLogicInstance.get();

            final String textFieldAText = textFieldA.getText();
            final Integer a = Integer.valueOf(textFieldAText);

            final String textFieldBText = textFieldB.getText();
            final Integer b = Integer.valueOf(textFieldBText);

            final int result = demoLogic.add(a, b);
            label.setText(result+&amp;quot;&amp;quot;);

        });

        checkbox.setOnAction(actionEvent -&amp;gt; {
            context.original = checkbox.isSelected();
        });
    }
}
    &lt;/class&gt;&lt;/pre&gt;

Inside the method initialize you will find the connection between the GUI logic and the business logic.
This is now clean devided.
&lt;br/&gt;
To test this I was using Arquillian. LAter we will see how we could do this with TestFX.
We are working on the CDI Support.

&lt;br /&gt;
&lt;pre class="brush: java"&gt;
@RunWith(Arquillian.class)
public class DemoLogicTest {
    @Deployment
    public static JavaArchive createDeployment() {
        return ShrinkWrap.create(JavaArchive.class)
                .addPackages(true, &amp;quot;org.rapidpm.demo&amp;quot;)
                .addPackages(true, &amp;quot;junit.org.rapidpm.demo&amp;quot;)
                .addPackages(true, &amp;quot;demo&amp;quot;)
                .addAsManifestResource(EmptyAsset.INSTANCE, &amp;quot;beans.xml&amp;quot;);
    }

    @Inject @DynamicDecoratorTest
    Instance&amp;lt;DemoController&amp;gt; demoControllerInstance;
    @Inject
    Context context;

    static final FXMLLoader loader = new FXMLLoader();

    @Test
    public void testDemoLogicJavaFXTest() throws Exception {
        loader.setControllerFactory(param -&amp;gt; demoControllerInstance.get());
        Application.launch(DemoApp.class);
    }


    public static class DemoApp extends Application {
        @Override
        public void start(Stage stage) throws Exception {

            final URL resource = getClass()
                    .getClassLoader()
                    .getResource(&amp;quot;DemoPane.fxml&amp;quot;);
            loader.setLocation(resource);
            final DemoController controller = (DemoController) loader
                    .getControllerFactory()
                    .call(DemoController.class);
            try {

                loader.setController(controller);
                loader.setRoot(new AnchorPane());
                final Parent root = (Parent) loader.load();

                stage.setScene(new Scene(root));
                stage.setTitle(&amp;quot;Custom Control&amp;quot;);
                stage.setWidth(300);
                stage.setHeight(200);
                stage.show();
            } catch (IOException exception) {
                throw new RuntimeException(exception);
            }

        }

        public static void main(String[] args) {
            launch(args);
        }
    }
}
    &lt;/class&gt;&lt;/pre&gt;
&lt;br/&gt;
You never need the decorator from CDI anymore. ;-)  
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>Java8 CompletableFuture for JavaFX and CDI Part I</title>
        <category label="CDI"/>
        <category label="Concurrency"/>
        <category label="Core Java"/>
        <category label="Java8"/>
        <category label="JavaFX"/>
        <published>2014-03-28T00:00:00+01:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2014/03/28/java8-completablefuture-for-javafx-and.html&gt;Java8 CompletableFuture for JavaFX and CDI Part I&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2014-03-28 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
Java8 CompletableFuture for JavaFX and CDI Part I

Java8 will give you a few more tools to solve concurrency problems.&lt;br/&gt;
One of them is the CompletableFuture. I will show you, how you could sync the &lt;br/&gt;
two different init-cycles from CDI and JavaFX with this.&lt;br/&gt;
&lt;br/&gt;
CDI and JavaFX are using a life-cycle during the init process. &lt;br/&gt;
For CDI you can use the method that is annotated with the &lt;br/&gt;
AnnotationLiteral @Postconstruct and for JavaFX you can use the method initialize(..)
&lt;br/&gt;
If you want to have a method that is called after both others are finished you have to think &lt;br/&gt;
about the problem that it is not clear which method is called first.&lt;br/&gt;
To show more in detail what the problem is let us think about the following.
&lt;br /&gt;
&lt;pre class="brush: java"&gt; 
private String pattern;
private SimpleDateFormat sdf;

//beispielhaft für eine init
public void createSDF(){
    this.sdf = new SimpleDateFormat(this.pattern);        
}

//beispielhaft für eine init
public void newPattern(final String pattern) {
    this.pattern = pattern;
}

public String format(final Date date){
    return sdf.fomat(date);
}
&lt;/pre&gt;

To use the method format(..) you must use the methods newPattern(..) and createSDF first.&lt;br/&gt;
But both in the right order like the following code snipp.
&lt;br /&gt;
&lt;pre class="brush: java"&gt; 
newPattern("yyyy.MM.dd");
createSDF();
final String s = versionAB.format(new Date());
System.out.println("s = " + s);
&lt;/pre&gt;
If you are calling first createSDF(..) for example you will get an exception.&lt;br/&gt;
But thinking to the problem with CDI and JavaFX it must be
valid to do something like the following.
&lt;br /&gt;
&lt;pre class="brush: java"&gt; 
createSDF();
newPattern("yyyy.MM.dd");

final String s = versionAB.format(new Date());
System.out.println("s = " + s);
&lt;/pre&gt;
The method creatdSDF(..) is called before newPattern(..).&lt;br/&gt;
The solution is quite simple. The method call from createSDF must be non blocking but&lt;br/&gt;
waiting with the execution until newPattern(..) was called.&lt;br/&gt;
The same with format(..). This method call must wait until both are finished but itself it &lt;br/&gt;
is an blocking method call. This is to give the developer the feeling he expected, &lt;br/&gt;
if he is working with the result from format(..).
&lt;br/&gt;
To solve this we have to booleans called initCompleteA and initCompleteB. &lt;br/&gt;
Both are false in the beginning. If newPattern(..) is called initcompleteA will be true, &lt;br/&gt;
and initCompleteB will be true after the method creatSDF() is ready.

&lt;br /&gt;
&lt;pre class="brush: java"&gt; 
public void newPattern(final String pattern) {
    this.pattern = pattern;
    initCompleteA=true;
    System.out.println("newPattern = " + pattern);
}
public void createSDF(){
    CompletableFuture&amp;lt;Void&amp;gt; supplyAsync
        = CompletableFuture
        .supplyAsync(taskCreateSDF, cachedThreadPool);
    supplyAsync.thenAccept(System.out::println);
}
public Supplier&amp;lt;Void&amp;gt; taskCreateSDF = ()-&amp;gt; {
    while(! initCompleteA ){
        try {
            System.out.println("createSDF is waiting" );
            TimeUnit.MILLISECONDS.sleep(4);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    sdf = new SimpleDateFormat(pattern);
    initCompleteB = true;
    return null;
};
&lt;/pre&gt;

The Method format(..) now is only waiting for both...
&lt;br /&gt;
&lt;pre class="brush: java"&gt; 
public Supplier&amp;lt;String&amp;gt; task = ()-&amp;gt; {
//Warten bis alle true
    while(! (initCompleteA &amp;&amp; initCompleteB) ){
        try {
            System.out.println("initCompleteA = " + initCompleteA);
            System.out.println("initCompleteB = " + initCompleteB);
            System.out.println("pattern = " + pattern);
            System.out.println("sdf = " + sdf);
            TimeUnit.MILLISECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    return sdf.format(this.date);
};
private Date date;

public String format(final Date date){
    this.date = date;
    supplyAsync = CompletableFuture
        .supplyAsync(task, cachedThreadPool);
    try {
        return supplyAsync.get();
    } catch (InterruptedException | ExecutionException e) {
        e.printStackTrace();
    }
    return "";
}
&lt;/pre&gt;

The example you will find at
&lt;a href="http://stash.rapidpm.org/projects/PUB/repos/jaxenter.de-0016-async-calls/browse"&gt;http://stash.rapidpm.org/projects/PUB/repos/jaxenter.de-0016-async-calls/browse&lt;/a&gt;
&lt;br/&gt;
The next Part will show how we have to implement
the JavaFX CDI bootstrapping to use this.

&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
</feed>
