<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>RapidPM</title>
    <category label="RapidPM"/>
    <updated>2014-12-19T12:17:15.694+01:00</updated>
    <id>http://rapidpm.github.io</id>
    <author>
        <name>Sven Ruppert</name>
    </author>
    <author>
        <name>Alexander Bischof</name>
    </author>
    <entry>
        <title>RapidPM Modules is added to our CI</title>
        <category label="CI"/>
        <category label="Jetbrains"/>
        <category label="RapidPM"/>
        <category label="TeamCity"/>
        <published>2013-08-27T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/08/27/rapidpm-modules-is-added-to-our-ci.html&gt;RapidPM Modules is added to our CI&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-08-27 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
Now we are happy to say, that RapidPM Modules is available at our TeamCity-Server. (&lt;a href="http://www.jetbrains.com/teamcity/" target="_blank"&gt;Thx JetBrains&lt;/a&gt;) &lt;br /&gt;
&lt;a href="http://teamcity.rapidpm.org/viewType.html?buildTypeId=MOD_ModulesDevelop"&gt;http://teamcity.rapidpm.org/viewType.html?buildT&lt;/a&gt;&lt;a href="http://teamcity.rapidpm.org/viewType.html?buildTypeId=MOD_ModulesDevelop"&gt;ypeId=MOD_ModulesDevelop&lt;/a&gt; (please login as guest) &lt;br /&gt;
&lt;br /&gt;
 &lt;a href="http://lh3.ggpht.com/-GN8ZP-7QF98/Uh0eVU5sk9I/AAAAAAABTTI/9oZSs0JyOms/s1600-h/image%25255B5%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh3.ggpht.com/-GJDRqQYM7t4/Uh0eWLh9OxI/AAAAAAABTTQ/4Wm5AT43aGg/image_thumb%25255B3%25255D.png?imgmax=800" height="413" style="border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline;" title="image" width="1028" /&gt;&lt;/a&gt;&lt;br /&gt;
  &lt;br /&gt;

&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>MultiLevel DrillDownPieChart in less then 30min as component for TableViews</title>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="Java"/>
        <category label="JavaFX"/>
        <category label="RapidPM"/>
        <category label="TableView"/>
        <category label="Weld"/>
        <published>2013-09-03T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/09/03/multilevel-drilldownpiechart-in-less-t.html&gt;MultiLevel DrillDownPieChart in less then 30min as component for TableViews&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-09-03 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
&lt;div style="text-align: center;"&gt;
    &lt;i&gt;&lt;span style="font-size: x-small;"&gt;The full code and demo jUnit you will find under :&amp;nbsp;&lt;a href="https://bitbucket.org/rapidpm/modules/src/265b5f577e8f9b5a875408a9659d58a02f72b1af/javafx-chart-pie-drilldown?at=develop" target="_blank"&gt;BitBucket Repo - RapidPM - Modules - javafx-chart-pie-drilldown&lt;/a&gt;&amp;nbsp;&lt;/span&gt;&lt;/i&gt;&lt;/div&gt;
&lt;div style="text-align: center;"&gt;
    &lt;i&gt;&lt;span style="font-size: x-small;"&gt;Please use the develop branch and a commit after&amp;nbsp;&lt;a href="https://bitbucket.org/rapidpm/modules/commits/265b5f577e8f9b5a875408a9659d58a02f72b1af?at=develop"&gt;265b5f5&lt;/a&gt;&amp;nbsp;&lt;/span&gt;&lt;/i&gt;&lt;/div&gt;
&lt;br /&gt;
Sometimes you want to have a drill down pi chart for a tableview. This code often looks like the following &lt;br /&gt;
(example from the oracle side)&lt;br /&gt;
&lt;a href="http://lh5.ggpht.com/-5KuGN_tnaic/UiYI9GTqX6I/AAAAAAABTXI/CKp7qJaPg8M/s1600-h/image%25255B3%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-ydmWK3GgtJk/UiYI9gFkecI/AAAAAAABTXM/tsHeNgJAvL0/image_thumb%25255B1%25255D.png?imgmax=800" height="484" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="530" /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
What you can see, is the direct way of putting the data together for each drilldown-level.&lt;br /&gt;
But if you want to drill down more than one level.. the code will be long.&lt;br /&gt;
For this example I am using the following demo data table.&lt;br /&gt;
&lt;br /&gt;
&lt;a href="http://lh6.ggpht.com/-Dln9HPL38mw/UiYI-gzJA7I/AAAAAAABTXY/l7uE_hEpjOc/s1600-h/image%25255B8%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh3.ggpht.com/-SnrHBEPMMHM/UiYI_MHshTI/AAAAAAABTXc/jFwz7iu2k_w/image_thumb%25255B4%25255D.png?imgmax=800" height="244" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="231" /&gt;&lt;/a&gt;&lt;br /&gt;
What I want to reach is a short way for a developer to aggregate from one row to an other (in both directions)&lt;br /&gt;
Here the pie–chart for this demo data and clicking the following steps:&lt;br /&gt;
Rows: Vorname-&amp;gt;Nachname-&amp;gt;Datum-&amp;gt;Betrag &lt;br /&gt;
Data: Holger-&amp;gt;Hoppel-&amp;gt;2013.10.01-&amp;gt;122.0 &lt;br /&gt;
&lt;a href="http://lh6.ggpht.com/-M8cJy_3fHmw/UiYI_txlqdI/AAAAAAABTXo/RRn5gXIi2LU/s1600-h/image%25255B11%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-CQyGxK2HMYI/UiYJAPlSEII/AAAAAAABTXs/ZZZHHNwgSFE/image_thumb%25255B5%25255D.png?imgmax=800" height="244" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="206" /&gt;&lt;/a&gt;&lt;a href="http://lh4.ggpht.com/-2_gTKMNX8mE/UiYJApNHhRI/AAAAAAABTX4/WFwxYSfYKUY/s1600-h/image%25255B14%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-FKGgdz6m5Co/UiYJBcGFtsI/AAAAAAABTYA/3Kyxlx2ij9Q/image_thumb%25255B6%25255D.png?imgmax=800" height="244" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; margin: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="191" /&gt;&lt;/a&gt;&lt;a href="http://lh4.ggpht.com/-IUAsBkI3mcs/UiYJCFnpZSI/AAAAAAABTYI/ILGKNlZsSsU/s1600-h/image%25255B17%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-K3YgnWkqaZM/UiYJCmmseGI/AAAAAAABTYQ/hDD7FDcvN90/image_thumb%25255B7%25255D.png?imgmax=800" height="244" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; margin: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="221" /&gt;&lt;/a&gt;&lt;a href="http://lh5.ggpht.com/-uIxOkfx3ZxU/UiYJDFf2Z7I/AAAAAAABTYY/hNh3S0nL0yo/s1600-h/image%25255B21%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-YUPfZV8MP3U/UiYJD_HH73I/AAAAAAABTYg/ZtSsq2GJljo/image_thumb%25255B9%25255D.png?imgmax=800" height="244" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="244" /&gt;&lt;/a&gt;&lt;br /&gt;
You can see, that for each level you will get the aggregated data from the table..&amp;nbsp; But how to do it?&lt;br /&gt;
The basic is the Aggregator-Class&lt;br /&gt;
&lt;script type="syntaxhighlighter" class="brush: java"&gt;&lt;![CDATA[
public abstract class MapAggregator&lt;T, K&gt; {

    private @Inject @CDILogger Logger logger;

    public abstract K getKeyElement(T t);

    public Map&lt;K, List&lt;T&gt;&gt; aggregate(final Collection&lt;T&gt; dataCollection) {
        final Map&lt;K, List&lt;T&gt;&gt; result = new HashMap&lt;&gt;();
        for (final T dataObject : dataCollection) {
            final K key = getKeyElement(dataObject);
            if (result.containsKey(key)) {
                if (logger.isDebugEnabled()) {
                    logger.debug("key schon vorhanden -&gt; " + key);
                }
            } else {
                result.put(key, new ArrayList&lt;T&gt;());
            }
            result.get(key).add(dataObject);
        }
        return result;
    }
}
]]&gt;&lt;/script&gt;
&lt;br /&gt;
&lt;span class="nt" style="background-color: ghostwhite; color: navy; font-family: Consolas, 'Liberation Mono', Courier, monospace; font-size: 14px; line-height: 19px; white-space: pre;"&gt;&lt;/span&gt;

With this you can aggregate a collection to a map. The key is the aggregated value from the collection elements.&lt;br /&gt;
For this example: A Collection of the TransientDemoDataRow (Collection&lt;transientdemodatarow&gt;) aggregated over the attribute vorname.&lt;/transientdemodatarow&gt;&lt;br /&gt;

&lt;script type="syntaxhighlighter" class="brush: java"&gt;&lt;![CDATA[
public class TransientDemoDataRow {


    private String vorname;
    private String nachname;
    private String datum;
    private Double betrag;

    @PostConstruct
    public void init() {

    }

    public String getVorname() {
        return vorname;
    }

    public void setVorname(String vorname) {
        this.vorname = vorname;
    }

    public String getNachname() {
        return nachname;
    }

    public void setNachname(String nachname) {
        this.nachname = nachname;
    }

    public String getDatum() {
        return datum;
    }

    public void setDatum(String datum) {
        this.datum = datum;
    }

    public Double getBetrag() {
        return betrag;
    }

    public void setBetrag(Double betrag) {
        this.betrag = betrag;
    }
}
]]&gt;&lt;/script&gt;
With our demo data table you will get a map with two collections. &lt;br /&gt;
a) Holger –&amp;gt; List of 6 elements&lt;br /&gt;
b) Willi –&amp;gt; List of 4 elements&lt;br /&gt;
This is the data for the first level of the DrillDownPieChart. (first pic of the pie charts see above)&lt;br /&gt;
For our DrillDownPieChart we are using the following aggregator extending the MapAggregator&lt;t&gt;.&lt;/t&gt;&lt;br /&gt;
&lt;t&gt;&lt;/t&gt;&lt;br /&gt;
&lt;script type="syntaxhighlighter" class="brush: java"&gt;&lt;![CDATA[
public abstract class DrillDownPieChartMapAggregator&lt;T&gt; extends MapAggregator&lt;T, String&gt; {


    /**
     * Calculate the Value for the PiChart.Data based on the aggregated values
     *
     * @param aggregatedValues
     * @return
     */
    public abstract double aggregateValue(List&lt;T&gt; aggregatedValues);

    public abstract String getLevelName();

    private DrillDownPieChartMapAggregator&lt;T&gt; nextLevelAggregator;
    private DrillDownPieChartMapAggregator&lt;T&gt; parentLevelAggregator;

    public DrillDownPieChartMapAggregator&lt;T&gt; getNextLevelAggregator() {
        return nextLevelAggregator;
    }

    public DrillDownPieChartMapAggregator&lt;T&gt; getParentLevelAggregator() {
        return parentLevelAggregator;
    }

    public void setNextLevelAggregator(DrillDownPieChartMapAggregator&lt;T&gt; nextLevelAggregator) {
        this.nextLevelAggregator = nextLevelAggregator;
        this.nextLevelAggregator.parentLevelAggregator = this;
    }

    public boolean isLastOne() {
        if (nextLevelAggregator == null) {
            return true;
        } else {
            return false;
        }
    }

    public boolean isFirstOne() {
        if (parentLevelAggregator == null) {
            return true;
        } else {
            return false;
        }
    }

}
]]&gt;&lt;/script&gt;
&lt;br /&gt;
We are holding the reference to the next level aggregator and the reference to the parent aggregator.&lt;br /&gt;
To implement the aggregator for each col. we want to use for our DrillDownPieChart we have to write code like the following&lt;br /&gt;
&lt;script type="syntaxhighlighter" class="brush: java"&gt;&lt;![CDATA[
public static class BetragAggregator extends DrillDownPieChartMapAggregator&lt;TransientDemoDataRow&gt; {
        @Override public double aggregateValue(List&lt;TransientDemoDataRow&gt; aggregatedValues) {
            double betrag = 0;
            for (final TransientDemoDataRow aggregatedValue : aggregatedValues) {
                betrag = betrag + aggregatedValue.getBetrag();
            }
            return betrag;
        }

        @Override public String getLevelName() {
            return "Betrag";
        }

        @Override public String getKeyElement(TransientDemoDataRow transientDemoDataRow) {
            return transientDemoDataRow.getBetrag() + " € Beträge";
        }
    }

    public static class DatumAggregator extends DrillDownPieChartMapAggregator&lt;TransientDemoDataRow&gt; {
        @Override public double aggregateValue(List&lt;TransientDemoDataRow&gt; aggregatedValues) {
            return aggregatedValues.size();
        }

        @Override public String getLevelName() {
            return "Datum";
        }
        @Override public String getKeyElement(TransientDemoDataRow transientDemoDataRow) {
            return transientDemoDataRow.getDatum();
        }
    }

    public static class VornameAggregator extends DrillDownPieChartMapAggregator&lt;TransientDemoDataRow&gt; {
        @Override public double aggregateValue(List&lt;TransientDemoDataRow&gt; aggregatedValues) {
            return aggregatedValues.size();
        }

        @Override public String getLevelName() {
            return "Vorname";
        }

        @Override public String getKeyElement(TransientDemoDataRow transientDemoDataRow) {
            return transientDemoDataRow.getVorname();
        }
    }


    public static class NachnameAggregator extends DrillDownPieChartMapAggregator&lt;TransientDemoDataRow&gt; {
        @Override public double aggregateValue(List&lt;TransientDemoDataRow&gt; aggregatedValues) {
            return aggregatedValues.size();
        }

        @Override public String getLevelName() {
            return "Nachname";
        }
        @Override public String getKeyElement(TransientDemoDataRow transientDemoDataRow) {
            return transientDemoDataRow.getNachname();
        }
    }

]]&gt;&lt;/script&gt;
&lt;br /&gt;
The method getLevelName is to label the PieChart for the user.&lt;br /&gt;
The method getKeyElement is the value used for the aggregation.&lt;br /&gt;
The method aggregateValue is to calculate the double, used by the pie chart as value.&lt;br /&gt;
After this you have to put all together… the logic-part is done now..&lt;br /&gt;
&lt;script type="syntaxhighlighter" class="brush: java"&gt;&lt;![CDATA[
public class DrillDownPieChartPaneController implements CDIJavaFxBaseController {

    @FXML DemoDrillDownPieChart piechart;


    @Inject Instance&lt;VornameAggregator&gt; vornameAggregatorInstance;
    @Inject Instance&lt;NachnameAggregator&gt; nachnameAggregatorInstance;
    @Inject Instance&lt;DatumAggregator&gt; datumAggregatorInstance;
    @Inject Instance&lt;BetragAggregator&gt; betragAggregatorInstance;


    @Override public void initialize(URL url, ResourceBundle resourceBundle) {

        //setze Aggregatoren
        final VornameAggregator vornameAggregator = vornameAggregatorInstance.get();

        final NachnameAggregator nachnameAggregator = nachnameAggregatorInstance.get();
        vornameAggregator.setNextLevelAggregator(nachnameAggregator);

        final DatumAggregator datumAggregator = datumAggregatorInstance.get();
        nachnameAggregator.setNextLevelAggregator(datumAggregator);

        final BetragAggregator betragAggregator = betragAggregatorInstance.get();
        datumAggregator.setNextLevelAggregator(betragAggregator);

        piechart.setRootAggregator(vornameAggregator);

    }


    public void init() {
        piechart.init();
    }

]]&gt;&lt;/script&gt;
The gui part looks like this: Extending the DrillDownPieChart with the type you need as data holder, here the TransientDemoDataRow.&lt;br /&gt;
&lt;script type="syntaxhighlighter" class="brush: java"&gt;&lt;![CDATA[
public class TransientDemoDataRow {


    private String vorname;
    private String nachname;
    private String datum;
    private Double betrag;

    @PostConstruct
    public void init() {

    }

    public String getVorname() {
        return vorname;
    }

    public void setVorname(String vorname) {
        this.vorname = vorname;
    }

    public String getNachname() {
        return nachname;
    }

    public void setNachname(String nachname) {
        this.nachname = nachname;
    }

    public String getDatum() {
        return datum;
    }

    public void setDatum(String datum) {
        this.datum = datum;
    }

    public Double getBetrag() {
        return betrag;
    }

    public void setBetrag(Double betrag) {
        this.betrag = betrag;
    }
}
]]&gt;&lt;/script&gt;
and putting it to a fxml file.&lt;br /&gt;
&lt;script type="syntaxhighlighter" class="brush: javafx"&gt;&lt;![CDATA[
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;?import gui.org.rapidpm.modul.javafx.chart.pie.drilldown.DemoDrillDownPieChart?&gt;
&lt;?import javafx.scene.control.Label?&gt;
&lt;?import javafx.scene.layout.AnchorPane?&gt;
&lt;?import javafx.scene.layout.VBox?&gt;
&lt;fx:root type="gui.org.rapidpm.modul.javafx.chart.pie.drilldown.DrillDownPieChartPane"
         fx:id="DrillDownPieChartPane" xmlns:fx="http://javafx.com/fxml" style="-fx-background-color:#EEEEEE"&gt;

    &lt;children&gt;
        &lt;AnchorPane minHeight="0.0" minWidth="0.0" VBox.vgrow="ALWAYS"
                    AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0"&gt;
            &lt;children&gt;
                &lt;Label text="hallo Hier bin ich"/&gt;
                &lt;DemoDrillDownPieChart fx:id="piechart"&gt;

                &lt;/DemoDrillDownPieChart&gt;
            &lt;/children&gt;
        &lt;/AnchorPane&gt;
    &lt;/children&gt;
&lt;/fx:root&gt;
]]&gt;&lt;/script&gt;
ready…&amp;nbsp; &lt;br /&gt;
&lt;br /&gt;
The steps for a developer are:&lt;br /&gt;
1) writing the transient data holder for an row –&amp;gt; TransientDemoDataRow&lt;br /&gt;
2) extending the DrillDownPieChart –&amp;gt; DemoDrillDownPieChart extends&lt;transientdemodatarow&gt;&lt;/transientdemodatarow&gt;&lt;br /&gt;
3) extending the DrillDownPieChartMapAggregator –&amp;gt; NachnameAggregator extends DrillDownPieChartMapAggregator&lt;transientdemodatarow&gt;&lt;/transientdemodatarow&gt;&lt;br /&gt;
4) putting all aggregator implementations together –&amp;gt; Controller – Class&lt;br /&gt;
5) add the element to the fxml file, &lt;br /&gt;
6) init() and ready&lt;br /&gt;
For a normal TableView with a handfull of rows you will need less than 30 min.&lt;br /&gt;
&lt;br /&gt;
The basic classes to use for an developer:&lt;br /&gt;
&lt;a href="http://lh3.ggpht.com/-SJ-pDNpLOMc/UiYJNA9ohpI/AAAAAAABTaY/ofUQV5uIuEk/s1600-h/image%25255B54%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh4.ggpht.com/-WMXinq5fTd8/UiYJNoBLSEI/AAAAAAABTag/WlbvOUwDZsk/image_thumb%25255B26%25255D.png?imgmax=800" height="484" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="513" /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
All classes from the jUnit demo available at the javafx-chart-pie-drilldown module.&lt;br /&gt;
&lt;a href="http://lh6.ggpht.com/-lP1udVyDMVA/UiYJOSIqFfI/AAAAAAABTao/rEssoxks5Gs/s1600-h/image%25255B58%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh3.ggpht.com/-LiWMRqCVT5A/UiYJPDrwyVI/AAAAAAABTaw/huD7OwGJooI/image_thumb%25255B28%25255D.png?imgmax=800" height="362" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="644" /&gt;&lt;/a&gt;

&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>CDI - ComboBoxCell - How to reduce 80% of code</title>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="FilteredTableView"/>
        <category label="Java"/>
        <category label="JavaFX"/>
        <category label="RapidPM"/>
        <category label="TableView"/>
        <category label="Weld"/>
        <published>2013-09-06T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/09/06/cdi-comboboxcell-how-to-reduce-80%-of-.html&gt;CDI - ComboBoxCell - How to reduce 80% of code&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-09-06 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
&lt;div style="text-align: center;"&gt;
    &lt;i&gt;&lt;span style="font-size: x-small;"&gt;The full code and demo jUnit you will find under :&amp;nbsp;&lt;a href="https://bitbucket.org/rapidpm/modules/src/aec4f95e0ae3130f62bc79170c0233cf49e43299/javafx-filtered-tableview?at=develop" target="_blank"&gt;BitBucket Repo - RapidPM - Modules - javafx-filtered-tableview&lt;/a&gt;&amp;nbsp;&lt;/span&gt;&lt;/i&gt;&lt;/div&gt;
&lt;div style="text-align: center;"&gt;
    &lt;i&gt;&lt;span style="font-size: x-small;"&gt;Please use the develop branch and a commit after&amp;nbsp;&lt;a href="https://bitbucket.org/rapidpm/modules/commits/265b5f577e8f9b5a875408a9659d58a02f72b1af?at=develop"&gt;aec4f95&lt;/a&gt;&amp;nbsp;&lt;/span&gt;&lt;/i&gt;&lt;/div&gt;
&lt;br /&gt;
&lt;br /&gt;
Today I had a TableView with the following function.&lt;br /&gt;
- In one column there was a ComboBoxCell.&lt;br /&gt;
- The values of this ComboBox was calculated / loaded at the moment the combobox was used.&lt;br /&gt;
- Each ComboBox will have different values based on the context of this row.&lt;br /&gt;
&lt;br /&gt;
The first version was something like this:&lt;br /&gt;
A ComboBoxCell:&lt;br /&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class LegacyBetragComboBoxCell extends ComboBoxTableCell&lt;TransientDemoDataRow, Double&gt; {

    private @Inject @CDILogger Logger logger;
    private boolean readOnlyView = false;

    @Inject Instance&lt;contextlogic&gt; contextLogicInstance; //some injected business logic;

    @Override
    public void updateItem(Double o, boolean b) {
        if (logger.isDebugEnabled()) {
            logger.debug("ComboBoxTableCell-&gt;updateItem " + o);
        }
        super.updateItem(o, b);
        if (o == null) {
            //
        } else {
            final TableRow tableRow = getTableRow();
            final TransientDemoDataRow row = (TransientDemoDataRow) tableRow.getItem();
            getItems().clear();
            if (row.getBetrag() == null || row.getBetrag().isInfinite() || row.getBetrag().isNaN()) {
                this.setDisable(true);
            } else if (readOnlyView) {
                this.setDisable(true);
            } else {
                final ContextLogic contextLogic = contextLogicInstance.get();
                final List&lt;double&gt; doubleList = contextLogic.workOnContext(row.getBetrag());

                getItems().addAll(doubleList);

                this.setDisable(false);
            }
            //application logic on row itself
            //application logic external
        }
    }


    public boolean isReadOnlyView() {
        return readOnlyView;
    }

    public void setReadOnlyView(boolean readOnlyView) {
        this.readOnlyView = readOnlyView;
    }
}
]]&gt;&lt;/script&gt;


and the code called from the controller:&lt;br /&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
    @Inject Instance&lt;legacybetragcomboboxcell&gt; legacyBetragComboBoxCellInstance;

    private void initTable() {
        final ObservableList&lt;TableColumn&lt;TransientDemoDataRow, ?&gt;&gt; columns = tableView.getColumns();
        for (final TableColumn&lt;TransientDemoDataRow, ?&gt; column : columns) {
            if(column.getText().equals("betrag")){
                final TableColumn&lt;TransientDemoDataRow, Double&gt; colTyped =(TableColumn&lt;TransientDemoDataRow, Double&gt;) column;
                colTyped.setCellFactory(new Callback&lt;TableColumn&lt;TransientDemoDataRow, Double&gt;, TableCell&lt;TransientDemoDataRow, Double&gt;&gt;() {
                    @Override public TableCell&lt;TransientDemoDataRow, Double&gt; call(TableColumn&lt;TransientDemoDataRow, Double&gt; transientDemoDataRowTableColumn) {
                        final LegacyBetragComboBoxCell cell = legacyBetragComboBoxCellInstance.get();
                        cell.setComboBoxEditable(false);  //true if you want bidirectional dataflow
                        return  cell;
                    }
                });

            } else{
                //other col
            }
        }
    }
]]&gt;&lt;/script&gt;

&lt;br /&gt;
This is to much boilerplate code. So I started to reduce it.&lt;br /&gt;
&lt;br /&gt;
First step was reducing the generics..&lt;br /&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
    @Inject Instance&lt;betragcomboboxcell&gt; betragComboBoxCellInstance;

    private void initTable() {
        final ObservableList&lt;TableColumn&lt;TransientDemoDataRow, ?&gt;&gt; columns = tableView.getColumns();
        for (final TableColumn column : columns) {
            if (column.getText().equals("betrag")) {
                column.setCellFactory(new Callback&lt;TableColumn, TableCell&gt;() {
                    @Override public TableCell call(TableColumn tableColumn) {
                        final BetragComboBoxCell cell = betragComboBoxCellInstance.get();
                        cell.setComboBoxEditable(false);  //true if you want bidirectional dataflow
                        return cell;
                    }
                });

            } else {
                //other col
            }
        }
    }
]]&gt;&lt;/script&gt;
This is shorter, but not better...&amp;nbsp;
&lt;br /&gt;
&lt;br /&gt;
The solution is the abstract GenericComboBoxCell. (part of the &lt;a href="https://bitbucket.org/rapidpm/modules/src/cd6e925b21196fc3e3a5f7b26abe879ed6add129/javafx-filtered-tableview?at=develop" target="_blank"&gt;javafx-filtered-tableview module&lt;/a&gt;)&lt;br /&gt;
&lt;br /&gt;
Iterating over the columns are now part of the GenericComboBoxCell, and here will be the typesave code.&lt;br /&gt;
&lt;br /&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public abstract class GenericComboBoxCell&lt;RT, VT&gt; extends ComboBoxTableCell&lt;RT, VT&gt; {

    private @Inject @CDILogger Logger logger;
    private boolean readOnlyView = false;

    @Override
    public void updateItem(VT o, boolean b) {
        if (logger.isDebugEnabled()) {
            logger.debug("ComboBoxTableCell-&gt;updateItem " + o);
        }
        super.updateItem(o, b);
        if (o == null) {
            //
        } else {
            final TableRow tableRow = getTableRow();
            final RT row = (RT) tableRow.getItem();
            getItems().clear();
            if (disableComboBox(row)) {
                this.setDisable(true);
            } else if (readOnlyView) {
                this.setDisable(true);
            } else {

                final List&lt;vt&gt; comboBoxValues = createComboBoxValues(row);
                getItems().addAll(comboBoxValues);

                this.setDisable(false);
            }
            workOnRowItself(row);
        }
    }

    public void associateWithCol(final TableView&lt;rt&gt; tableView, final String colName) {
        final ObservableList&lt;TableColumn&lt;RT, ?&gt;&gt; columns = tableView.getColumns();
        for (final TableColumn&lt;RT, ?&gt; column : columns) {
            final String columnText = column.getText();
            if (columnText.equals(colName)) {
                if (logger.isDebugEnabled()) {
                    logger.debug("associating to col " + columnText);
                }
                associate((TableColumn&lt;RT, VT&gt;) column);
            } else {
                if (logger.isDebugEnabled()) {
                    logger.debug("not binding to this col : " + columnText);
                }
            }
        }
    }

    private void associate(TableColumn&lt;RT, VT&gt; column) {
        column.setCellFactory(new Callback&lt;TableColumn&lt;RT, VT&gt;, TableCell&lt;RT, VT&gt;&gt;() {
            @Override
            public TableCell&lt;RT, VT&gt; call(TableColumn&lt;RT, VT&gt; rtTableColumn) {
                final GenericComboBoxCell&lt;RT, VT&gt; mySelf = getComboBoxCellRef();
                mySelf.setComboBoxEditable(false);
                mySelf.setReadOnlyView(readOnlyView);
                return mySelf;
            }
        });
    }

    protected abstract GenericComboBoxCell&lt;RT, VT&gt; getComboBoxCellRef();

    /**
     * logic to disable the combobox, for example if the value ist null or ...
     *
     * @return
     */
    public abstract boolean disableComboBox(final RT row);

    public abstract List&lt;vt&gt; createComboBoxValues(final RT row);

    public abstract void workOnRowItself(final RT row);


    public boolean isReadOnlyView() {
        return readOnlyView;
    }

    public void setReadOnlyView(boolean readOnlyView) {
        this.readOnlyView = readOnlyView;
    }
}
]]&gt;&lt;/script&gt;

The developer must extend this class and has to implement the following methods only:&lt;br /&gt;
- protected abstract GenericComboBoxCell&lt;rt vt=""&gt; getComboBoxCellRef();&amp;nbsp;&lt;/rt&gt;&lt;br /&gt;
&lt;rt vt=""&gt;- public abstract boolean disableComboBox(final RT row); (optional)&amp;nbsp;&lt;/rt&gt;&lt;br /&gt;
&lt;rt vt=""&gt;- public abstract List&lt;vt&gt; createComboBoxValues(final RT row);&amp;nbsp;&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;rt vt=""&gt;&lt;vt&gt;- public abstract void workOnRowItself(final RT row); (optional)&amp;nbsp;&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;rt vt=""&gt;&lt;vt&gt;A demo implementation is shown here:&amp;nbsp;&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class BetragComboBoxCell extends GenericComboBoxCell&lt;TransientDemoDataRow, Double&gt; {

    @Inject Instance&lt;contextlogic&gt; contextLogicInstance; //business logic
    @Inject Instance&lt;betragcomboboxcell&gt; betragComboBoxCellInstance; //the cell instance itself

    @Override
    protected GenericComboBoxCell&lt;TransientDemoDataRow, Double&gt; getComboBoxCellRef() {
        return betragComboBoxCellInstance.get();
    }

    @Override public boolean disableComboBox(TransientDemoDataRow row) {
        return row.getBetrag() == null || row.getBetrag().isInfinite() || row.getBetrag().isNaN();
    }

    @Override public List&lt;double&gt; createComboBoxValues(TransientDemoDataRow row) {
        final ContextLogic contextLogic = contextLogicInstance.get();
        final List&lt;double&gt; doubleList = contextLogic.workOnContext(row.getBetrag());
        return doubleList;
    }

    @Override public void workOnRowItself(TransientDemoDataRow row) {
        //nothing for this example
    }
}
]]&gt;&lt;/script&gt;


&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;rt vt=""&gt;&lt;vt&gt;The controlle will need a piece of code like this:&amp;nbsp;&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
    @Inject Instance&lt;betragcomboboxcell&gt; betragComboBoxCellInstance;

    private void initTable() {
        final BetragComboBoxCell cell = betragComboBoxCellInstance.get();
        cell.associateWithCol(tableView, "betrag");
    }
]]&gt;&lt;/script&gt;

&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;rt vt=""&gt;&lt;vt&gt;With this you can test the context logic indepentend from the javafx stuff.&amp;nbsp;&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;rt vt=""&gt;&lt;vt&gt;All initializations inside a ComboBoxCell must be done in a PostConstruct - method.&amp;nbsp;&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;rt vt=""&gt;&lt;vt&gt;With the&amp;nbsp;GenericComboBoxCell&amp;nbsp;you can activate/deactivate the combobox, modify the row cell values, and create the combobox values.&amp;nbsp;&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;rt vt=""&gt;&lt;vt&gt;This implementation is based on the JavaFX/CDI bootstrap from cdi-commons-fx. (blog entry &lt;a href="http://www.rapidpm.org/2013/08/cdicommonsfx-javafxcdi-bootstrap.html" target="_blank"&gt;JavaFX/CDI bootstrap&lt;/a&gt; )&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://2.bp.blogspot.com/-AQ7GFqVQD4U/Uin3Zyv-FxI/AAAAAAABTbs/Kp70aYegR3U/s1600/tableview001.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://2.bp.blogspot.com/-AQ7GFqVQD4U/Uin3Zyv-FxI/AAAAAAABTbs/Kp70aYegR3U/s1600/tableview001.jpg" height="216" width="320" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://2.bp.blogspot.com/-8qDppXPeXes/Uin3Z_Su-pI/AAAAAAABTb4/BLIB0FT2cLI/s1600/tableview002.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://2.bp.blogspot.com/-8qDppXPeXes/Uin3Z_Su-pI/AAAAAAABTb4/BLIB0FT2cLI/s1600/tableview002.jpg" height="218" width="320" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;rt vt=""&gt;&lt;vt&gt;UML of this demo:&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://1.bp.blogspot.com/-ePJ6s1IzMKE/Uiny8-L--tI/AAAAAAABTbY/3hK_OgfHDPc/s1600/uml.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img alt="" border="0" src="http://1.bp.blogspot.com/-ePJ6s1IzMKE/Uiny8-L--tI/AAAAAAABTbY/3hK_OgfHDPc/s1600/uml.png" height="608" title="" width="640" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;rt vt=""&gt;&lt;vt&gt;Full CDI dependicies&lt;/vt&gt;&lt;/rt&gt;&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://4.bp.blogspot.com/-1CreRx6oh_I/UinzViniCcI/AAAAAAABTbg/E6C0MdnnRTQ/s1600/cdi-deps.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://4.bp.blogspot.com/-1CreRx6oh_I/UinzViniCcI/AAAAAAABTbg/E6C0MdnnRTQ/s1600/cdi-deps.png" height="254" width="640" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;rt vt=""&gt;&lt;vt&gt;&lt;br /&gt;&lt;/vt&gt;&lt;/rt&gt;
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>Where to find the cdi-commons and javafx modules ?</title>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="JavaFX"/>
        <category label="RapidPM"/>
        <published>2013-09-10T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/09/10/where-to-find-the-cdi-commons-and-java.html&gt;Where to find the cdi-commons and javafx modules ?&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-09-10 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
Since RapidPM-Modules is available at the central repo (&lt;a href="http://www.sonatype.org/central"&gt;Thanks SonarType&lt;/a&gt;), we are using the following repositories.&lt;br /&gt;
&lt;br /&gt;
For development: (no stable builds/ development branch ci )&lt;br /&gt;
&lt;br /&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href="http://nexus.rapidpm.org/nexus/index.html#welcome"&gt;http://nexus.rapidpm.org/nexus/index.html#welcome&lt;/a&gt;/ (snapshots)&lt;/li&gt;
    &lt;li&gt;&lt;a href="http://nexus.rapidpm.org/nexus/index.html#welcome"&gt;http://nexus.rapidpm.org/nexus/content/groups/public&lt;/a&gt;&amp;nbsp;(mirror
        for needed artifacts)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;
    For Releases and Snapshots from the release-branches/master-branch&lt;/div&gt;
&lt;div&gt;
    &lt;ul&gt;
        &lt;li&gt;Releases&amp;nbsp;&lt;a href="http://search.maven.org/#search%7Cga%7C1%7Crapidpm"&gt;http://search.maven.org/&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;RC &lt;a href="https://oss.sonatype.org/index.html#view-repositories;snapshots~browsestorage"&gt;https://oss.sonatype.org/&lt;/a&gt;&amp;nbsp;&lt;/li&gt;
    &lt;/ul&gt;
    &lt;div&gt;
        &lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>FullText - SearchBox for TableView Part I</title>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="JavaFX"/>
        <category label="RapidPM"/>
        <published>2013-09-10T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/09/10/fulltext-searchbox-for-tableview-part-.html&gt;FullText - SearchBox for TableView Part I&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-09-10 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
How to combine a FullTextSearch with a TableView?&lt;br /&gt;
I would say, you will need 30 min max ;-) But How?&lt;br /&gt;
Short version :&lt;br /&gt;
&lt;br /&gt;
&lt;ul&gt;
    &lt;li&gt;implementing 2 small methods&lt;/li&gt;
    &lt;li&gt;put a SearchBox element to the fxml file&lt;/li&gt;
    &lt;li&gt;combine the TableView with the SearchBox&amp;nbsp;&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
Long version:&lt;br /&gt;
Let´s start with the correspondings jUnit.&lt;br /&gt;
&lt;br /&gt;
As described (&lt;a href="http://www.rapidpm.org/2013/09/cdi-comboboxcell-how-to-reduce-80-of.html"&gt;here&lt;/a&gt;)&amp;nbsp;we will start with a small demo - jUnit, containing a TableView.&lt;br /&gt;
To make the example smaller I will use a default TableView.&lt;br /&gt;
&lt;br /&gt;
&lt;div style="text-align: center;"&gt;
    &lt;span style="font-size: x-small;"&gt;&lt;i&gt;The full code and demo jUnit you will find under : BitBucket Repo - RapidPM - Modules - javafx-searchbox&amp;nbsp;&lt;/i&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="text-align: center;"&gt;
    &lt;span style="font-size: x-small;"&gt;&lt;i&gt;Please use &amp;nbsp;a commit after&amp;nbsp;&lt;/i&gt;&lt;/span&gt;&lt;a class="execute" href="https://bitbucket.org/rapidpm/modules/commits/59237d342eec977e8aece0c83a96ab3d0dca5856?at=release/1.1.1" style="background-color: whitesmoke; color: #3b73af; font-family: Monaco, monospace; font-size: 12px;"&gt;59237d3&lt;/a&gt;&lt;/div&gt;
&lt;br /&gt;
The application based on the &lt;b&gt;SearchBoxDemoPane&lt;/b&gt;&lt;br /&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class SearchBoxDemoPane extends CDIBaseAnchorPane&lt;SearchBoxDemoPane, SearchBoxDemoPaneController&gt; {
    @Override public Class&lt;searchboxdemopane&gt; getPaneClass() {
        return SearchBoxDemoPane.class;
    }
}
]]&gt;&lt;/script&gt;

with the &lt;b&gt;SearchBoxDemoPaneController&lt;/b&gt;.&lt;br /&gt;
&lt;br /&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class SearchBoxDemoPaneController implements CDIJavaFxBaseController {

    private @Inject @CDILogger Logger logger;

    @Inject @CDIPropertyRegistryService PropertyRegistryService propertyRegistryService;
    @Inject DemoKeyMapper keyMapper;
    @Inject Instance&lt;transientdemorowcomparator&gt; comparatorInstance;

    @FXML public TableView&lt;transientdemodatarow&gt; tableView;
    @FXML public SearchBox SearchBox;

    @Override public void initialize(URL url, ResourceBundle resourceBundle) {
        initTable();
        setI18n();

        //init SearchBox
        refreshIndex();

    }

    private void refreshIndex() {
        final ObservableList&lt;transientdemodatarow&gt; items = tableView.getItems();
        SearchBox.refreshIndex(items);
    }

    private void initTable() {

    }

    private void setI18n() {
        final ObservableList&lt;TableColumn&lt;TransientDemoDataRow, ?&gt;&gt; col = tableView.getColumns();
        for (final TableColumn column : col) {
            final String text = column.getText();
            final String map = map(text);
            if (logger.isDebugEnabled()) {
                logger.debug("text -&gt; " + text);
                logger.debug("map -&gt; " + map);
            }
            column.setText(map);
        }
    }

    private String map(final String key) {
        return propertyRegistryService.getRessourceForKey(keyMapper.map(key));
    }

}
]]&gt;&lt;/script&gt;

and the transient data for the TableView&amp;nbsp;&lt;b&gt;TransientDemoDataRow&lt;/b&gt;&lt;br /&gt;
The importand part is the implementation of the Interface SearchBoxDataElement, this will make the connection between the index and the full-text search later.&lt;br /&gt;
&lt;br /&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class TransientDemoDataRow implements Serializable, SearchBoxDataElement {

    @Inject @CDIPropertyRegistryService PropertyRegistryService propertyRegistryService;
    @Inject DemoKeyMapper keyMapper;

    private StringProperty vorname;
    private StringProperty nachname;
    private StringProperty datum;
    private SimpleDoubleProperty betrag;

    private SimpleLongProperty ID; //normaly a normal Long, not shown at the table

    @PostConstruct
    public void init() {
        vorname = new SimpleStringProperty(this, map("vorname"));
        nachname = new SimpleStringProperty(this, map("nachname"));
        datum = new SimpleStringProperty(this, map("datum"));
        betrag = new SimpleDoubleProperty(this, map("betrag"));
        ID = new SimpleLongProperty(this, map("ID"));
    }

    private String map(final String key) {
        return propertyRegistryService.getRessourceForKey(keyMapper.map(key));
    }

//.. snip getter / setter

    public Long getID() {
        return ID.get();
    }

    public SimpleLongProperty IDProperty() {
        return ID;
    }

    public void setID(long ID) {
        this.ID.set(ID);
    }

    @Override public List&lt;string&gt; getValues() {
        return Lists.newArrayList(getID() + "", getVorname(), getNachname(), getDatum(), getBetrag() + "");
    }

    @Override public String shortInfo() {
        return getID() + " - " + getVorname() + " - " + getNachname() + " - " + getDatum() + " - " + getBetrag() + "";
    }
}
]]&gt;&lt;/script&gt;

&lt;br /&gt;
&lt;div&gt;
    Now we will put the SearchBox to the fxml.&lt;/div&gt;
&lt;div&gt;
    This is only one line&amp;nbsp;&lt;/div&gt;
&lt;div&gt;
    &lt;span style="font-size: x-small;"&gt;&lt;i&gt;&lt;b&gt;&amp;nbsp;&amp;lt;SearchBox fx:id="SearchBox" visible="true" minHeight="24.00"&lt;/b&gt;&lt;/i&gt;&lt;/span&gt;&lt;i style="font-size: small;"&gt;&lt;b&gt;&amp;nbsp;prefWidth="1024.0" maxWidth="-Infinity"/&amp;gt;&lt;/b&gt;&lt;/i&gt;&lt;/div&gt;
&lt;div&gt;
    &lt;br /&gt;&lt;/div&gt;
&lt;script class="brush: javafx" type="syntaxhighlighter"&gt;&lt;![CDATA[
&lt;?import java.net.URL?&gt;
&lt;?import javafx.scene.control.cell.PropertyValueFactory?&gt;
&lt;?import javafx.scene.control.ScrollPane?&gt;
&lt;?import javafx.scene.control.TableColumn?&gt;
&lt;?import javafx.scene.control.TableView?&gt;
&lt;?import javafx.scene.layout.AnchorPane?&gt;
&lt;?import javafx.scene.layout.HBox?&gt;
&lt;?import javafx.scene.layout.VBox?&gt;
&lt;?import org.rapidpm.demo.javafx.searchbox.searchbox.SearchBox?&gt;
&lt;fx:root type="gui.org.rapidpm.demo.javafx.searchbox.demo.SearchBoxDemoPane"
         fx:id="SearchBoxDemoPane" xmlns:fx="http://javafx.com/fxml" style="-fx-background-color:#EEEEEE"&gt;
    &lt;stylesheets&gt;
        &lt;url value="@/main.css"/&gt;
    &lt;/stylesheets&gt;
    &lt;children&gt;
        &lt;vbox AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0"&gt;
            &lt;hbox maxHeight="24.00" maxWidth="Infinity" VBox.vgrow="NEVER"&gt;
                &lt;searchbox fx:id="SearchBox" visible="true" minHeight="24.00" prefWidth="5000.0" maxWidth="-Infinity"/&gt;
            &lt;/HBox&gt;
            &lt;anchorpane minHeight="0.0" minWidth="0.0" VBox.vgrow="ALWAYS"
                        AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0"&gt;
                &lt;children&gt;
                    &lt;scrollpane fitToHeight="true" fitToWidth="true" AnchorPane.bottomAnchor="0.0"
                                AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0"&gt;
                        &lt;tableview fx:id="tableView" editable="true" VBox.vgrow="ALWAYS" style="-fx-font-size: 80%"
                                   tableMenuButtonVisible="true"&gt;
                            &lt;columns&gt;
                                &lt;tablecolumn prefWidth="120.0" text="id"&gt;
                                    &lt;cellvaluefactory&gt;
                                        &lt;propertyvaluefactory property="ID"/&gt;
                                    &lt;/cellValueFactory&gt;
                                &lt;/TableColumn&gt;
                                &lt;tablecolumn prefWidth="120.0" text="vorname"&gt;
                                    &lt;cellvaluefactory&gt;
                                        &lt;propertyvaluefactory property="vorname"/&gt;
                                    &lt;/cellValueFactory&gt;
                                &lt;/TableColumn&gt;
                                &lt;tablecolumn prefWidth="120.0" text="nachname"&gt;
                                    &lt;cellvaluefactory&gt;
                                        &lt;propertyvaluefactory property="nachname"/&gt;
                                    &lt;/cellValueFactory&gt;
                                &lt;/TableColumn&gt;
                                &lt;tablecolumn prefWidth="120.0" text="datum"&gt;
                                    &lt;cellvaluefactory&gt;
                                        &lt;propertyvaluefactory property="datum"/&gt;
                                    &lt;/cellValueFactory&gt;
                                &lt;/TableColumn&gt;
                                &lt;tablecolumn prefWidth="120.0" text="betrag"&gt;
                                    &lt;cellvaluefactory&gt;
                                        &lt;propertyvaluefactory property="betrag"/&gt;
                                    &lt;/cellValueFactory&gt;
                                &lt;/TableColumn&gt;
                            &lt;/columns&gt;
                        &lt;/TableView&gt;
                    &lt;/ScrollPane&gt;
                &lt;/children&gt;
            &lt;/AnchorPane&gt;
        &lt;/VBox&gt;
    &lt;/children&gt;
&lt;/fx:root&gt;

]]&gt;&lt;/script&gt;

Finally we are implementing the jUnit Test (&lt;a href="http://www.rapidpm.org/2013/08/cdicommonsfx-javafxcdi-bootstrap.html"&gt;more info about cdi javaFX bootstraping&lt;/a&gt;)&lt;br /&gt;
like this one.&lt;br /&gt;
&lt;br /&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class SearchBoxTest extends JavaFXBaseTest {
    @Override protected Class&lt;? extends JavaFXBaseTest&gt; getTestClass() {
        return SearchBoxTest.class;
    }

    public static class TestImpl extends JavaFXBaseTest.JavaFXBaseTestImpl {

        @Inject SearchBoxDemoPane root;
        @Inject DemoDataBuilder dataBuilder;

        @Override public boolean isExitAfterTest() {
            return false;
        }

        @Override protected Class&lt;? extends JavaFXBaseTest&gt; getParentTestClass() {
            return SearchBoxTest.class;
        }

        @Override public void testImpl(Stage stage) {
            stage.setTitle("SearchBoxTest");  //i18n
            stage.setScene(new Scene(root, 1024, 786));

            final SearchBoxDemoPaneController controller = root.getController();
            final ObservableList&lt;transientdemodatarow&gt; transientDemoDataRows = dataBuilder.create();
            controller.tableView.setItems(transientDemoDataRows);
            controller.SearchBox.refreshIndex(transientDemoDataRows);
        }
    }
}
]]&gt;&lt;/script&gt;

After this we have a full funktional combination between a full-text SearchBox and a TableView.&lt;br /&gt;
The SearchBox itself is working in this version with a transient Lucene-Index.&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://2.bp.blogspot.com/-O8e8Q0v6s90/Ui7Srr4pCkI/AAAAAAABTcQ/UJKEGo-evK4/s1600/search_step_01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://2.bp.blogspot.com/-O8e8Q0v6s90/Ui7Srr4pCkI/AAAAAAABTcQ/UJKEGo-evK4/s1600/search_step_01.jpg" height="171" width="320" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://3.bp.blogspot.com/-oOSZA0ASumQ/Ui7SrqsW-JI/AAAAAAABTcU/HqrSusRzrNw/s1600/search_step_02.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://3.bp.blogspot.com/-oOSZA0ASumQ/Ui7SrqsW-JI/AAAAAAABTcU/HqrSusRzrNw/s1600/search_step_02.jpg" height="171" width="320" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://1.bp.blogspot.com/-yp873G-WUjM/Ui7Srm3nH3I/AAAAAAABTcs/YyNnboufSgE/s1600/search_step_03.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://1.bp.blogspot.com/-yp873G-WUjM/Ui7Srm3nH3I/AAAAAAABTcs/YyNnboufSgE/s1600/search_step_03.jpg" height="170" width="320" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://1.bp.blogspot.com/-p4AJX4aNNWE/Ui7SsIn5yyI/AAAAAAABTcc/7qzRFXf1BE8/s1600/search_step_04.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://1.bp.blogspot.com/-p4AJX4aNNWE/Ui7SsIn5yyI/AAAAAAABTcc/7qzRFXf1BE8/s1600/search_step_04.jpg" height="170" width="320" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://1.bp.blogspot.com/-IX3WYgvaJJc/Ui7SsbXUntI/AAAAAAABTck/0QwrIf_nm1o/s1600/search_step_05.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://1.bp.blogspot.com/-IX3WYgvaJJc/Ui7SsbXUntI/AAAAAAABTck/0QwrIf_nm1o/s1600/search_step_05.jpg" height="170" width="320" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;span style="font-size: x-small;"&gt;&lt;i&gt;&lt;br /&gt;&lt;/i&gt;&lt;/span&gt;
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>11 lines of code for optimal col size (TableView)</title>
        <category label="JavaFX"/>
        <category label="RapidPM"/>
        <published>2013-09-11T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/09/11/11-lines-of-code-for-optimal-col-size-.html&gt;11 lines of code for optimal col size (TableView)&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-09-11 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
To combine the property &lt;b&gt;tableMenuButtonVisible&lt;/b&gt;="true" from the TableView with the column.&lt;b&gt;prefWidthProperty&lt;/b&gt;() you need not more than 11 lines of code. The result will be a TableView with automatic resizing columns if you are hiding one ore more columns and reverse.&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
        //set optimal size
        final ObservableList&lt;TableColumn&lt;TransientDemoDataRow, ?&gt;&gt; columns = tableView.getColumns();
        final ObservableList&lt;TableColumn&lt;TransientDemoDataRow, ?&gt;&gt; visibleLeafColumns = tableView.getVisibleLeafColumns();
        final int size = visibleLeafColumns.size();
        final SimpleDoubleProperty newSizeProperty = new SimpleDoubleProperty(size);
        visibleLeafColumns.addListener(new ListChangeListener&lt;TableColumn&lt;TransientDemoDataRow, ?&gt;&gt;() {
            @Override public void onChanged(Change&lt;? extends TableColumn&lt;TransientDemoDataRow, ?&gt;&gt; change) {
                final int newSize = change.getList().size();
                newSizeProperty.set(newSize);
            }
        });
        for (final TableColumn&lt;TransientDemoDataRow, ?&gt; column : columns) {
            column.prefWidthProperty().bind(tableView.widthProperty().divide(newSizeProperty));
        }
]]&gt;&lt;/script&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://3.bp.blogspot.com/-EQXJrt8k68w/UjA_-XKLRwI/AAAAAAABTdM/uoG3ewVQJrw/s1600/step01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://3.bp.blogspot.com/-EQXJrt8k68w/UjA_-XKLRwI/AAAAAAABTdM/uoG3ewVQJrw/s1600/step01.jpg" height="266" width="640" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://3.bp.blogspot.com/-C6xLs44_QCI/UjA_-ZVUSeI/AAAAAAABTdQ/pzoOckJdYkc/s1600/step02.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://3.bp.blogspot.com/-C6xLs44_QCI/UjA_-ZVUSeI/AAAAAAABTdQ/pzoOckJdYkc/s1600/step02.jpg" height="250" width="640" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://3.bp.blogspot.com/-mxpi-V1ddkY/UjA_-R66JUI/AAAAAAABTdU/zmQMvA_o-4U/s1600/step03.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://3.bp.blogspot.com/-mxpi-V1ddkY/UjA_-R66JUI/AAAAAAABTdU/zmQMvA_o-4U/s1600/step03.jpg" height="250" width="640" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br /&gt;
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>CDI Callback&lt;TableColumn, TableCell&gt; cellFactory - from FXML</title>
        <category label="Callback"/>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="JavaFX"/>
        <category label="RapidPM"/>
        <category label="TableView"/>
        <published>2013-09-19T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/09/19/cdi-callback-tablecolumn-tablecell-cel.html&gt;CDI Callback&lt;TableColumn, TableCell&gt; cellFactory - from FXML&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-09-19 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
How to get a full managed JavaFX-element declared in the fxml-file?&lt;br/&gt;

Let´s say we have something like the following:&lt;br/&gt;

&lt;script class="brush: javafx" type="syntaxhighlighter"&gt;&lt;![CDATA[
&lt;TableView fx:id="tableView" editable="true" VBox.vgrow="ALWAYS" style="-fx-font-size: 80%"
                   tableMenuButtonVisible="true"&gt;
    &lt;columns&gt;
        &lt;FilterableStringTableColumn prefWidth="120.0" text="vorname"&gt;
            &lt;cellFactory&gt;
                &lt;EditingAutoCompleteStringCellFactory/&gt;
            &lt;/cellFactory&gt;
            &lt;cellValueFactory&gt;
                &lt;PropertyValueFactory property="vorname"/&gt;
            &lt;/cellValueFactory&gt;
        &lt;/FilterableStringTableColumn&gt;
        &lt;FilterableStringTableColumn prefWidth="120.0" text="nachname"&gt;
            &lt;cellFactory&gt;
                &lt;EditingStringCellFactoryCallback/&gt;
            &lt;/cellFactory&gt;
            &lt;cellValueFactory&gt;
                &lt;PropertyValueFactory property="nachname"/&gt;
            &lt;/cellValueFactory&gt;
        &lt;/FilterableStringTableColumn&gt;
        &lt;FilterableDateTableColumn prefWidth="120.0" text="datum"&gt;
            &lt;cellFactory&gt;
                &lt;EditingDateCellFactoryCallback/&gt;
            &lt;/cellFactory&gt;
            &lt;cellValueFactory&gt;
                &lt;PropertyValueFactory property="datum"/&gt;
            &lt;/cellValueFactory&gt;
        &lt;/FilterableDateTableColumn&gt;
        &lt;FilterableDoubleTableColumn prefWidth="120.0" text="betrag"&gt;
            &lt;cellValueFactory&gt;
                &lt;PropertyValueFactory property="betrag"/&gt;
            &lt;/cellValueFactory&gt;
        &lt;/FilterableDoubleTableColumn&gt;
    &lt;/columns&gt;
&lt;/TableView&gt;
]]&gt;&lt;/script&gt;

This looks like a normal definition of a TableView with some cell-factories.
The intressting part is the instantiating of the cellFactory elements. They are
created from the JavaFX part. How to get them as full managed bean?&lt;br/&gt;

Based on my blog entry about  (&lt;a href="http://www.rapidpm.org/2013/08/cdicommonsfx-javafxcdi-bootstrap.html"&gt;CDI-JavaFX bootstrapping&lt;/a&gt;) I wanted to have full cdi managed JavaFX elements but defined in my fxml-file.&lt;br/&gt;

How to get this with a ComboBoxCell you can see here (&lt;a href="http://www.rapidpm.org/2013/09/cdi-comboboxcell-how-to-reduce-80-of.html"&gt;cdi comboboxcell how to reduce 80 of code&lt;/a&gt;)&lt;br/&gt;

The aproach was to define an element that is able to associate itself as CellFactory.
Only two line of code are used during the init - phase:&lt;br/&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
@Inject Instance&lt;BetragComboboxCell&gt; betragComboBoxCellInstance;
 
private void initTable() {
    final BetragComboBoxCell cell = betragComboBoxCellInstance.get();
    cell.associateWithCol(tableView, "betrag");
}
]]&gt;&lt;/script&gt;


BUT: the definition inside the fxml-file is &lt;br/&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
        &lt;FilterableDoubleTableColumn prefWidth="120.0" text="betrag"&gt;
            &lt;cellValueFactory&gt;
                &lt;PropertyValueFactory property="betrag"/&gt;
            &lt;/cellValueFactory&gt;
        &lt;/FilterableDoubleTableColumn&gt;
]]&gt;&lt;/script&gt;

You only could (implicit)define a normal CellFactory, because the creation of this element would be done by JavaFX.&lt;br/&gt;

Now I want to write a more precise fxml file.&lt;br/&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
&lt;FilterableStringTableColumn prefWidth="120.0" text="vorname"&gt;
            &lt;cellFactory&gt;
                &lt;EditingAutoCompleteStringCellFactory/&gt;
            &lt;/cellFactory&gt;
            &lt;cellValueFactory&gt;
                &lt;PropertyValueFactory property="vorname"/&gt;
            &lt;/cellValueFactory&gt;
        &lt;/FilterableStringTableColumn&gt;
]]&gt;&lt;/script&gt;

Now you could see, the CellFactory is well defined. Here an EditingAutoCompleteStringCellFactory.
This is an element with injected autocomplete functions/data.&lt;br/&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class EditingAutoCompleteStringCellFactory 
                implements Callback&lt;TableColumn&lt;FilteredTableDataRow, ?&gt;,
                                      TableCell&lt;FilteredTableDataRow, ?&gt;&gt;
]]&gt;&lt;/script&gt;

Inside this class you can use all cdi features.&lt;br/&gt;

The missing part is: How to get this as managed instance?&lt;br/&gt;
The short answer is.. make it managed by yourself ;-)&lt;br/&gt;

Let´s say the controller is a managed instance, you can get the BeanManager with&lt;br/&gt;

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
@Inject BeanManager beanManager;
]]&gt;&lt;/script&gt;

Now I started to get during the init-phase the right column&lt;br/&gt;

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
final ObservableList&lt;TableColumn&lt;TransientDemoDataRow, ?&gt;&gt; columns = tableView.getColumns();
for (final TableColumn&lt;TransientDemoDataRow, ?&gt; column : columns) {
 if(column.getText().equals("vorname")){ 
   //do something on column
 } else{
  //nothing to do
 }
}
]]&gt;&lt;/script&gt;

After you found the right column, start with the CDI-stuff
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
final TableColumn&lt;TransientDemoDataRow, String&gt; columnString = (TableColumn&lt;TransientDemoDataRow, String&gt;) column;

final Callback&lt;? extends TableColumn&lt;TransientDemoDataRow, String&gt;, ? extends TableCell&lt;TransientDemoDataRow,String&gt;&gt; cellFactory = columnString.getCellFactory();

final AnnotatedType&lt;EditingAutoCompleteStringCellFactory&gt; annotationType = beanManager.createAnnotatedType(EditingAutoCompleteStringCellFactory.class);

final InjectionTarget injectionTarget = beanManager.createInjectionTarget(annotationType);

final CreationalContext&lt;EditingAutoCompleteStringCellFactory&gt; creationalContext = beanManager.createCreationalContext(null);

                injectionTarget.inject(cellFactory, creationalContext);
                injectionTarget.postConstruct(cellFactory);

]]&gt;&lt;/script&gt;

Ready..   but this code is not nice...  and done for every column this is toooooo much code.&lt;br/&gt;

So I started to reduce it.&lt;br/&gt;
- reducing the generics..&lt;br/&gt;
- getting the class from the instance itself&lt;br/&gt;

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
final Callback cellFactory = column.getCellFactory();
final AnnotatedType annotationType = beanManager.createAnnotatedType(cellFactory.getClass());
final InjectionTarget injectionTarget = beanManager.createInjectionTarget(annotationType);
final CreationalContext creationalContext = beanManager.createCreationalContext(null);
injectionTarget.inject(cellFactory, creationalContext);
injectionTarget.postConstruct(cellFactory);
]]&gt;&lt;/script&gt;

Done..  OK, this is short and easy..  and you can do it for every column..&lt;br/&gt;

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
final ObservableList&lt;TableColumn&lt;TransientDemoDataRow, ?&gt;&gt; columns = tableView.getColumns();
for (final TableColumn&lt;TransientDemoDataRow, ?&gt; column : columns) {
 final Callback cellFactory = column.getCellFactory();
 final AnnotatedType annotationType = beanManager.createAnnotatedType(cellFactory.getClass());
 final InjectionTarget injectionTarget = beanManager.createInjectionTarget(annotationType);
 final CreationalContext creationalContext = beanManager.createCreationalContext(null);
 injectionTarget.inject(cellFactory, creationalContext);
 injectionTarget.postConstruct(cellFactory);
}
]]&gt;&lt;/script&gt;

or more generic...&lt;br/&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
final ObservableList&lt;TableColumn&lt;?, ?&gt;&gt; columns = tableView.getColumns();
for (final TableColumn&lt;?, ?&gt; column : columns) {
 final Callback cellFactory = column.getCellFactory();
 final AnnotatedType annotationType = beanManager.createAnnotatedType(cellFactory.getClass());
 final InjectionTarget injectionTarget = beanManager.createInjectionTarget(annotationType);
 final CreationalContext creationalContext = beanManager.createCreationalContext(null);
 injectionTarget.inject(cellFactory, creationalContext);
 injectionTarget.postConstruct(cellFactory);
}
]]&gt;&lt;/script&gt;

Now you can use CDI-managed elements as CellFactories and define them inside your fxml. &lt;br/&gt;

Nice, Managed and TypeSave&lt;br/&gt;
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>CDI ButtonCell</title>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="JavaFX"/>
        <category label="RapidPM"/>
        <category label="TableView"/>
        <category label="Weld"/>
        <published>2013-10-02T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/10/02/cdi-buttoncell.html&gt;CDI ButtonCell&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-10-02 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
&lt;div style="text-align: center;"&gt;
    &lt;i&gt;&lt;span style="font-size: x-small;"&gt;The full code and demo jUnit you will find under :&amp;nbsp;&lt;a href="https://bitbucket.org/rapidpm/modules/src/6e440e241875/javafx-filtered-tableview?at=release/1.1.1" target="_blank"&gt;BitBucket Repo - RapidPM - Modules - javafx-filtered-tableview&lt;/a&gt;&amp;nbsp;&lt;/span&gt;&lt;/i&gt;&lt;/div&gt;
&lt;div style="text-align: center;"&gt;
    &lt;i&gt;&lt;span style="font-size: x-small;"&gt;Please use the release/1.1.1 branch and a commit after&amp;nbsp;&lt;a href="https://bitbucket.org/rapidpm/modules/commits/6e440e241875c2f574741bd1f0e0749054996326"&gt;6e440e2&lt;/a&gt;&amp;nbsp;&lt;/span&gt;&lt;/i&gt;&lt;/div&gt;
&lt;br /&gt;

Today I needed a button inside my TableView.

Something needed to be activated, based on some other values in this row.

How to do this in a nice, lean and decoupled way? One goal was the possibillity that the definition could be done inside the fxml - file.

Let´s start with the basic cdi managed &lt;b&gt;ButtonCell&lt;/b&gt;:

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[ 
public abstract class ButtonCell&lt;T&gt; extends TableCell&lt;T, Boolean&gt; {

    public Button cellButton;
    public abstract String getButtonLabelText();
    private List&lt;ButtonCellAction&lt;T&gt;&gt; actionList = new ArrayList&lt;&gt;();

    private @Inject @CDILogger Logger logger;

    public ButtonCell() {

    }

    @PostConstruct
    public void init(){
        if (logger.isDebugEnabled()) {
            logger.debug("ButtonCell-&gt;init");
        }
        cellButton = new Button(getButtonLabelText());
        cellButton.setOnAction(new EventHandler&lt;ActionEvent&gt;() {
            @Override
            public void handle(ActionEvent t) {
                for (final ButtonCellAction&lt;T&gt; buttonCellAction : actionList) {
                    if (logger.isDebugEnabled()) {
                        logger.debug("execute buttonCellAction-&gt; " + buttonCellAction);
                    }
                    buttonCellAction.execute(ButtonCell.this, t);
                }
            }
        });
    }

    @Override
    protected void updateItem(Boolean t, boolean empty) {
        super.updateItem(t, empty);
        if (!empty) {
            setGraphic(cellButton);
        }
    }

    public static abstract class ButtonCellAction&lt;T&gt; {
        public abstract void execute(ButtonCell&lt;T&gt; buttonCell, ActionEvent t);
    }


    public List&lt;ButtonCellAction&lt;T&gt;&gt; getActionList() {
        return actionList;
    }
}
]]&gt;&lt;/script&gt;

The main part here is the method &lt;b&gt;setOnAction()&lt;/b&gt;: With this we are iterating over a list of ButtonCellActions.
&lt;br/&gt;
Now we have to implement a class for our used TableView. In this example an simple delete-button.
&lt;br/&gt;

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class DeleteButtonCell extends ButtonCell&lt;TransientDemoDataRow&gt; {

    private @Inject @CDILogger Logger logger;
    private @Inject @CDIPropertyRegistryService PropertyRegistryService propertyRegistryService;
    private @Inject DeleteButtonLogic logic;

    @Override public String getButtonLabelText() {
        return propertyRegistryService.getRessourceForKey("delete");
    }

    public DeleteButtonCell() {

    }

    @PostConstruct
    public void init(){
        super.init();
        if (logger.isDebugEnabled()) {
            logger.debug("DeleteButtonCell-&gt;init");
        }
        getActionList().add(new ButtonCellAction&lt;TransientDemoDataRow&gt;() {
            @Override public void execute(ButtonCell&lt;TransientDemoDataRow&gt; buttonCell, ActionEvent t) {
                if (logger.isDebugEnabled()) {
                    final Object source = t.getSource();
                    logger.debug("ButtonCellAction -&gt; " + source);
                }
                final TableRow tableRow = buttonCell.getTableRow();
            }
        });
    }
}
]]&gt;&lt;/script&gt;

At this point we are able to inject all the needed logic (here :&lt;b&gt;DeleteButtonLogic&lt;/b&gt;) to fullfill our task. The logic will be activated inside an implementtion of the class &lt;b&gt;ButtonCellAction&lt;/b&gt;. The order you are filling the Actions is the order the actions are processed. quite easy and mostly all you need.
&lt;br/&gt;
The implementation is easy, but we want to put this to an fxml file like the following?:

&lt;script class="brush: javafx" type="syntaxhighlighter"&gt;&lt;![CDATA[
&lt;TableColumn text="tcdelete" sortable="false"&gt;
 &lt;cellFactory&gt;
  &lt;DeleteButtonCellFactory/&gt;
 &lt;/cellFactory&gt;
 &lt;cellValueFactory&gt;
  &lt;DeleteButtonCellValueFactory/&gt;
 &lt;/cellValueFactory&gt;
&lt;/TableColumn&gt;
]]&gt;&lt;/script&gt;

For this we need the CellFactory and the CellValueFactory.
Both implementations are small:

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class DeleteButtonCellFactory
        implements Callback&lt;TableColumn&lt;TransientDemoDataRow, ?&gt;, TableCell&lt;TransientDemoDataRow, ?&gt;&gt; {

    @Inject Instance&lt;DeleteButtonCell&gt;  deleteButtonCellInstance;

    public DeleteButtonCellFactory() {
        CDIContainerSingleton.getInstance().activateCDI(this);
    }

    @Override public TableCell&lt;TransientDemoDataRow, ?&gt; call(TableColumn&lt;TransientDemoDataRow, ?&gt; column) {
        return deleteButtonCellInstance.get();
    }
}
]]&gt;&lt;/script&gt;

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class DeleteButtonCellValueFactory
        implements Callback&lt;TableColumn.CellDataFeatures&lt;TransientDemoDataRow, Boolean&gt;,ObservableValue&lt;Boolean&gt;&gt; {


    @Override public ObservableValue&lt;Boolean&gt; call(TableColumn.CellDataFeatures&lt;TransientDemoDataRow, Boolean&gt; p) {
        final TransientDemoDataRow value = p.getValue();
        return new SimpleBooleanProperty(value != null);
    }
}
]]&gt;&lt;/script&gt;

This is all..  and the result is nice and clean..
&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://4.bp.blogspot.com/-2UVVaH6biHA/Ukw537ReTJI/AAAAAAABUVc/mULLql4jTi0/s1600/uml-buttoncell.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://4.bp.blogspot.com/-2UVVaH6biHA/Ukw537ReTJI/AAAAAAABUVc/mULLql4jTi0/s400/uml-buttoncell.png" /&gt;&lt;/a&gt;&lt;/div&gt;

 
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>complex PropertyBindings</title>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="Java"/>
        <category label="JavaFX"/>
        <category label="PropertyBinding"/>
        <category label="RapidPM"/>
        <published>2013-10-08T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/10/08/complex-propertybindings.html&gt;complex PropertyBindings&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-10-08 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
Today I had to deal with different dependent input-fields.
&lt;br/&gt;
Let´s say you have (only) two TextFields, leftTextField and rightTextField.
If you writing something into the left TextField you have to calculate something (Logic A) and write it to the right TextField.
If you are writing to the right one you have to calculate something (Logic B) and write it to the left TextField.
&lt;br/&gt;
This example is quite simple, but if you have to deal with a lot of fields with different deps based on a transient context
you have to solve:
&lt;br/&gt;
- cycles between the different components.
&lt;br/&gt;
- in this case, the transient context that was changing the logic (here Logic A and Logic B).
&lt;br/&gt;
&lt;br/&gt;
First the component called PairedTextField.
&lt;br/&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[ 
public class PairedTextField extends Pane {

    private final TextField leftTextField = new TextField();
    private final TextField rightTextField = new TextField();

    private final HBox hb = new HBox();
    private int spacing = 10;

    public PairedTextField() {
        setAnchors(hb, 0.0);
        hb.getChildren().addAll(leftTextField, rightTextField);
        hb.setSpacing(spacing);
        getChildren().add(hb);
        setPadding(new Insets(0, 10, 0, 10));
    }

    private void setAnchors(Node node , Double anchor){
        AnchorPane.setBottomAnchor(node, anchor);
        AnchorPane.setLeftAnchor(node, anchor);
        AnchorPane.setRightAnchor(node, anchor);
        AnchorPane.setTopAnchor(node, anchor);
    }
}

]]&gt;&lt;/script&gt;

Now, how to bind both TextFields to get the result?
If you are binding bidirectional you will get a Stackoverflow. To solve this you can do something like the following:
&lt;br/&gt;
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
leftTextField.setOnKeyTyped(new EventHandler&lt;KeyEvent&gt;() {
            @Override public void handle(KeyEvent keyEvent) {
                rightTextField.textProperty().bind(leftTextFieldBinding);
            }
        });
        leftTextField.setOnKeyReleased(new EventHandler&lt;KeyEvent&gt;() {
            @Override public void handle(KeyEvent keyEvent) {
                rightTextField.textProperty().unbind();
            }
        });

        rightTextField.setOnKeyTyped(new EventHandler&lt;KeyEvent&gt;() {
            @Override public void handle(KeyEvent keyEvent) {
                leftTextField.textProperty().bind(rigthTextFieldBinding);
            }
        });
        rightTextField.setOnKeyReleased(new EventHandler&lt;KeyEvent&gt;() {
            @Override public void handle(KeyEvent keyEvent) {
                leftTextField.textProperty().unbind();
            }
        });
 ]]&gt;&lt;/script&gt;

This simple solution is working well. Binding if you need it, unbind after this. Thanks to JavaFX PropertyBinding ;-)
Finally we have to deal with the different implementations of the logic-part for every request.
&lt;br/&gt;
The class Bindings will give you the method createStringBinding(Callable, Property), with this you can create the Bindings (leftTextFieldBinding, rigthTextFieldBinding).
What you need now is the implementation of the Callable&lt;String&gt;. If you are doing it in the "normal" way you have to write it like the following
    &lt;br/&gt;
    &lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class LeftTextFieldBindingCallable extends Callable&lt;String&gt;{
    final DemoLogic demoLogic = new DemoLogic();

    @Override public String call() throws Exception {
        return "leftTextField - " + demoLogic.doIt();
    }
}
]]&gt;&lt;/script&gt;

    With this solution you are not able to switch the implementation of the attribute "demoLogic". Nicer would be something like
    &lt;br/&gt;
    &lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class LeftTextFieldBindingCallable extends CDICallable&lt;String&gt;{
    @Inject Instance&lt;DemoLogic&gt; demoLogic;

    @Override public String call() throws Exception {
        return "leftTextField - " + demoLogic.get().doIt();
    }
}
]]&gt;&lt;/script&gt;

    With every request you will get the possibility to change the implementation of DemoLogic. The Producer will decide wich implementation will be used.
    &lt;br/&gt;
    &lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class DemoLogicProducer {

    @Produces
    public DemoLogic create(BeanManager beanManager, InjectionPoint injectionPoint){
        //decide which implementation to use...
        //here simple version..
        return  new DemoLogic();
    }
}
]]&gt;&lt;/script&gt;
    &lt;br/&gt;
    Now, putting all together:
    &lt;br/&gt;
    &lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public class PairedTextField extends Pane {

    private final TextField leftTextField = new TextField();
    private final TextField rightTextField = new TextField();

    private final HBox hb = new HBox();
    private int spacing = 10;

    @Inject Instance&lt;LeftTextFieldBindingCallable&gt; leftTextFieldBindingCallableInstance;
    @Inject Instance&lt;RightTextFieldBindingCallable&gt; rightTextFieldBindingCallableInstance;


    public PairedTextField() {
        setAnchors(hb, 0.0);
        hb.getChildren().addAll(leftTextField, rightTextField);
        hb.setSpacing(spacing);
        getChildren().add(hb);
        setPadding(new Insets(0, 10, 0, 10));

        CDIContainerSingleton.getInstance().activateCDI(this);

    }

    @PostConstruct
    public void init(){
        final StringBinding leftTextFieldBinding = Bindings.createStringBinding(leftTextFieldBindingCallableInstance.get(), leftTextField.textProperty());

        final StringBinding rigthTextFieldBinding = Bindings.createStringBinding(rightTextFieldBindingCallableInstance.get(), rightTextField.textProperty());


        leftTextField.setOnKeyTyped(new EventHandler&lt;KeyEvent&gt;() {
            @Override public void handle(KeyEvent keyEvent) {
                rightTextField.textProperty().bind(leftTextFieldBinding);
            }
        });
        leftTextField.setOnKeyReleased(new EventHandler&lt;KeyEvent&gt;() {
            @Override public void handle(KeyEvent keyEvent) {
                rightTextField.textProperty().unbind();
            }
        });

        rightTextField.setOnKeyTyped(new EventHandler&lt;KeyEvent&gt;() {
            @Override public void handle(KeyEvent keyEvent) {
                leftTextField.textProperty().bind(rigthTextFieldBinding);
            }
        });
        rightTextField.setOnKeyReleased(new EventHandler&lt;KeyEvent&gt;() {
            @Override public void handle(KeyEvent keyEvent) {
                leftTextField.textProperty().unbind();
            }
        });
    }


    private void setAnchors(Node node , Double anchor){
        AnchorPane.setBottomAnchor(node, anchor);
        AnchorPane.setLeftAnchor(node, anchor);
        AnchorPane.setRightAnchor(node, anchor);
        AnchorPane.setTopAnchor(node, anchor);
    }
}
]]&gt;&lt;/script&gt;
    &lt;br/&gt;
    The importand parts are:
    &lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[

public abstract class  CDICallable&lt;T&gt; implements Callable&lt;T&gt; {
    protected CDICallable() {
        CDIContainerSingleton.getInstance().activateCDI(this);
    }
}

//...
CDIContainerSingleton.getInstance().activateCDI(this);
//..
 
        final StringBinding leftTextFieldBinding = Bindings.createStringBinding(leftTextFieldBindingCallableInstance.get(), leftTextField.textProperty());

        final StringBinding rigthTextFieldBinding = Bindings.createStringBinding(rightTextFieldBindingCallableInstance.get(), rightTextField.textProperty());


]]&gt;&lt;/script&gt;

    &lt;br/&gt;
    &lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://1.bp.blogspot.com/-VJn5X9vrTig/UlQZiDC4LfI/AAAAAAABUV4/GKtv6srW2SY/s1600/diagram.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://1.bp.blogspot.com/-VJn5X9vrTig/UlQZiDC4LfI/AAAAAAABUV4/GKtv6srW2SY/s400/diagram.png" /&gt;&lt;/a&gt;&lt;/div&gt;


&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>The Central Repository Search Engine</title>
        <category label="Maven"/>
        <category label="RapidPM"/>
        <published>2013-10-11T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/10/11/the-central-repository-search-engine.html&gt;The Central Repository Search Engine&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-10-11 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
The RapidPM-Modules Version 1.1.1 are at maven central now :&amp;nbsp;&lt;a href="http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22rapidpm-parent%22"&gt;The Central Repository Search Engine&lt;/a&gt;: &lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;

&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>The power of the ContextResolver Part I</title>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="JavaFX"/>
        <category label="RapidPM"/>
        <published>2013-10-17T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2013/10/17/the-power-of-the-contextresolver-part-.html&gt;The power of the ContextResolver Part I&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2013-10-17 from &lt;a href="/team/sven-ruppert/"&gt;Sven Ruppert&lt;/a&gt;&lt;/p&gt;
How to use a ContextResolver? What can you do with this?
&lt;br/&gt;
Let´s say you have something like the following:

&lt;pre class="brush: java"&gt;
@Inject @DemoLogicContext DemoLogic demologic;
&lt;/pre&gt;

But it depends on the transient context of the application to decide what is the right implementation of the interface DemoLogic.
&lt;br/&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://2.bp.blogspot.com/-duqsdVLfujI/Ul66G0S0ZdI/AAAAAAABUXc/75QGLk5n0tk/s1600/DemoLogic.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://2.bp.blogspot.com/-duqsdVLfujI/Ul66G0S0ZdI/AAAAAAABUXc/75QGLk5n0tk/s400/DemoLogic.jpg" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br/&gt;
The implementation DemoLogicB is a normal JavaClass, KotlinDemoLogic is writen in &lt;a href="http://kotlin.jetbrains.org/"&gt;Kotlin&lt;/a&gt;.
Both implementations are paired with a qualifier and a producer like the following in the picture.
&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://2.bp.blogspot.com/-Gcbyha4grzI/Ul688KeBy6I/AAAAAAABUXo/TyTdcQC4VnY/s1600/DemoLogicB.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://2.bp.blogspot.com/-Gcbyha4grzI/Ul688KeBy6I/AAAAAAABUXo/TyTdcQC4VnY/s400/DemoLogicB.jpg" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br/&gt;
At this point you have n implementations with n qualiefiers and maybe n producer. Or it must be possible to extend the running system with a few more different customer dependent implementations. To write this inside your code with an big if else tree it is not a good style. From the busineslogic point of view the right definition is:
&lt;pre class="brush: java"&gt;
@Inject @DemoLogicContext DemoLogic demologic;
&lt;/pre&gt;
&lt;br/&gt;
For this you can use the producer methods from cdi. The way is quite easy:

&lt;pre class="brush: java"&gt;
@Produces @DemoLogicContext
public DemoLogic create(){...}
&lt;/pre&gt;
With this you have the entry-point for the final injection point. You can extend the signature of the create method with more attributes. Mostly used is the BeanManager and/or InjectioPoint, but you can use your own classes. For example the &lt;b&gt;ContextResolver&lt;/b&gt;.

&lt;pre class="brush: java"&gt;
@Produces @DemoLogicContext
public DemoLogic create(ContextResolver contextResolver){...}
&lt;/pre&gt;
The ContextResolver itself is an interface.. this means you have to use an qualifier to define the producer or implementing class for this interface.
&lt;pre class="brush: java"&gt;
@Produces @DemoLogicContext
public DemoLogic create(@DemoLogicContext ContextResolver contextResolver){...}
&lt;/pre&gt;

&lt;br/&gt;
Now we have to implement the first class, called DemoContextResolver. The DemoContextResolver will be injected into every producer that must be able to decide something.
&lt;pre class="brush: java"&gt;
public class DemoLogicProducer {
    private @Inject ManagedInstanceCreator creator;

    @Produces @DemoLogicContext
    public DemoLogic create(@New DemoContextResolver contextResolver){
        final Class&lt;DemoLogic&gt; beanType = DemoLogic.class;
    final AnnotationLiteral annotationLiteral = contextResolver.resolveContext(beanType);
    final DemoLogic demoLogic = creator.getManagedInstance(beanType, annotationLiteral);
    return demoLogic;
    }
    }
&lt;/pre&gt;
From this point you are able to decide what will be the implementation to use. For this example I wrote a very simple
version, but you can extend this to a tree of deciding ContextResolvers.
&lt;pre class="brush: java"&gt;
public class DemoContextResolver implements ContextResolver {

    @Inject DemoContext demoContext;

    @Override public AnnotationLiteral resolveContext(Class&lt;?&gt; targetClass) {
        if(demoContext.getContextInfo()){
            return new AnnotationLiteral&lt;KotlinDemoLogicContext&gt;() {};
    } else{
    return new AnnotationLiteral&lt;DemoLogicContextB&gt;() {};
        }
        }
        }
&lt;/pre&gt;


The good thing is, that every module will be usable for itself. You can write jUnit-Tests per implementation. At runtime you can add more implementations.

Think about the possibility to change the controller for a GUI in this way ;-)
I will show this more in detail in my next blog entry (Part II)
&lt;br/&gt;

&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://2.bp.blogspot.com/-pvUtFOprIyE/Ul-dDY48llI/AAAAAAABUX4/_HjQF9mLpyE/s1600/full-uml.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://2.bp.blogspot.com/-pvUtFOprIyE/Ul-dDY48llI/AAAAAAABUX4/_HjQF9mLpyE/s400/full-uml.png" /&gt;&lt;/a&gt;&lt;/div&gt;



&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>One way to deadlock a JBoss AS 7</title>
        <category label="Deadlock"/>
        <category label="EJB"/>
        <category label="JBoss"/>
        <category label="RapidPM"/>
        <published>2014-02-03T00:00:00+01:00</published>
        <author>
            <name>Alexander Bischof</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2014/02/03/one-way-to-deadlock-a-jboss-as-7.html&gt;One way to deadlock a JBoss AS 7&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2014-02-03 from &lt;a href="/team/alexander-bischof/"&gt;Alexander Bischof&lt;/a&gt;&lt;/p&gt;
Take a standard JBoss AS 7 and create/deploy a simple remote stateless session bean with two methods. One of them should
be asynchronous. As shown in the following example the asynchronous method creates a little bit of load and the second one&amp;nbsp;simulates a login.

&lt;br /&gt;
&lt;pre class="brush: java"&gt;public interface IMyBean
{
 Future&amp;lt;Void&amp;gt; doNothing();
 void login();
}&lt;/pre&gt;
&lt;pre class="brush: java"&gt;@Stateless
@Remote(IMyBean.class)
public class MyBean implements IMyBean
{
 @Override
 @Asynchronous
 public Future&amp;lt;Void&amp;gt; doNothing()
 {
  //Creates Load
  int lo = 0;
  for (int i = 0; i &amp;lt; 5000; i++)
  {
   lo += i;
  }
  System.out.println("nothing done");
  return new AsyncResult&amp;lt;Void&amp;gt;(null);
 }
 @Override
 public void login()
 {
  System.out.println("logged in");
 }
}
&lt;/pre&gt;
In the next step besides 10 EJB-Remote-Clients which access the asynchronous method parallel&amp;nbsp;we create an additional client which repeatly tries to login.
(Note: Classpath contains jboss-ejb-client.properties and jboss-client.jar)

&lt;br /&gt;
&lt;pre class="brush: java"&gt;public class HangTest
{
 public static void main(String args[]) throws NamingException
 {
  //EJB-Remote-Access
  Properties jndiProps = new Properties();
  jndiProps.put(Context.URL_PKG_PREFIXES, "org.jboss.ejb.client.naming");
  Context context = new InitialContext(jndiProps);
  final IMyBean myBean = (IMyBean) context.lookup("ejb:/hangtest/MyBean!IMyBean");

  //Create and start asynchronous method threads
  final List&amp;lt;Thread&amp;gt; threadList = new ArrayList&amp;lt;&amp;gt;();
  for (int i = 0; i &amp;lt; 10; i++)
  {
   Thread thread = new Thread()
   {
    @Override
    public void run()
    {
     try
     {
      myBean.doNothing().get();
     }
     catch(Exception e)
     {
      e.printStackTrace();
     }
     finally
     {
      threadList.remove(this);
     }
    }
   };
   threadList.add(thread);
   thread.start();
  }

  //Repeated Login
  while(!threadList.isEmpty())
  {
   System.out.println("Try login...");
   myBean.login();
  }
 }
}
&lt;/pre&gt;
The code above works as expected which means that random server messages ("nothing done", "logged in") are printed out and that the login client can login. It also can be executed as many times as you want without a change in behavior.&lt;br /&gt;
BUT if you increase the number of asynchronous method clients for example to 20-30 (depending on your computer) then nothing is printed out and the login client can not login anymore. The JBoss or -&amp;nbsp;to be more specific - some&amp;nbsp;components of it are in a deadlock
(Note: JBoss shutdown does not work anymore).

So what has happened?&lt;br /&gt;
&lt;br /&gt;
To answer this question we have to look into the standalone.xml, especially in the subsystem "urn:jboss:domain:ejb3". This section contains ejb3-related configurations and among them threadpools.&amp;nbsp;In this context it is important&amp;nbsp;that the default threadpool is shared between asynchronous calls, timers and ejb-remote.
&lt;br /&gt;
&lt;pre class="brush: java"&gt;&amp;lt;subsystem xmlns="urn:jboss:domain:ejb3:1.2"&amp;gt;&lt;/pre&gt;
&lt;pre class="brush: java"&gt;...
 &amp;lt;async thread-pool-name="default"/&amp;gt;
 &amp;lt;timer-service thread-pool-name="default"&amp;gt;
  &amp;lt;data-store path="timer-service-data" relative-to="jboss.server.data.dir"/&amp;gt;
        &amp;lt;/timer-service&amp;gt;
 &amp;lt;remote connector-ref="remoting-connector" thread-pool-name="default"&amp;gt;
  &amp;lt;thread-pools&amp;gt;
   &amp;lt;thread-pool name="default"&amp;gt;
    &amp;lt;max-threads count="10"/&amp;gt;
    &amp;lt;keepalive-time time="100" unit="milliseconds"/&amp;gt;
   &amp;lt;/thread-pool&amp;gt;
  &amp;lt;/thread-pools&amp;gt;
   &amp;lt;/remote&amp;gt;
&amp;lt;/subsystem&amp;gt;&lt;/pre&gt;
&lt;br /&gt;
So if you stumble upon that problem either increase the max-thread count property or even better seperate the thread-pools for asynchronous and ejb-remote components. &lt;br /&gt;
&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>CDI EJB-Remote Context for wildfly</title>
        <category label="CDI"/>
        <category label="EJB"/>
        <category label="JBoss"/>
        <category label="JNDI"/>
        <category label="RapidPM"/>
        <category label="Wildfly"/>
        <published>2014-02-17T00:00:00+01:00</published>
        <author>
            <name>Alexander Bischof</name>
        </author>
        <content type="html">&lt;div class="blog-post"&gt;
&lt;h2 class="blog-post-title"&gt;&lt;a href=/2014/02/17/cdi-ejb-remote-context-for-wildfly.html&gt;CDI EJB-Remote Context for wildfly&lt;/a&gt;&lt;/h2&gt;
&lt;p class="blog-post-meta"&gt;2014-02-17 from &lt;a href="/team/alexander-bischof/"&gt;Alexander Bischof&lt;/a&gt;&lt;/p&gt;
&lt;div&gt;
    This article shows how ejb remote clients can be configured and connected in a more dynamic way.&lt;/div&gt;
&lt;div&gt;
    &lt;br /&gt;&lt;/div&gt;
Within wildfly (current version 8.0.0.Final) there are several possibilities to connect ejb remote clients. Descriptions can be found on:&lt;br /&gt;
&lt;div&gt;
    &lt;ul&gt;
        &lt;li&gt;the standard way with jboss-ejb-client.properties&lt;br /&gt;&lt;a href="https://docs.jboss.org/author/display/WFLY8/Remote+EJB+invocations+via+JNDI+-+EJB+client+API+or+remote-naming+project"&gt;https://docs.jboss.org/author/display/WFLY8/Remote+EJB+invocations+via+JNDI+-+EJB+client+API+or+remote-naming+project&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;a programmatic way&lt;br /&gt;&lt;a href="http://alexbischoftechwriteups.blogspot.de/2013/11/jboss-as-7-programmatic-ejb-remote.html"&gt;http://alexbischoftechwriteups.blogspot.de/2013/11/jboss-as-7-programmatic-ejb-remote.html&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h4&gt;
    &lt;/h4&gt;
    &lt;h3&gt;
    &lt;/h3&gt;
    &lt;h3&gt;
        The Problem&lt;/h3&gt;
    &lt;div&gt;
        &lt;br /&gt;
        You have an application for two (or more) tenants which are identical but are deployed on different machines. Customers should be able to switch between those tenants without restarting the application. Additionally the code itself should not depend on tenant specific code.&lt;br /&gt;
        As far as i know this would be necessary with the standard approach (jboss-ejb-client.properties) given above.&lt;br /&gt;
        &lt;br /&gt;&lt;/div&gt;
    &lt;h4&gt;
    &lt;/h4&gt;
    &lt;h3&gt;
    &lt;/h3&gt;
    &lt;h3&gt;
        A Solution&lt;/h3&gt;
    &lt;div&gt;
        &lt;br /&gt;
        After some consideration i have identified the following five components which are needed to implement this feature.&lt;/div&gt;
    &lt;div&gt;
        &lt;ul&gt;
            &lt;li&gt;Component that creates WildFly ejb remote connections&lt;/li&gt;
            &lt;li&gt;Component that produces the JNDI-Context&lt;/li&gt;
            &lt;li&gt;Component that holds the selected tenant-key for the client&lt;/li&gt;
            &lt;li&gt;Component that maps the tenant-keys to connection properties&lt;/li&gt;
            &lt;li&gt;CDI-Modul Qualifier&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;br /&gt;
        Putting them together leads to the following UML:&lt;/div&gt;
    &lt;div&gt;
        &lt;br /&gt;&lt;/div&gt;
    &lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;div class="separator" style="clear: both; text-align: center;"&gt;
        &lt;/div&gt;
        &lt;div class="separator" style="clear: both; text-align: center;"&gt;
            &lt;a href="http://1.bp.blogspot.com/-ZZPEg3qbdpU/UwEe92qwxaI/AAAAAAAAACM/dWExN23jkkk/s1600/diagram.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://1.bp.blogspot.com/-ZZPEg3qbdpU/UwEe92qwxaI/AAAAAAAAACM/dWExN23jkkk/s1600/diagram.png" height="382" width="640" /&gt;&lt;/a&gt;&lt;/div&gt;
        &lt;br /&gt;&lt;/div&gt;
    &lt;div&gt;
        &lt;br /&gt;&lt;/div&gt;
    &lt;div&gt;
        To keep the example as simple as possible i have decided to use the ejb-remote-quickstart example and extend it with the jndicontext module. The current implementation uses a simple property file which holds the following data.&lt;/div&gt;
    &lt;div&gt;
&lt;pre&gt;tenant1.host=localhost
tenant1.port=8080
tenant1.username=test
tenant1.password=test
tenant1.noanonymous=false

tenant2.host=192.168.0.104
tenant2.port=8080
tenant2.username=test
tenant2.password=test
tenant2.noanonymous=false
&lt;/pre&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;br /&gt;&lt;/div&gt;
    &lt;div&gt;
        &lt;h3&gt;
            The Fazit&lt;/h3&gt;
        &lt;br /&gt;
        The resulting service locator just has to use the JndiSession (in this example the RemoteEJBClient) which technically holds the tenant key and can be set from the GUI.&lt;br /&gt;
        &lt;div&gt;
&lt;pre&gt;public class RemoteEJBClient {
    @Inject @JndiContextAnno
    Instance&amp;lt;Context&amp;gt; contextInstance;

    @Inject
    JndiSession jndiSession;
    //...snip
    private RemoteCalculator lookupRemoteStatelessCalculator() throws NamingException {
        Context context = contextInstance.get();
        //...snip
    }
}

public class CDIBootStrapper {
    public static void main(String[] args) throws Exception
    {
        WeldContainer weld = new Weld().initialize();
        RemoteEJBClient client = weld.instance().select(RemoteEJBClient.class).get();

        client.getJndiSession().setTenantKey("tenant1");
        client.invokeStatelessBean();

        client.getJndiSession().setTenantKey("tenant2");
        client.invokeStatelessBean();
    }
)&lt;/pre&gt;
        &lt;/div&gt;
        So the code looks very clean and in comparison to jboss-ejb-client.properties way more functional.&lt;br /&gt;
        The sources can be found on&amp;nbsp;&lt;a href="https://bitbucket.org/abischof/injectablejndicontext"&gt;https://bitbucket.org/abischof/injectablejndicontext&lt;/a&gt;.&lt;br /&gt;
        Have fun coding... ;)&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
</feed>
